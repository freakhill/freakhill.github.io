<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

      <title>Johan Gall</title>

      <!-- CSS -->
      <link rel="stylesheet" href="https:&#x2f;&#x2f;www.johangall.com&#x2f;print.css" media="print">
      <link rel="stylesheet" href="https:&#x2f;&#x2f;www.johangall.com&#x2f;poole.css">
      <link rel="stylesheet" href="https:&#x2f;&#x2f;www.johangall.com&#x2f;hyde.css">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

      

      
      
    </head>

    <body class="theme-base-0e layout-reverse">
        
            <div class="sidebar">
                <div class="container sidebar-sticky">
                    <div class="sidebar-about">
                        
                            <a href="https:&#x2f;&#x2f;www.johangall.com"><h1>Johan Gall</h1></a>
                            
                            <p class="lead">aka jojo, lucyjojo, freakhill, seku</p>
                            
                        
                    </div>

                    <ul class="sidebar-nav">
                        
                        
                        <li class="sidebar-nav-item"><a href="https:&#x2f;&#x2f;www.youtube.com&#x2f;watch?v=NYgq75uIMUk">SFV beginner guide</a></li>
                        
                        <li class="sidebar-nav-item"><a href="https:&#x2f;&#x2f;github.com&#x2f;freakhill&#x2f;jojolisp">Jojolisp&#x27;s github repo</a></li>
                        
                        <li class="sidebar-nav-item"><a href="https:&#x2f;&#x2f;www.twitch.tv&#x2f;lucyjojo">Twitch channel</a></li>
                        
                        <li class="sidebar-nav-item"><a href="http:&#x2f;&#x2f;www.metro.tokyo.jp&#x2f;english&#x2f;guide&#x2f;bosai&#x2f;index.html">Disaster preparedness Tokyo</a></li>
                        
                        <li class="sidebar-nav-item"><a href="http:&#x2f;&#x2f;www.google.co.jp">Ambulance = 119</a></li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div class="content container">
            
<div class="post">
  <h1 class="post-title">I&#x27;m building a Lisp on the side</h1>
  <span class="post-date">2019-03-17</span>
  <p>I want to make a lisp to develop games on PC and consoles.</p>
<p>Use F-Expr and pervasive full program optimization, partial interpreter &amp; LLVM code generation.</p>
<p>partial evaluator + effect system + &quot;collapse tower of interpreters&quot; paper?</p>
<p>First order locality, packing, static &amp; dynamic environments.</p>
<p>No GC, support for rust Pin/Unpin (build up support of gc as a library)</p>
<p>Concepts:</p>
<ul>
<li>Locality</li>
<li>Packing = Tilling * Alignment * Size of each field</li>
<li>Modules</li>
<li>Each symbol has an API and a version, and a locality</li>
<li>do not export libraries/packages, but functions and static bundles each with api/version/and dependencies</li>
</ul>
<p>possibility to hint fix registers to store specific data
(for instance when making a VM keep the virtual pc in a specific register to avoid spilling)</p>
<p>http://lua-users.org/lists/lua-l/2011-02/msg00742.html</p>
<p>https://www.reddit.com/r/programming/comments/badl2/luajit_2_beta_3_is_out_support_both_x32_x64/c0lrus0/</p>
<p>when compiling/linking, possibility to hand tile the objects, keep the hotpaths close to each-other to be more I-cache friendly</p>
<p>Think about:</p>
<ul>
<li>How to do polymorphism?? in our multi-stage compiling system</li>
</ul>
<p>We want flow typing
We want to be able to bind to C libraries fast, so we can call LLVM/Z3 from inside
our language.</p>
<p>// There are no macros in jojolist, only applicative and operatives
// [1 2 3] ‚â° (array 1 2 3)
// &quot;abc&quot; ‚â° (packing --stuff--for-unicode-packing-- (array 65 66 67??))
// {.offset_member 1 @ptr_member 12 &gt;&quot;dict member&quot; 77} ‚â° (packing ~~~ (record ...))
// tilling [0 (n [1]) (n [2]) (n [3 4 5]) 6 7 (m [8])]
// align ...
// sizes ...
// packing tilling x align x size</p>
<h2 id="stuff-to-check-out">Stuff to check out<a class="zola-anchor" href="#stuff-to-check-out" aria-label="Anchor link for: stuff-to-check-out">üîó</a>
</h2>
<ul>
<li><a href="https://github.com/mrakgr/The-Spiral-Language">Spiral language</a></li>
<li><a href="https://www.johangall.com/jojolisp/">Vau</a></li>
<li><a href="https://www.johangall.com/jojolisp/">ATS</a></li>
<li><a href="https://github.com/halgari/heliotrope">Heliotrope</a></li>
<li><a href="https://github.com/namin/pink">Pink</a></li>
<li><a href="http://lampwww.epfl.ch/%7Eamin/pub/collapsing-towers.pdf">Collapsing towers of interpreters</a></li>
<li><a href="https://github.com/egison/egison">Egison language</a> and its great pattern matching</li>
<li><a href="https://www.johangall.com/jojolisp/">Learn ADA/Spark</a></li>
<li>look for the source for rust's lifetime checker</li>
<li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/1992/01/student.pdf">implementing functional languages</a></li>
<li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/1992/04/spineless-tagless-gmachine.pdf">spineless tagless machine</a></li>
<li><a href="https://wiki.clean.cs.ru.nl/Functional_Programming_and_Parallel_Graph_Rewriting">functional programming and parallel graph rewriting</a></li>
<li><a href="https://llvm.org/docs/LangRef.html">llvm reference manual</a></li>
<li><a href="http://llvm.org/docs/">llvm docs</a></li>
<li><a href="https://queue.acm.org/detail.cfm?id=2991130">great article about locks!</a></li>
</ul>
<h2 id="an-argument-againat-resumable-exceptions">An argument againat resumable exceptions<a class="zola-anchor" href="#an-argument-againat-resumable-exceptions" aria-label="Anchor link for: an-argument-againat-resumable-exceptions">üîó</a>
</h2>
<p><a href="https://books.google.co.jp/books?id=hS9mDwAAQBAJ&amp;lpg=PT459&amp;ots=xNle_k81Rl&amp;dq=bjarne%20stroustrup%20against%20resumable%20exceptoni&amp;pg=PT459#v=onepage&amp;q=bjarne%20stroustrup%20against%20resumable%20exceptoni&amp;f=false">From Bjarne Stroupstrup - Design and evolution of C++</a></p>
<h2 id="halide">Halide<a class="zola-anchor" href="#halide" aria-label="Anchor link for: halide">üîó</a>
</h2>
<p>In Jojolisp we already have the idea of separating a data structure definition (fields, open or close etc.) from its implementation (packing, order etc.).</p>
<p>Halide pushes further by separating an algorithm definition (a + b * c) from its implementation (vertorization, parallelisation etc.)!</p>
<p>This separations allows to experiment with different implementation strategies a lot faster (and is one nice step in implementing some degree of automatic high level optimization.</p>
<p>Halide works on matrix/array operations.</p>
<h3 id="notes-from-halide-talks">Notes from Halide talks<a class="zola-anchor" href="#notes-from-halide-talks" aria-label="Anchor link for: notes-from-halide-talks">üîó</a>
</h3>
<p>(Re)organizing computation is hard:</p>
<ul>
<li>Optimizing parallelism/locality requires transforming program &amp; data structure</li>
<li>What transformations are legal?</li>
<li>What transformations are beneficial?</li>
</ul>
<p>Halide‚Äôs answer: decouple algorithm from schedule</p>
<p>Algorithm: what is computed</p>
<p>Schedule: where and when it‚Äôs computed</p>
<p>Easy for programmers to build pipelines</p>
<p>Easy to specify &amp; explore optimizations manual or automatic search</p>
<p>Easy for the compiler to generate fast code</p>
<p>How can we determine good schedules?</p>
<p>Explicit programmer control: </p>
<ul>
<li>The compiler does exactly what you say</li>
<li>Schedules cannot influence correctness</li>
<li>Exploration is fast and easy</li>
</ul>
<p>Stochastic search (autotuning):</p>
<ul>
<li>Pick your favorite high-dimensional search.(We used Petabricks‚Äô genetic algorithm tuner [Ansel et al. 2009])</li>
</ul>
<p>\ /// </p>
<p>BIG POINT : LOOPS ARE IMPLICIT IN HALIDE</p>
<h2 id="ada-spark">ADA/SPARK<a class="zola-anchor" href="#ada-spark" aria-label="Anchor link for: ada-spark">üîó</a>
</h2>
<p>...</p>
<h3 id="spiral">Spiral<a class="zola-anchor" href="#spiral" aria-label="Anchor link for: spiral">üîó</a>
</h3>
<p>...</p>
<h3 id="vau-klisp-kernel">Vau/KLisp/Kernel<a class="zola-anchor" href="#vau-klisp-kernel" aria-label="Anchor link for: vau-klisp-kernel">üîó</a>
</h3>
<p>...</p>
<h3 id="midori">Midori<a class="zola-anchor" href="#midori" aria-label="Anchor link for: midori">üîó</a>
</h3>
<p>Research project at microsoft about programming languages, compilers, OS, services, application, programming model etc. etc.</p>
<h4 id="safety">Safety<a class="zola-anchor" href="#safety" aria-label="Anchor link for: safety">üîó</a>
</h4>
<p><a href="http://joeduffyblog.com/2015/11/03/a-tale-of-three-safeties/">source</a></p>
<p>Goal =&gt; eliminate bugs &quot;by construction&quot;, allowing the mental space to go for more advanced/complex design optimizations</p>
<ul>
<li>memory safety</li>
<li>type safety</li>
<li>concurrency safety</li>
</ul>
<p>Many approaches are available.</p>
<p>Software fault isolation =&gt; runtime cose, cannot fully exploit type&amp;concurrency safety</p>
<p>Language-based safety =&gt; type system &amp; local checks, prohibits categories of behaviours, safety holes avoided while writing code instead of at runtime. still some optional runtime checks (ex: array bound). however, if the type system is unsound there is no software fault isolation safety net...</p>
<p>Use a mix of these for defense in depth.</p>
<p>Example: runtime approach =&gt; google c++ sanitizers and microsoft's &quot;/guard&quot; feature. language approach =&gt; anything non C pretty much, careful of the escape hatches like the &quot;unsafe&quot; keyword in C#.

As small as possible amount of encapsulated unsafe code, isolated by component (&quot;Trusted Computing Base&quot;). OS scheduler, memory manager, all applications etc. were written in 100% safe code. Reliance on type safety =&gt; compiler part of the TCP. Limit the compiler related risks with &quot;proof carrying code&quot; and &quot;typed assembly language&quot; (TAL). Some amount of runtime checks will lessen the risk.</p>
<p>The cost? There is some stuff you can't dfo without pointer arithmetic, data races, etc. Their research was about how to minimize those costs. They were pretty succesful. They could unlock things like no blocking IO/lightweight processes.fine frained concurrency/asynchonous message passing etc. in a pervasive way which in the end offset the costs.</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">For example, we did have certain types that were just buckets of bits. But these were just PODs. This allowed us to parse bits out of byte buffers ‚Äì and casting to and fro between different wholly differnt ‚Äútypes‚Äù ‚Äì efficiently and without loss of safety. We had a first class slicing type that permit us to form safe, checked windows over buffers, and unify the way we accessed all memory in the system (the slice type we‚Äôre adding to .NET was inspired by this).

</span><span style="color:#c0c5ce;">You might also wonder about the RTTI overheads required to support type safety. Well, thanks to PODs, and proper support for discriminated unions, we didn‚Äôt need to cast things all that much. And anywhere we did, the compiler optimized the hell out of the structures. The net result wasn‚Äôt much more than what a typical C++ program has just to support virtual dispatch (never mind casting).

</span><span style="color:#c0c5ce;">A general theme that ran throughout this journey is that compiler technology has advanced tremendously in the past 20 years. In most cases, safety overheads can be optimized very aggressively. That‚Äôs not to say they drop to zero, but we were able to get them within the noise for most interesting programs. And ‚Äì surprisingly ‚Äì we found plenty of cases where safety enabled new, novel optimization techniques! For example, having immutability in the type system permit us to share pages more aggressively across multiple heaps and programs; teaching the optimizer about contracts let us more aggressively hoist type safety checks; and so on.

</span><span style="color:#c0c5ce;">Another controversial area was concurrency safety. Especially given that the start of the project overlapped with the heady multicore days of the late 2000s. What, no parallelism, you ask?

</span><span style="color:#c0c5ce;">Note that I didn‚Äôt say we banned concurrency altogether, just that we banned unsafe concurrency. First, most concurrency in the system was expressed using message passing between lightweight software isolated processes. Second, within a process, we formalized the rules of safe shared memory parallelism, enforced through type system and programming model rules. The net result was that you couldn‚Äôt write a shared memory data race.

</span><span style="color:#c0c5ce;">They key insight driving the formalism here was that no two ‚Äúthreads‚Äù sharing an address space were permitted to see the same object as mutable at the same time. Many could read from the same memory at once, and one could write, but multiple could not write at once. A few details were discussed in our OOPSLA paper, and Rust achieved a similar outcome and documented it nicely. It worked well enough for many uses of fine-grained parallelism, like our multimedia stack.

</span><span style="color:#c0c5ce;">Since Midori, I‚Äôve been working to bring some of our key lessons about how to achieve simultaneous safety and performance to both .NET and C++. Perhaps the most visible artifact are the safety profiles we recently launched as part of the C++ Core Guidelines effort. I expect more to show up in C# 7 and the C# AOT work we‚Äôre doing right now as we take .NET cross-platform. Midori was greenfield, whereas these environments require delicate compromises, which has been fun, but slowed down some of the transfer of these ideas into production. I‚Äôm happy to finally start seeing some of it bearing fruit.

</span><span style="color:#c0c5ce;">The combination of memory, type, and concurrency safety gave us a powerful foundation to stand on. Most of all, it delivered a heightened level of developer productivity and let us move fast. The extremely costly buffer overflows, data races, deadlocks, and so on, simply did not happen. Someday all operating systems will be written this way.

</span><span style="color:#c0c5ce;">In the next article in this series, we‚Äôll look at how this foundational safety let us deliver a capability-based security model that was first class in the programming model and type system, and brought the same ‚Äúby-construction‚Äù solution to eliminating ambient authority and enabling the principle of least privilege everywhere, by default, in a big way. See you next time.
</span></pre><h4 id="objects-as-secure-capabilities">Objects as secure capabilities<a class="zola-anchor" href="#objects-as-secure-capabilities" aria-label="Anchor link for: objects-as-secure-capabilities">üîó</a>
</h4>
<p><a href="http://joeduffyblog.com/2015/11/10/objects-as-secure-capabilities/">source</a></p>
<p>Last time, we saw how Midori built on a foundation of type, memory, and concurrency safety. This time, we will see how this enabled some novel approaches to security. Namely, it let our system eliminate ambient authority and access control in favor of capabilities woven into the fabric of the system and its code. As with many of our other principles, the guarantees were delivered ‚Äúby-construction‚Äù via the programming language and its type system.
Capabilities</p>
<p>First and foremost: what the heck are capabilities?</p>
<p>In the security systems most of us know and love, i.e. UNIX and Windows, permission to do something is granted based on identity, typically in the form of users and groups. Certain protected objects like files and system calls have access controls attached to them that restrict which users and groups can use them. At runtime, the OS checks that the requested operation is permitted based on these access controls, using ambient identity like what user is running the current process.</p>
<p>To illustrate this concept, consider a simple C call to the open API:</p>
<p>void main() {
int file = open(&quot;filename&quot;, O_RDONLY, 0);
// Interact with <code>file</code>...
}</p>
<p>Internally, this call is going to look at the identity of the current process, the access control tables for the given file object, and permit or reject the call accordingly. There are various mechanisms for impersonating users, like su and setuid on UNIX and ImpersonateLoggedOnUser on Windows. But the primary point here is that open just ‚Äúknew‚Äù how to inspect some global state to understand the security implications of the action being asked of it. Another interesting aspect of this is that the O_RDONLY flag is passed, asking for readonly access, which factors into the authorization process too.</p>
<p>Well, what‚Äôs wrong with this?</p>
<p>It‚Äôs imprecise. It relies on ambient state that is invisible to the program. You can‚Äôt easily audit to see the security implications of the operation. You just need to know how open works. And thanks to its imprecision, it‚Äôs easy to get wrong, and going here wrong means security vulnerabilities. Specifically, it‚Äôs easy to trick a program into doing something on behalf of a user that it was never intended to do. This is called the ‚Äúconfused deputy problem‚Äù. All you need to do is trick the shell or program into impersonating a superuser, and you‚Äôre home free.</p>
<p>Capability-based security, on the other hand, isn‚Äôt reliant on global authority in this same way. It uses so-called ‚Äúunforgeable tokens‚Äù to represent the ability to perform privileged operations. No matter how the decision gets made ‚Äì there is an entirely complex topic of policy management and granting authority that gets into social and human behaviors ‚Äì if the software isn‚Äôt meant to perform some operation, it simply never receives the token necessary to do said operation. And because tokens are unforgeable, the program can‚Äôt even attempt the operation. In a system like Midori‚Äôs, type safety meant that not only could the program not perform the operation, it would often be caught at compile-time.</p>
<p>Insecure operations rejected at compile-time, how cool is that!</p>
<p>The hypothetical open API from earlier, as you may have guessed, would look very different:</p>
<p>void main(File file) {
// Interact with <code>file</code>...
}</p>
<p>OK, clearly we‚Äôre not in Kansas anymore. This is extremely different. And I‚Äôve just passed the buck. Someone else has to show up with a File object? How do they get one?</p>
<p>The trite answer is, who cares, that‚Äôs up to the caller. But if they do show up with one, they must have been authorized to get it, because object references in a type safe system are unforgeable. The matter of policy and authorization are now pushed to the source where, arguably, they belong.</p>
<p>I‚Äôm over-simplifying a little bit, since this answer likely raised more questions than it actually answered. Let‚Äôs keep digging deeper.</p>
<p>So, again, let‚Äôs ask the question: how does one get their hands on a File object?</p>
<p>The code above neither knows nor cares whether where it came from. All it knows is it is given an object with a File-like API. It might have been new‚Äòd up by the caller. More likely, it was obtained by consulting a separate entity, like a Filesystem or a Directory, both of which are also capability objects:</p>
<p>Filesystem fs = ...;
Directory dir = ... something(fs) ...;
File file = ... something(dir) ...;
MyProgram(file);</p>
<p>You might be getting really angry at me now. Where did fs come from? How did I get a Directory from fs, and how did I get a File from dir? I‚Äôve just squished all the interesting topics around, like a water balloon, and answered nothing at all!</p>
<p>The reality is that those are all the interesting questions you encounter now when you try to design a filesystem using capabilities. You probably don‚Äôt want to permit free enumeration of the entire filesystem hierarchy, because if you get access to a Filesystem object ‚Äì or the system‚Äôs root Directory ‚Äì you can access everything, transitively. That‚Äôs the sort of thinking you do when you begin dealing with capabilities. You think hard about information encapsulation and exposure, because all you‚Äôve got are objects to secure your system. Probably, you‚Äôll have a way that a program requests access to some state somewhere on the Filesystem, declaratively, and then the ‚Äúcapability oracle‚Äù decides whether to give it to you. This is the role our application model played, and is how main got its hands on the capabilities a program‚Äôs manifest demanded that it needs. From that point onwards it‚Äôs just objects. The key is that nowhere in the entire system will you find the classical kind of ambient authority, and so none of these abstractions can ‚Äúcheat‚Äù in their construction.</p>
<p>A classic paper, Protection, by Butler Lampson clearly articulates some of the key underlying principles, like unforgeable tokens. In a sense, each object in our system is its own ‚Äúprotection domain.‚Äù I also love Capability Myths Demolished‚Äôs way of comparing and contrasting capabilities with classical security models, if you want more details (or incorrectly speculate that they might be isomorphic).</p>
<p>Midori was by no means the first to build an operating systems with object capabilities at its core. In fact, we drew significant inspiration from KeyKOS and its successors EROS and Coyotos. These systems, like Midori, leveraged object-orientation to deliver capabilities. We were lucky enough to have some of the original designers of those projects on the team.</p>
<p>Before moving on, a warning‚Äôs in order: some systems confusingly use the term ‚Äúcapability‚Äù even though aren‚Äôt true capability systems. POSIX defines such a system and so both Linux and Android inherit it. Although POSIX capabilities are nicer than the typical classical ambient state and access control mechanisms ‚Äì enabling finer-grained controls than usual ‚Äì they are closer to them than the true sort of capability we‚Äôre discussing here.
Objects and State</p>
<p>A nice thing about capabilities just being objects is that you can apply existing knowledge about object-orientation to the domains of security and authority.</p>
<p>Since objects represent capabilities, they can be as fine or coarse as you wish. You can make new ones through composition, or modify existing ones through subclassing. Dependencies are managed just like any dependencies in an object-oriented system: by encapsulating, sharing, and requesting references to objects. You can leverage all sorts of classic design patterns suddenly in the domain of security. I do have to admit the simplicity of this idea was jarring to some.</p>
<p>One fundamental idea is revocation. An object has a type and our system let you substitute one implementation in place of another. That means if you ask me for a Clock, I needn‚Äôt give you access to a clock for all time, or even the real one for that matter. Instead, I can give you my own subclass of a Clock that delegates to the real one, and rejects your attempts after some event occurs. You‚Äôve got to either trust the source of the clock, or explicitly safe-guard yourself against it, if you aren‚Äôt sure.</p>
<p>Another concept is state. In our system, we banned mutable statics, by-construction at compile-time, in our programming language. That‚Äôs right, not only could a static field only be written to once, but the entire object graph it referred to was frozen after construction. It turns out mutable statics are really just a form of ambient authority, and this approach prevents someone from, say, caching a Filesystem object in a global static variable, and sharing it freely, thereby creating something very similar to the classical security models we are seeking to avoid. It also had many benefits in the area of safe concurrency and even gave us performance benefits, because statics simply became rich constant object graphs that could be frozen and shared across binaries.</p>
<p>The total elimination of mutable statics had an improvement to our system‚Äôs reliability that is difficult to quantify, and difficult to understate. This is one of the biggest things I miss.</p>
<p>Recall my mention of Clock above. This is an extreme example, however, yes, that‚Äôs right, there was no global function to read time, like C‚Äôs localtime or C#‚Äôs DateTime.Now. To get the time, you must explicitly request a Clock capability. This has the effect of eliminating non-determinism from an entire class of functions. A static function that doesn‚Äôt do IO ‚Äì something we can ascertain in our type system (think Haskell monads) ‚Äì now becomes purely functional, memoizable, and even something we can evaluate at compile-time (a bit like constexpr on steroids).</p>
<p>I‚Äôll be the first to admit, there was a maturity process that developers went through, as they learned about the design patterns in an object capability system. It was common for ‚Äúbig bags‚Äù of capabilities to grow over time, and/or for capabilities to be requested at an inopportune time. For example, imagine a Stopwatch API. It probably needs the Clock. Do you pass the Clock to every operation that needs to access the current time, like Start and Stop? Or do you construct the Stopwatch with a Clock instance up-front, thereby encapsulating the Stopwatch‚Äôs use of the time, making it easier to pass to others (recognizing, importantly, that this essentially grants the capability to read the time to the recipient). Another example, if your abstraction requires 15 distinct capabilities to get its job done, does its constructor take a flat list of 15 objects? What an unwieldy, annoying constructor! Instead, a better approach is to logically group these capabilities into separate objects, and maybe even use contextual storage like parents and children to make fetching them easier.</p>
<p>The weaknesses of classical object-oriented systems also rear their ugly heads. Downcasting, for example, means you cannot entirely trust subclassing as a means of information hiding. If you ask for a File, and I supply my own CloudFile that derives from File and adds its own public cloud-like functions to it, you might sneakily downcast to CloudFile and do things I didn‚Äôt intend. We addressed this with severe restrictions on casting and by putting the most sensitive capabilities on an entirely different plan altogether‚Ä¶
Distributed Capabilities</p>
<p>I‚Äôll briefly touch on an area that warrants a lot more coverage in a future post: our asynchronous programming model. This model formed the foundation of how we did concurrent, distributed computing; how we performed IO; and, most relevant to this discussion, how capabilities could extend their reach across these critical domains.</p>
<p>In the Filesystem example above, our system often hosted the real object behind that Filesystem reference in a different process altogether. That‚Äôs right, invoking a method actually dispatched a remote call to another process, which serviced the call. So, in practice, most, but not all, capabilities were asynchronous objects; or, more precisely, unforgeable tokens that permit one to talk with them, something we called an ‚Äúeventual‚Äù capability. The Clock was a counter-example to this. It was something we called a ‚Äúprompt‚Äù capability: something that wrapped a system call, rather than a remote call. But most security-related capabilities tended to be remote, because most interesting things that require authority bottom out on some kind of IO. It‚Äôs rare you need authority to simply perform a computation. In fact, the filesystem, network stack, device drivers, graphics surfaces, and a whole lot more took the form of eventual capabilities.</p>
<p>This unification of overall security in the OS and how we built distributed, and highly concurrent, secure systems, was one of our largest, innovative, and most important accomplishments.</p>
<p>I should note, like the idea of capabilities in general, similar ideas were pioneered well before Midori. Although we didn‚Äôt use the languages directly, the ideas from the Joule language and, later, E, laid some very powerful foundations for us to build upon. Mark Miller‚Äôs 2006 PhD thesis is a treasure trove of insights in this entire area. We had the privilege of working closely with one of the brightest minds I‚Äôve ever worked alongside, who happened to have been a chief designer of both systems.
Wrapping Up</p>
<p>There is so much to say about the benefits of capabilities. The foundation of type safety let us make some bold leaps forward. It led to a very different system architecture than is commonplace with ambient authority and access controls. This system brought secure, distributed computing to the forefront in a way that I‚Äôve never witnessed before. The design patterns that emerged really embraced object-orientation to its fullest, leveraging all sorts of design patterns that suddenly seemed more relevant than ever before.</p>
<p>We never did get much real-world exposure on this model. The user-facing aspects were under-explored compared to the architectural ones, like policy management. For example, I doubt we‚Äôd want to ask my mom if she wants to let the program use a Clock. Most likely we‚Äôd want some capabilities to be granted automatically (like the Clock), and others to be grouped, through composition, into related ones. Capabilities-as-objects thankfully gives us a plethora of known design patterns for doing this. We did have a few honey pots, and none ever got hacked (well, at least, we didn‚Äôt know if we did), but I cannot attest for sure about the quantifiable security of the resulting system. Qualitatively I can say we felt better having the belts-and-suspenders security at many layers of the system‚Äôs construction, but we didn‚Äôt get a chance to prove it at scale.</p>
<p>In the next article, we‚Äôll dig deeper into the asynchronous model that ran deep throughout the system. These days, asynchronous programming is a hot topic, with await showing up in C#, ECMAScript7, Python, C++, and more. This plus the fine-grained decomposition into lightweight processes connected by message passing were able to deliver a highly concurrent, reliable, and performant system, with asynchrony that was as easy to use as in all of those languages. See you next time!</p>
<h4 id="asynchronous-everything">Asynchronous everything<a class="zola-anchor" href="#asynchronous-everything" aria-label="Anchor link for: asynchronous-everything">üîó</a>
</h4>
<p><a href="http://joeduffyblog.com/2015/11/19/asynchronous-everything/">source</a></p>
<p>Midori was built out of many ultra-lightweight, fine-grained processes, connected through strongly typed message passing interfaces. It was common to see programs that‚Äôd‚Äôve classically been single, monolithic processes ‚Äì perhaps with some internal multithreading ‚Äì expressed instead as dozens of small processes, resulting in natural, safe, and largely automatic parallelism. Synchronous blocking was flat-out disallowed. This meant that literally everything was asynchronous: all file and network IO, all message passing, and any ‚Äúsynchronization‚Äù activities like rendezvousing with other asynchronous work. The resulting system was highly concurrent, responsive to user input, and scaled like the dickens. But as you can imagine, it also came with some fascinating challenges.
Asynchronous Programming Model</p>
<p>The asynchronous programming model looked a lot like C#‚Äôs async/await on the surface.</p>
<p>That‚Äôs not a coincidence. I was the architect and lead developer on .NET tasks. As the concurrency architect on Midori, coming off just shipping the .NET release, I admit I had a bit of a bias. Even I knew what we had wouldn‚Äôt work as-is for Midori, however, so we embarked upon a multi-year journey. But as we went, we worked closely with the C# team to bring some of Midori‚Äôs approaches back to the shipping language, and had been using a variant of the async/await model for about a year when C# began looking into it. We didn‚Äôt bring all the Midori goodness to .NET, but some of it certainly showed up, mostly in the area of performance. It still kills me that I can‚Äôt go back in time and make .NET‚Äôs task a struct.</p>
<p>But I‚Äôm getting ahead of myself. The journey to get to this point was a long one, and we should start at the beginning.
Promises</p>
<p>At the core of our asynchronous model was a technology called promises. These days, the idea is ubiquitous. The way we used promises, however, was more interesting, as we‚Äôll start to see soon. We were heavily influenced by the E system. Perhaps the biggest difference compared to popular asynchronous frameworks these days is there was no cheating. There wasn‚Äôt a single synchronous API available.</p>
<p>The first cut at the model used explicit callbacks. This‚Äôll be familiar to anybody who‚Äôs done Node.js programming. The idea is you get a Promise<T> for any operation that will eventually yield a T (or fail). The operation producing that may be running asynchronously within the process or even remotely somewhere else. The consumer doesn‚Äôt need to know or care. They just deal with the Promise<T> as a first class value and, when the T is sought, must rendezvous.</p>
<p>The basic callback model started something like this:</p>
<p>Promise<T> p = ... some operation ...;</p>
<p>... optionally do some things concurrent with that operation ...;</p>
<p>Promise<U> u = Promise.When(
p,
(T t) =&gt; { ... the T is available ... },
(Exception e) =&gt; { ... a failure occurred ... }
);</p>
<p>Eventually we switched over from static to instance methods:</p>
<p>Promise<U> u = p.WhenResolved(
(T t) =&gt; { ... the T is available ... },
(Exception e) =&gt; { ... a failure occurred ... }
);</p>
<p>Notice that the promises chain. The operation‚Äôs callbacks are expected to return a value of type U or throw an exception, as appropriate. Then the recipient of the u promise does the same, and so on, and so forth.</p>
<p>This is concurrent dataflow programming. It is nice because the true dependencies of operations govern the scheduling of activity in the system. A classical system often results in work stoppage not because of true dependencies, but false dependencies, like the programmer just happening to issue a synchronous IO call deep down in the callstack, unbeknownst to the caller.</p>
<p>In fact, this is one of the reasons your screen bleaches so often on Windows. I‚Äôll never forget a paper a few years back finding one of the leading causes of hangs in Outlook. A commonly used API would occasionally enumerate Postscript fonts by attempting to talk to the printer over the network. It cached fonts so it only needed to go to the printer once in a while, at unpredictable times. As a result, the ‚Äúgood‚Äù behavior led developers to think it safe to call from the UI thread. Nothing bad happened during testing (where, presumably, the developers worked on expensive computers with near-perfect networks). Sadly, when the network flaked out, the result was 10 second hangs with spinning donuts and bleachy white screens. To this day, we still have this problem in every OS that I use.</p>
<p>The issue in this example is the possibility for high latency wasn‚Äôt apparent to developers calling the API. It was even less apparent because the call was buried deep in a callstack, masked by virtual function calls, and so on. In Midori, where all asynchrony is expressed in the type system, this wouldn‚Äôt happen because such an API would necessarily return a promise. It‚Äôs true, a developer can still do something ridiculous (like an infinite loop on the UI thread), but it‚Äôs a lot harder to shoot yourself in the foot. Especially when it came to IO.</p>
<p>What if you didn‚Äôt want to continue the dataflow chain? No problem.</p>
<p>p.WhenResolved(
... as above ...
).Ignore();</p>
<p>This turns out to be a bit of an anti-pattern. It‚Äôs usually a sign that you‚Äôre mutating shared state.</p>
<p>The Ignore warrants a quick explanation. Our language didn‚Äôt let you ignore return values without being explicit about doing so. This specific Ignore method also addded some diagnostics to help debug situations where you accidentally ignored something important (and lost, for example, an exception).</p>
<p>Eventually we added a bunch of helper overloads and APIs for common patterns:</p>
<p>// Just respond to success, and propagate the error automatically:
Promise<U> u = p.WhenResolved((T t) =&gt; { ... the T is available ... });</p>
<p>// Use a finally-like construct:
Promise<U> u = p.WhenResolved(
(T t) =&gt; { ... the T is available ... },
(Exception e) =&gt; { ... a failure occurred ... },
() =&gt; { ... unconditionally executes ... }
);</p>
<p>// Perform various kinds of loops:
Promise<U> u = Async.For(0, 10, (int i) =&gt; { ... the loop body ... });
Promise<U> u = Async.While(() =&gt; ... predicate, () =&gt; { ... the loop body ... });</p>
<p>// And so on.</p>
<p>This idea is most certainly not even close to new. Joule and Alice even have nice built-in syntax to make the otherwise clumsy callback passing shown above more tolerable.</p>
<p>But it was not tolerable. The model tossed out decades of familiar programming language constructs, like loops.</p>
<p>It got really bad. Like really, really. It led to callback soup, often nested many levels deep, and often in some really important code to get right. For example, imagine you‚Äôre in the middle of a disk driver, and you see code like:</p>
<p>Promise<void> DoSomething(Promise<string> cmd) {
return cmd.WhenResolved(
s =&gt; {
if (s == &quot;...&quot;) {
return DoSomethingElse(...).WhenResolved(
v =&gt; {
return ...;
},
e =&gt; {
Log(e);
throw e;
}
);
}
else {
return ...;
}
},
e =&gt; {
Log(e);
throw e;
}
);
}</p>
<p>It‚Äôs just impossible to follow what‚Äôs going on here. It‚Äôs hard to tell where the various returns return to, what throw is unhandled, and it‚Äôs easy to duplicate code (such as the error cases), because classical block scoping isn‚Äôt available. God forbid you need to do a loop. And it‚Äôs a disk driver ‚Äì this stuff needs to be reliable!
Enter Async and Await</p>
<p>Almost every major language now features async and/or await-like constructs. We began wide-scale use sometime in 2009. And when I say wide-scale, I mean it.</p>
<p>The async/await approach let us keep the non-blocking nature of the system and yet clean up some of the above usability mess. In hindsight, it‚Äôs pretty obvious, but remember back then the most mainstream language with await used at scale was F# with its asynchronous workflows (also see this paper). And despite the boon to usability and productivity, it was also enormously controversial on the team. More on that later.</p>
<p>What we had was a bit different from what you‚Äôll find in C# and .NET. Let‚Äôs walk through the progression from the promises model above to this new async/await-based one. As we go, I‚Äôll point out the differences.</p>
<p>We first renamed Promise<T> to AsyncResult<T>, and made it a struct. (This is similar to .NET‚Äôs Task<T>, however focuses more on the ‚Äúdata‚Äù than the ‚Äúcomputation.‚Äù) A family of related types were born:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">T: the result of a prompt, synchronous computation that cannot fail.
</span><span style="color:#c0c5ce;">Async&lt;T&gt;: the result of an asynchronous computation that cannot fail.
</span><span style="color:#c0c5ce;">Result&lt;T&gt;: the result of a a prompt, synchronous computation that might fail.
</span><span style="color:#c0c5ce;">AsyncResult&lt;T&gt;: the result of an asynchronous computation that might fail.
</span></pre>
<p>That last one was really just a shortcut for Async&lt;Result<T>&gt;.</p>
<p>The distinction between things that can fail and things that cannot fail is a topic for another day. In summary, however, our type system guaranteed these properties for us.</p>
<p>Along with this, we added the await and async keywords. A method could be marked async:</p>
<p>async int Foo() { ... }</p>
<p>All this meant was that it was allowed to await inside of it:</p>
<p>async int Bar() {
int x = await Foo();
...
return x * x;
}</p>
<p>Originally this was merely syntactic sugar for all the callback goop above, like it is in C#. Eventually, however, we went way beyond this, in the name of performance, and added lightweight coroutines and linked stacks. More below.</p>
<p>A caller invoking an async method was forced to choose: use await and wait for its result, or use async and launch an asynchronous operation. All asynchrony in the system was thus explicit:</p>
<p>int x = await Bar();        // Invoke Bar, but wait for its result.
Async<int> y = async Bar(); // Invoke Bar asynchronously; I'll wait later.
int z = await y;            // ...like now.  This waits for Bar to finish.</p>
<p>This also gave us a very important, but subtle, property that we didn‚Äôt realize until much later. Because in Midori the only way to ‚Äúwait‚Äù for something was to use the asynchronous model, and there was no hidden blocking, our type system told us the full set of things that could ‚Äúwait.‚Äù More importantly, it told us the full set of things that could not wait, which told us what was pure synchronous computation! This could be used to guarantee no code ever blocked the UI from painting and, as we‚Äôll see below, many other powerful capabilities.</p>
<p>Because of the sheer magnitude of asynchronous code in the system, we embellished lots of patterns in the language that C# still doesn‚Äôt support. For example, iterators, for loops, and LINQ queries:</p>
<p>IAsyncEnumerable<Movie> GetMovies(string url) {
foreach (await var movie in http.Get(url)) {
yield return movie;
}
}</p>
<p>Or, in LINQ style:</p>
<p>IAsyncEnumerable<Movie> GetMovies(string url) {
return
from await movie in http.Get(url)
... filters ...
select ... movie ...;
}</p>
<p>The entire LINQ infrastructure participated in streaming, including resource management and backpressure.</p>
<p>We converted millions of lines of code from the old callback style to the new async/await one. We found plenty of bugs along the way, due to the complex control flow of the explicit callback model. Especially in loops and error handling logic, which could now use the familiar programming language constructs, rather than clumsy API versions of them.</p>
<p>I mentioned this was controversial. Most of the team loved the usability improvements. But it wasn‚Äôt unanimous.</p>
<p>Maybe the biggest problem was that it encouraged a pull-style of concurrency. Pull is where a caller awaits a callee before proceeding with its own operations. In this new model, you need to go out of your way to not do that. It‚Äôs always possible, of course, thanks to the async keyword, but there‚Äôs certainly a little more friction than the old model. The old, familiar, blocking model of waiting for things is just an await keyword away.</p>
<p>We offered bridges between pull and push, in the form of reactive IObservable<T>/IObserver<T> adapters. I wouldn‚Äôt claim they were very successful, however for side-effectful actions that didn‚Äôt employ dataflow, they were useful. In fact, our entire UI framework was based on the concept of functional reactive programming, which required a slight divergence from the Reactive Framework in the name of performance. But alas, this is a post on its own.</p>
<p>An interesting consequence was a new difference between a method that awaits before returning a T, and one that returns an Async<T> directly. This difference didn‚Äôt exist in the type system previously. This, quite frankly, annoyed the hell out of me and still does. For example:</p>
<p>async int Bar()  { return await Foo(); }
Async<int> Bar() { return async Foo(); }</p>
<p>We would like to claim the performance between these two is identical. But alas, it isn‚Äôt. The former blocks and keeps a stack frame alive, whereas the latter does not. Some compiler cleverness can help address common patterns ‚Äì this is really the moral equivalent to an asynchronous tail call ‚Äì however it‚Äôs not always so cut and dry.</p>
<p>On its own, this wasn‚Äôt a killer. It caused some anti-patterns in important areas like streams, however. Developers were prone to awaiting in areas they used to just pass around Async<T>s, leading to an accumulation of paused stack frames that really didn‚Äôt need to be there. We had good solutions to most patterns, but up to the end of the project we struggled with this, especially in the networking stack that was chasing 10GB NIC saturation at wire speed. We‚Äôll discuss some of the techniques we employed below.</p>
<p>But at the end of this journey, this change was well worth it, both in the simplicity and usability of the model, and also in some of the optimization doors it opened up for us.
The Execution Model</p>
<p>That brings me to the execution model. We went through maybe five different models, but landed in a nice place.</p>
<p>A key to achieving asynchronous everything was ultra-lightweight processes. This was possible thanks to software isolated processes (SIPs), building upon the foundation of safety described in an earlier post.</p>
<p>The absence of shared, mutable static state helped us keep processes small. It‚Äôs surprising how much address space is burned in a typical program with tables and mutable static variables. And how much startup time can be spent initializing said state. As I mentioned earlier, we froze most statics as constants that got shared across many processes. The execution model also resulted in cheaper stacks (more on that below) which was also a key factor. The final thing here that helped wasn‚Äôt even technical, but cultural. We measured process start time and process footprint nightly in our lab and had a ‚Äúratcheting‚Äù process where every sprint we ensured we got better than last sprint. A group of us got in a room every week to look at the numbers and answer the question of why they went up, down, or stayed the same. We had this culture for performance generally, but in this case, it kept the base of the system light and nimble.</p>
<p>Code running inside processes could not block. Inside the kernel, blocking was permitted in select areas, but remember no user code ever ran in the kernel, so this was an implementation detail. And when I say ‚Äúno blocking,‚Äù I really mean it: Midori did not have demand paging which, in a classical system, means that touching a piece of memory may physically block to perform IO. I have to say, the lack of page thrashing was such a welcome that, to this day, the first thing I do on a new Windows sytem is disable paging. I would much rather have the OS kill programs when it is close to the limit, and continue running reliably, than to deal with a paging madness.</p>
<p>C#‚Äôs implementation of async/await is entirely a front-end compiler trick. If you‚Äôve ever run ildasm on the resulting assembly, you know: it lifts captured variables into fields on an object, rewrites the method‚Äôs body into a state machine, and uses Task‚Äôs continuation passing machinery to keep the iterator-like object advancing through the states.</p>
<p>We began this way and shared some of our key optimizations with the C# and .NET teams. Unfortunately, the result at the scale of what we had in Midori simply didn‚Äôt work.</p>
<p>First, remember, Midori was an entire OS written to use garbage collected memory. We learned some key lessons that were necessary for this to perform adequately. But I‚Äôd say the prime directive was to avoid superfluous allocations like the plague. Even short-lived ones. There is a mantra that permeated .NET in the early days: Gen0 collections are free. Unfortunately, this shaped a lot of .NET‚Äôs library code, and is utter hogwash. Gen0 collections introduce pauses, dirty the cache, and introduce beat frequency issues in a highly concurrent system. I will point out, however, one of the tricks to garbage collection working at the scale of Midori was precisely the fine-grained process model, where each process had a distinct heap that was independently collectible. I‚Äôll have an entire article devoted to how we got good behavior out of our garbage collector, but this was the most important architectural characteristic.</p>
<p>The first key optimization, therefore, is that an async method that doesn‚Äôt await shouldn‚Äôt allocate anything.</p>
<p>We were able to share this experience with .NET in time for C#‚Äôs await to ship. Sadly, by then, .NET‚Äôs Task had already been made a class. Since .NET requires async method return types to be Tasks, they cannot be zero-allocation unless you go out of your way to use clumsy patterns like caching singleton Task objects.</p>
<p>The second key optimization was to ensure that async methods that awaited allocated as little as possible.</p>
<p>In Midori, it was very common for one async method to invoke another, which invoked another ‚Ä¶ and so on. If you think about what happens in the state machine model, a leaf method that blocks triggers a cascade of O(K) allocations, where K is the depth of the stack at the time of the await. This is really unfortunate.</p>
<p>What we ended up with was a model that only allocated when the await happened, and that allocated only once for an entire such chain of calls. We called this chain an ‚Äúactivity.‚Äù The top-most async demarcated the boundary of an activity. As a result, async could cost something, but await was free.</p>
<p>Well, that required one additional step. And this one was the biggie.</p>
<p>The final key optimization was to ensure that async methods imposed as little penalty as possible. This meant eliminating a few sub-optimal aspects of the state machine rewrite model. Actually, we abandoned it:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">It completely destroyed code quality. It impeded simple optimizations like inlining, because few inliners consider a switch statement with multiple state variables, plus a heap-allocated display frame, with lots of local variable copying, to be a ‚Äúsimple method.‚Äù We were competing with OS‚Äôs written in native code, so this matters a lot.

</span><span style="color:#c0c5ce;">It required changes to the calling convention. Namely, returns had to be Async*&lt;T&gt; objects, much like .NET‚Äôs Task&lt;T&gt;. This was a non-starter. Even though ours were structs ‚Äì eliminating the allocation aspect ‚Äì they were multi-words, and required that code fetch out the values with state and type testing. If my async method returns an int, I want the generated machine code to be a method that returns an int, goddamnit.

</span><span style="color:#c0c5ce;">Finally, it was common for too much heap state to get captured. We wanted the total space consumed by an awaiting activity to be as small as possible. It was common for some processes to end up with hundreds or thousands of them, in addition to some processes constantly switching between them. For footprint and cache reasons, it was important that they remain as small as the most carefully hand-crafted state machine as possible.
</span></pre>
<p>The model we built was one where asynchronous activities ran on linked stacks. These links could start as small as 128 bytes and grow as needed. After much experimentation, we landed on a model where link sizes doubled each time; so, the first link would be 128b, then 256b, ‚Ä¶, on up to 8k chunks. Implementing this required deep compiler support. As did getting it to perform well. The compiler knew to hoist link checks, especially out of loops, and probe for larger amounts when it could predict the size of stack frames (accounting for inlining). There is a common problem with linking where you can end up relinking frequently, especially at the edge of a function call within a loop, however most of the above optimizations prevented this from showing up. And, even if they did, our linking code was hand-crafted assembly ‚Äì IIRC, it was three instructions to link ‚Äì and we kept a lookaside of hot link segments we could reuse.</p>
<p>There was another key innovation. Remember, I hinted earlier, we knew statically in the type system whether a function was asynchronous or not, simply by the presence of the async keyword? That gave us the ability in the compiler to execute all non-asynchronous code on classical stacks. The net result was that all synchronous code remained probe-free! Another consequence is the OS kernel could schedule all synchronous code on a set of pooled stacks. These were always warm, and resembled a classical thread pool, more than an OS scheduler. Because they never blocked, you didn‚Äôt have O(T) stacks, where T is the number of threads active in the entire system. Instead, you ended up with O(P), where P is the number of processors on the machine. Remember, eliminating demand paging was also key to achieiving this outcome. So it was really a bunch of ‚Äúbig bets‚Äù that added up to something that was seriously game-changing.
Message Passing</p>
<p>A fundamental part of the system has been missing from the conversation: message passing.</p>
<p>Not only were processes ultra-lightweight, they were single-threaded in nature. Each one ran an event loop and that event loop couldn‚Äôt be blocked, thanks to the non-blocking nature of the system. Its job was to execute a piece of non-blocking work until it finished or awaited, and then to fetch the next piece of work, and so on. An await that was previously waiting and became satisfied was simply scheduled as another turn of the crank.</p>
<p>Each such turn of the crank was called, fittingly, a ‚Äúturn.‚Äù</p>
<p>This meant that turns could happen between asynchronous activities and at await points, nowhere else. As a result, concurrent interleaving only occurred at well-defined points. This was a giant boon to reasoning about state in the face of concurrency, however it comes with some gotchas, as we explore later.</p>
<p>The nicest part of this, however, was that processes suffered no shared memory race conditions.</p>
<p>We did have a task and data parallel framework. It leveraged the concurrency safety features of the languge I‚Äôve mentioned previously ‚Äì immutability, isolation, and readonly annotations ‚Äì to ensure that this data race freedom was not violated. This was used for fine-grained computations that could use the extra compute power. Most of the system, however, gained its parallel execution through the decomposition into processes connected by message passing.</p>
<p>Each process could export an asynchronous interface. It looked something like this:</p>
<p>async interface ICalculator {
async int Add(int x, int y);
async int Multiply(int x, int y);
// Etc...
}</p>
<p>As with most asynchronous RPC systems, from this interface was generated a server stub and client-side proxy. On the server, we would implement the interface:</p>
<p>class MyCalculator : ICalculator {
async int Add(int x, int y) { return x + y; }
async int Multiply(int x, int y) { return x * y; }
// Etc...
}</p>
<p>Each server-side object could also request capabilities simply by exposing a constructor, much like the program‚Äôs main entrypoint could, as I described in the prior post. Our application model took care of activating and wiring up the server‚Äôs programs and services.</p>
<p>A server could also return references to other objects, either in its own process, or a distant one. The system managed the object lifetime state in coordination with the garbage collector. So, for example, a tree:</p>
<p>class MyTree : ITree {
async ITree Left() { ... }
async ITree Right() { ... }
}</p>
<p>As you might guess, the client-side would then get its hands on a proxy object, connected to this server object running in a process. It‚Äôs possible the server would be in the same process as the client, however typically the object was distant, because this is how processes communicated with one another:</p>
<p>class MyProgram {
async void Main(IConsole console, ICalculator calc) {
var result = await calc.Add(2, 2);
await console.WriteLine(result);
}
}</p>
<p>Imagining for a moment that the calculator was a system service, this program would communicate with that system service to add two numbers, and then print the result to the console (which itself also could be a different service).</p>
<p>A few key aspects of the system made message passing very efficient. First, all of the data structures necessary to talk cross-process were in user-mode, so no kernel-mode transitions were needed. In fact, they were mostly lock-free. Second, the system used a technique called ‚Äúpipelining‚Äù to remove round-trips and synchronization ping-ponging. Batches of messages could be stuffed into channels before they filled up. They were delivered in chunks at-a-time. Finally, a novel technique called ‚Äúthree-party handoff‚Äù was used to shorten the communication paths between parties engaging in a message passing dialogue. This cut out middle-men whose jobs in a normal system would have been to simply bucket brigade the messages, adding no value, other than latency and wasted work.</p>
<p>Message Passing Diagram</p>
<p>The only types marshalable across message passing boundaries were:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Primitive types (int, string, etc).
</span><span style="color:#c0c5ce;">Custom PODs that didn‚Äôt contain pointers (explicitly labeled marshalable).
</span><span style="color:#c0c5ce;">References to streams (see below).
</span><span style="color:#c0c5ce;">References to other async objects (e.g., our ICalculator above).
</span><span style="color:#c0c5ce;">A special SharedData object, which requires a bit more explanation.
</span></pre>
<p>Most of these are obvious. The SharedData thing is a little subtle, however. Midori had a fundamental philosophy of ‚Äúzero-copy‚Äù woven throughout its fabric. This will be the topic of a future post. It‚Äôs the secret sauce that let us out-perform many classical systems on some key benchmarks. The idea is, however, no byte should be copied if it can be avoided. So we don‚Äôt want to marshal a byte[] by copy when sending a message between processes, for example. The SharedData was a automatic ref-counted pointer to some immutable data in a heap shared between processes. The OS kernel managed this heap memory and reclaimed it when all references dropped to zero. Because the ref-counts were automatic, programs couldn‚Äôt get it wrong. This leveraged some new features in our language, like destructors.</p>
<p>We also had the notion of ‚Äúnear objects,‚Äù which went an extra step and let you marshal references to immutable data within the same process heap. This let you marshal rich objects by-reference. For example:</p>
<p>// An asynchronous object in my heap:
ISpellChecker checker = ...;</p>
<p>// A complex immutable Document in my heap,
// perhaps using piece tables:
immutable Document doc = ...;</p>
<p>// Check the document by sending messages within
// my own process; no copies are necessary:
var results = await checker.Check(doc);</p>
<p>As you can guess, all of this was built upon a more fundamental notion of a ‚Äúchannel.‚Äù This is similar to what you‚Äôll see in Occam, Go and related CSP languages. I personally found the structure and associated checking around how messages float around the system more comfortable than coding straight to the channels themselves, but your mileage may vary. The result felt similar to programming with actors, with some key differences around the relationship between process and object identity.
Streams</p>
<p>Our framework had two fundamental stream types: Stream held a stream of bytes and Sequence<T> held Ts. They were both forward-only (we had separate seekable classes) and 100% asynchronous.</p>
<p>Why two types, you wonder? They began as entirely independent things, and eventually converged to be brother and sister, sharing a lot of policy and implementation with one another. The core reason they remained distinct, however, is that it turns out when you know you‚Äôre just schlepping raw byte-streams around, you can make a lot of interesting performance improvements in the implementation, compared to a fully generic version.</p>
<p>For purposes of this discussion, however, just imagine that Stream and Sequence<byte> are isomorphic.</p>
<p>As hinted at earlier, we also had IAsyncEnumerable<T> and IAsyncEnumerator<T> types. These were the most general purpose interfaces you‚Äôd code against when wanting to consume something. Developers could, of course, implement their own stream types, especially since we had asynchronous iterators in the language. A full set of asynchronous LINQ operators worked over these interfaces, so LINQ worked nicely for consuming and composing streams and sequences.</p>
<p>In addition to the enumerable-based consumption techniques, all the standard peeking and batch-based APIs were available. It‚Äôs important to point out, however, that the entire streams framework built atop the zero-copy capabilities of the kernel, to avoid copying. Every time I see an API in .NET that deals with streams in terms of byte[]s makes me shed a tear. The result is our streams were actually used in very fundamental areas of the system, like the network stack itself, the filesystem the web servers, and more.</p>
<p>As hinted at earlier, we supported both push and pull-style concurrency in the streaming APIs. For example, we supported generators, which could either style:</p>
<p>// Push:
var s = new Stream(g =&gt; {
var item = ... do some work ...;
g.Push(item);
});</p>
<p>// Pull:
var s = new Stream(g =&gt; {
var item = await ... do some work ...;
yield return item;
});</p>
<p>The streaming implementation handled gory details of batching and generally ensuring streaming was as efficient as possible. A key technique was flow control, borrowed from the world of TCP. A stream producer and consumer collaborated, entirely under the hood of the abstraction, to ensure that the pipeline didn‚Äôt get too imbalanced. This worked much like TCP flow control by maintaining a so-called ‚Äúwindow‚Äù and opening and closing it as availability came and went. Overall this worked great. For example, our realtime multimedia stack had two asynchronous pipelines, one for processing audio and the other for processing video, and merged them together, to implement A/V sync. In general, the built-in flow control mechanisms were able to keep them from dropping frames.
‚ÄúGrand‚Äù Challenges</p>
<p>The above was a whirlwind tour. I‚Äôve glossed over some key details, but hopefully you get the picture.</p>
<p>Along this journey we uncovered several ‚Äúgrand challenges.‚Äù I‚Äôll never forget them, as they formed the outline of my entire yearly performance review for a good 3 years straight. I was determined to conquer them. I can‚Äôt say that our answers were perfect, but we made a gigantic dent in them.
Cancellation</p>
<p>The need to have cancellable work isn‚Äôt anything new. I came up with the CancellationToken abstraction in .NET, largely in response to some of the challenges we had around ambient authority with prior ‚Äúimplicitly scoped‚Äù attempts.</p>
<p>The difference in Midori was the scale. Asynchronous work was everywhere. It sprawled out across processes and, sometimes, even machines. It was incredibly difficult to chase down run-away work. My simple use-case was how to implement the browser‚Äôs ‚Äúcancel‚Äù button reliably. Simply rendering a webpage involved a handful of the browser‚Äôs own processes, plus the various networking processes ‚Äì including the NIC‚Äôs device driver ‚Äì along with the UI stack, and more. Having the ability to instantly and reliably cancel all of this work was not just appealing, it was required.</p>
<p>The solution ended up building atop the foundation of CancellationToken.</p>
<p>They key innovation was first to rebuild the idea of CancellationToken on top of our overall message passing model, and then to weave it throughout in all the right places. For example:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">CancellationTokens could extend their reach across processes.
</span><span style="color:#c0c5ce;">Whole async objects could be wrapped in a CancellationToken, and used to trigger revocation.
</span><span style="color:#c0c5ce;">Whole async functions could be invoked with a CancellationToken, such that cancelling propagated downward.
</span><span style="color:#c0c5ce;">Areas like storage needed to manually check to ensure that state was kept consistent.
</span></pre>
<p>In summary, we took a ‚Äúwhole system‚Äù approach to the way cancellation was plumbed throughout the system, including extending the reach of cancellation across processes. I was happy with where we landedon this one.
State Management</p>
<p>The ever-problematic ‚Äústate management‚Äù problem can be illustrated with a simple example:</p>
<p>async void M(State s) {
int x = s.x;
await ... something ...;
assert(x == s.x);
}</p>
<p>The question here is, can the assertion fire?</p>
<p>The answer is obviously yes. Even without concurrency, reentrancy is a problem. Depending on what I do in ‚Äú‚Ä¶ something ‚Ä¶‚Äù, the State object pointed to by s might change before returning back to us.</p>
<p>But somewhat subtly, even if ‚Äú‚Ä¶ something ‚Ä¶‚Äù doesn‚Äôt change the object, we may find that the assertion fires. Consider a caller:</p>
<p>State s = ...;
Async<void> a = async M(s);
s.x++;
await a;</p>
<p>The caller retains an alias to the same object. If M‚Äôs awaiting operation must wait, control is resumed to the caller. The caller here then increments x before awaiting M‚Äôs completion. Unfortunately, when M resumes, it will discover that the value of x no longer matches s.x.</p>
<p>This problem manifests in other more devious ways. For example, imagine one of those server objects earlier:</p>
<p>class StatefulActor : ISomething {
int state;
async void A() {
// Use state
}
async void B() {
// Use state
}
}</p>
<p>Imagining that both A and B contain awaits, they can now interleave with one another, in addition to interleaving with multiple activations of themselves. If you‚Äôre thinking this smells like a race condition, you‚Äôre right. In fact, saying that message passing systems don‚Äôt have race conditions is an outright lie. There have even been papers discussing this in the context of Erlang. It‚Äôs more correct to say our system didn‚Äôt have data race conditions.</p>
<p>Anyway, there be dragons here.</p>
<p>The solution is to steal a page from classical synchronization, and apply one of many techniques:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Isolation.
</span><span style="color:#c0c5ce;">Standard synchronization techniques (prevent write-write or read-write hazards).
</span><span style="color:#c0c5ce;">Transactions.
</span></pre>
<p>By far, we preferred isolation. It turns out web frameworks offer good lessons to learn from here. Most of the time, a server object is part of a ‚Äúsession‚Äù and should not be aliased across multiple concurrent clients. It tended to be easy to partition state into sub-objects, and have dialogues using those. Our language annotations around mutability helped to guide this process.</p>
<p>A lesser regarded technique was to apply synchronization. Thankfully in our language, we knew which operations read versus wrote, and so we could use that to block dispatching messages intelligently, using standard reader-writer lock techniques. This was comfy and cozy and whatnot, but could lead to deadlocks if done incorrectly (which we did our best to detect). As you can see, once you start down this path, the world is less elegant, so we discouraged it.</p>
<p>Finally, transactions. We didn‚Äôt go there. Distributed transactions are evil.</p>
<p>In general, we tried to learn from the web, and apply architectures that worked for large-scale distributed systems. Statelessness was by far the easiest pattern. Isolation was a close second. Everything else was just a little dirty.</p>
<p>P.S. I will be sure to have an entire post dedicated to the language annotations.
Ordering</p>
<p>In a distributed system, things get unordered unless you go out of your way to preserve order. And going out of your way to preserve order removes concurrency from the system, adds book-keeping, and a ton of complexity. My biggest lesson learned here was: distributed systems are unordered. It sucks. Don‚Äôt fight it. You‚Äôll regret trying.</p>
<p>Leslie Lamport has a classic must-read paper on the topic: Time, Clocks, and the Ordering of Events in a Distributed System.</p>
<p>But unordered events surprise developers. A good example is as follows:</p>
<p>// Three asynchronous objects:
IA a = ...;
IB b = ...;
IC c = ...;</p>
<p>// Tell b to talk to a:
var req1 = async b.TalkTo(a);</p>
<p>// Tell c to talk to b:
var req2 = async c.TalkTo(a);</p>
<p>await Async.Join(req1, req2);</p>
<p>If you expected that b is guaranteed to talk with a before c talks with a, you‚Äôre in for a bad day.</p>
<p>We offered facilities for controlling order. For example, you could flush all the messages from a channel, and await their delivery. You could, of course, always await the individual operations, but this introduces some amount of unnecessary latency due to round-tripping. We also had a ‚Äúflow‚Äù abstraction that let you guarantee a sequence of asynchronous messages were delivered in order, but in the most efficient way possible.</p>
<p>As with state management, we found that an abundance of ordering problems was often indicative of a design problem.
Debugging</p>
<p>With so much work flying around in the system, debugging was a challenge in the early days.</p>
<p>The solution, as with many such challenges, was tooling. We taught our tools that activities were as first class as threads. We introduced causality IDs that flowed with messages across processes, so if you broke into a message dispatch in one process, you could trace back to the origin in potentially some other distant process. The default behavior for a crash was to gather this cross-process stack trace, to help figure out how you go to where you were.</p>
<p>Another enormous benefit of our improved execution model was that stacks were back! Yes, you actually got stack traces for asynchronous activities awaiting multiple levels deep at no extra expense. Many systems like .NET‚Äôs have to go out of their way to piece together a stack trace from disparate hunks of stack-like objects. We had that challenge across processes, but within a single process, all activities had normal stack traces with variables that were in a good state.
Resource Management</p>
<p>At some point, I had a key realization. Blocking in a classical system acts as a natural throttle on the amount of work that can be offered up to the system. Your average program doesn‚Äôt express all of its latent concurrency and parallelism by default. But ours did! Although that sounds like a good thing ‚Äì and indeed it was ‚Äì it came with a dark side. How the heck do you manage resources and schedule all that work intelligently, in the face of so much of it?</p>
<p>This was a loooooooong, winding road. I won‚Äôt claim we solved it. I won‚Äôt claim we even came close. I will claim we tackled it enough that the problem was less disastrous to the stability of the system than it would have otherwise been.</p>
<p>An analogous problem that I‚Äôve faced in the past is with thread pools in both Windows and the .NET Framework. Given that work items might block in the thread pool, how do you decide the number of threads to keep active at once? There are always imperfect heuristics applied, and I would say we did no worse. If anything, we erred on the side of using more of the latent parallelism to saturate the available resources. It was pretty common to be running the Midori system at 100% CPU utilization, because it was doing useful stuff, which is pretty rare on PCs and traditional apps.</p>
<p>But the scale of our problem was much worse than anything I‚Äôd ever seen. Everything was asynchronous. Imagine an app traversing the entire filesystem, and performing a series of asynchronous operations for each file on disk. In Midori, the app, filesystem, disk drivers, etc., are all different asynchronous processes. It‚Äôs easy to envision the resulting fork bomb-like problem that results.</p>
<p>The solution here broke down into a two-pronged defense:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Self-control: async code knows that it could flood the system with work, and explicitly tries not to.
</span><span style="color:#c0c5ce;">Automatic resource management: no matter what the user-written code does, the system can throttle automatically.
</span></pre>
<p>For obvious reasons, we preferred automatic resource management.</p>
<p>This took the form of the OS scheduler making decisions about which processes to visit, which turns to let run, and, in some cases, techniques like flow control as we saw above with streams. This is the area we had the most ‚Äúopen ended‚Äù and ‚Äúunresolved‚Äù research. We tried out many really cool ideas. This included attempting to model the expected resource usage of asynchronous activities (similar to this paper on convex optimization). That turned out to be very difficult, but certainly shows some interesting long turn promise if you can couple it with adaptive techniques. Perhaps surprisingly, our most promising results came from adapting advertisement bidding algorithms to resource allocation. Coupled with an element of game theory, this approach gets very interesting. If the system charges a market value for all system resources, and all agents in the system have a finite amount of ‚Äúpurchasing power,‚Äù we can expect they will purchase those resources that benefit themselves the most based on the market prices available.</p>
<p>But automatic management wasn‚Äôt always perfect. That‚Äôs where self-control came in. A programmer could also help us out by capping the maximum number of outstanding activities, using simple techniques like ‚Äúwide-loops.‚Äù A wide-loop was an asynchronous loop where the developer specified the maximum outstanding iterations. The system ensured it launched no more than this count at once. It always felt a little cheesy but, coupled with resource management, did the trick.</p>
<p>I would say we didn‚Äôt die from this one. We really thought we would die from this one. I would also say it was solved to my least satisfaction out of the bunch, however. It remains fertile ground for innovative systems research.
Winding Down</p>
<p>That was a lot to fit into one post. As you can see, we took ‚Äúasynchronous everywhere‚Äù to quite the extreme.</p>
<p>In the meantime, the world has come a long way, much closer to this model than when we began. In Windows 8, a large focus was the introduction of asynchronous APIs, and, like with adding await to C#, we gave them our own lessons learned at the time. A little bit of what we were doing rubbed off, but certainly nothing to the level of what‚Äôs above.</p>
<p>The resulting system was automatically parallel in a very different way than the standard meaning. Tons of tiny processes and lots of asynchronous messages ensured the system kept making forward progress, even in the face of variable latency operations like networking. My favorite demo we ever gave, to Steve Ballmer, was a mock implementation of Skype on our own multimedia stack that wouldn‚Äôt hang even if you tried your hardest to force it.</p>
<p>As much as I‚Äôd like to keep going on architecture and programming model topics, I think I need to take a step back. Our compiler keeps coming up and, in many ways, it was our secret sauce. The techniques we used there enabled us to achieve all of these larger goals. Without that foundation, we‚Äôd never have had the safety or been on the same playing ground as native code. See you next time, when we nerd out a bit on compilers.</p>
<h4 id="safe-native-code">Safe native code<a class="zola-anchor" href="#safe-native-code" aria-label="Anchor link for: safe-native-code">üîó</a>
</h4>
<p><a href="http://joeduffyblog.com/2015/12/19/safe-native-code/">source</a></p>
<p>In my first Midori post, I described how safety was the foundation of everything we did. I mentioned that we built an operating system out of safe code, and yet stayed competitive with operating systems like Windows and Linux written in C and C++. In many ways, system architecture played a key role, and I will continue discussing how in future posts. But, at the foundation, an optimizing compiler that often eeked out native code performance from otherwise ‚Äúmanaged‚Äù, type- and memory-safe code, was one of our most important weapons. In this post, I‚Äôll describe some key insights and techniques that were essential to our success.
Overview</p>
<p>When people think of C#, Java, and related languages, they usually think of Just-In-Time (JIT) compilation. Especially back in the mid-2000s when Midori began. But Midori was different, using more C++-like Ahead-Of-Time (AOT) compilation from the outset.</p>
<p>AOT compiling managed, garbage collected code presents some unique challenges compared to C and C++. As a result, many AOT efforts don‚Äôt achieve parity with their native counterparts. .NET‚Äôs NGEN technology is a good example of this. In fact, most efforts in .NET have exclusively targeted startup time; this is clearly a key metric, but when you‚Äôre building an operating system and everything on top, startup time just barely scratches the surface.</p>
<p>Over the course of 8 years, we were able to significantly narrow the gap between our version of C# and classical C/C++ systems, to the point where basic code quality, in both size of speed dimensions, was seldom the deciding factor when comparing Midori‚Äôs performance to existing workloads. In fact, something counter-intuitive happened. The ability to co-design the language, runtime, frameworks, operating system, and the compiler ‚Äì making tradeoffs in one area to gain advantages in other areas ‚Äì gave the compiler far more symbolic information than it ever had before about the program‚Äôs semantics and, so, I dare say, was able to exceed C and C++ performance in a non-trivial number of situations.</p>
<p>Before diving deep, I have to put in a reminder. The architectural decisions ‚Äì like Async Everywhere and Zero-Copy IO (coming soon) ‚Äì had more to do with us narrowing the gap at a ‚Äúwhole system‚Äù level. Especially the less GC-hungry way we wrote systems code. But the foundation of a highly optimizing compiler, that knew about and took advantage of safety, was essential to our results.</p>
<p>I would also be remiss if I didn‚Äôt point out that the world has made considerable inroads in this area alongside us. Go has straddled an elegant line between systems performance and safety. Rust is just plain awesome. The .NET Native and, related, Android Runtime projects have brought a nice taste of AOT to C# and Java in a more limited way, as a ‚Äúsilent‚Äù optimization technique to avoid mobile application lag caused by JITting. Lately, we‚Äôve been working on bringing AOT to a broader .NET setting with the CoreRT project. Through that effort I hope we can bring some of the lessons learned below to a real-world setting. Due to the delicate balance around breaking changes it remains to be seen how far we can go. It took us years to get everything working harmoniously, measured in man-decades, however, so this transfer of knowledge will take time.</p>
<p>First thing‚Äôs first. Let‚Äôs quickly recap: What‚Äôs the difference between native and managed code, anyway?
What‚Äôs the same</p>
<p>I despise the false dichotomy ‚Äúnative and managed,‚Äù so I must apologize for using it. After reading this article, I hope to have convinced you that it‚Äôs a continuum. C++ is safer these days than ever before, and likewise, C# performant. It‚Äôs amusing how many of these lessons apply directly to the work my team is doing on Safe C++ these days.</p>
<p>So let‚Äôs begin by considering what‚Äôs the same.</p>
<p>All the basic dragon book topics apply to managed as much as they do native code.</p>
<p>In general, compiling code is a balancing act between, on one hand emitting the most efficient instruction sequences for the target architecture, to execute the program quickly; and on the other hand emitting the smallest encoding of instructions for the target architecture, to store the program compactly and effectively use the memory system on the target device. Countless knobs exist on your favorite compiler to dial between the two based on your scenario. On mobile, you probably want smaller code, whereas on a multimedia workstation, you probably want the fastest.</p>
<p>The choice of managed code doesn‚Äôt change any of this. You still want the same flexibility. And the techniques you‚Äôd use to achieve this in a C or C++ compiler are by and large the same as what you use for a safe language.</p>
<p>You need a great inliner. You want common subexpression elimination (CSE), constant propagation and folding, strength reduction, and an excellent loop optimizer. These days, you probably want to use static single assignment form (SSA), and some unique SSA optimizations like global value numbering (although you need to be careful about working set and compiler throughput when using SSA everywhere). You will need specialized machine dependent optimizers for the target architectures that are important to you, including register allocators. You‚Äôll eventually want a global analyzer that does interprocedural optimizations, link-time code-generation to extend those interprocedural optimizations across passes, a vectorizer for modern processors (SSE, NEON, AVX, etc.), and most definitely profile guided optimizations (PGO) to inform all of the above based on real-world scenarios.</p>
<p>Although having a safe language can throw some interesting curveballs your way that are unique and interesting ‚Äì which I‚Äôll cover below ‚Äì you‚Äôll need all of the standard optimizing compiler things.</p>
<p>I hate to say it, but doing great at all of these things is ‚Äútable stakes.‚Äù Back in the mid-2000s, we had to write everything by hand. Thankfully, these days you can get an awesome off-the-shelf optimizing compiler like LLVM that has most of these things already battle tested, ready to go, and ready for you to help improve.
What‚Äôs different</p>
<p>But, of course, there are differences. Many. This article wouldn‚Äôt be very interesting otherwise.</p>
<p>The differences are more about what ‚Äúshapes‚Äù you can expect to be different in the code and data structures thrown at the optimizer. These shapes come in the form of different instruction sequences, logical operations in the code that wouldn‚Äôt exist in the C++ equivalent (like more bounds checking), data structure layout differences (like extra object headers or interface tables), and, in most cases, a larger quantity of supporting runtime data structures.</p>
<p>Objects have ‚Äúmore to them‚Äù in most managed languages, compared to frugal data types in, say, C. (Note that C++ data structures are not nearly as frugal as you might imagine, and are probably closer to C# than your gut tells you.) In Java, every object has a vtable pointer in its header. In C#, most do, although structs do not. The GC can impose extra layout restrictions, such as padding and a couple words to do its book-keeping. Note that none of this is really specific to managed languages ‚Äì C and C++ allocators can inject their own words too, and of course, many C++ objects also carry vtables ‚Äì however it‚Äôs fair to say that most C and C++ implementations tend to be more economical in these areas. In most cases, for cultural reasons more than hard technical ones. Add up a few thousand objects in a heap, especially when your system is built of many small processes with isolated heaps, like Midori, and it adds up quickly.</p>
<p>In Java, you‚Äôve got a lot more virtual dispatch, because methods are virtual by default. In C#, thankfully, methods are non-virtual by default. (We even made classes sealed by default.) Too much virtual dispatch can totally screw inlining which is a critical optimization to have for small functions. In managed languages you tend to have more small functions for two reasons: 1) properties, and 2) higher level programmers tend to over-use abstraction.</p>
<p>Although it‚Äôs seldom described this formally, there‚Äôs an ‚ÄúABI‚Äù (Application Binary Interface) that governs interactions between code and the runtime. The ABI is where the rubber meets the road. It‚Äôs where things like calling conventions, exception handling, and, most notably, the GC manifest in machine code. This is not unique to managed code! C++ has a ‚Äúruntime‚Äù and therfore an ABI too. It‚Äôs just that it‚Äôs primarily composed of headers, libraries like allocators, and so on, that are more transparently linked into a program than with classical C# and Java virtual machines, where a runtime is non-negotiable (and in the JIT case, fairly heavy-handed). Thinking of it this way has been helpful to me, because the isomorphisms with C++ suddenly become immediately apparent.</p>
<p>The real biggie is array bounds checks. A traditional approach is to check that the index is within the bounds of an array before accessing it, either for loading or storing. That‚Äôs an extra field fetch, compare, and conditional branch. Branch prediction these days is quite good, however it‚Äôs just plain physics that if you do more work, you‚Äôre going to pay for it. Interestingly, the work we‚Äôre doing with C++‚Äôs array_view<T> incurs all these same costs.</p>
<p>Related to this, there can be null checks where they didn‚Äôt exist in C++. If you perform a method dispatch on a null object pointer in C++, for example, you end up running the function anyway. If that function tries to access this, it‚Äôs bound to AV, but in Java and .NET, the compiler is required (per specification) to explicitly check and throw an exception in these cases, before the call even occurs. These little branches can add up too. We eradicated such checks in favor of C++ semantics in optimized builds.</p>
<p>In Midori, we compiled with overflow checking on by default. This is different from stock C#, where you must explicitly pass the /checked flag for this behavior. In our experience, the number of surprising overflows that were caught, and unintended, was well worth the inconvenience and cost. But it did mean that our compiler needed to get really good at understanding how to eliminate unnecessary ones.</p>
<p>Static variables are very expensive in Java and .NET. Way more than you‚Äôd expect. They are mutable and so cannot be stored in the readonly segment of an image where they are shared across processes. And my goodness, the amount of lazy-initialization checking that gets injected into the resulting source code is beyond belief. Switching from preciseinit to beforefieldinit semantics in .NET helps a little bit, since the checks needn‚Äôt happen on every access to a static member ‚Äì just accesses to the static variable in question ‚Äì but it‚Äôs still disgusting compared to a carefully crafted C program with a mixture of constant and intentional global initialization.</p>
<p>The final major area is specific to .NET: structs. Although structs help to alleviate GC pressure and hence are a good thing for most programs, they also carry some subtle problems. The CLI specifies surprising behavior around their initialization, for example. Namely if an exception happens during construction, the struct slot must remain zero- initialized. The result is that most compilers make defensive copies. Another example is that the compiler must make a defensive copy anytime you call a function on a readonly struct. It‚Äôs pretty common for structs to be copied all over the place which, when you‚Äôre counting cycles, hurts, especially since it often means time spent in memcpy. We had a lot of techniques for addressing this and, funny enough, I‚Äôm pretty sure when all was said and done, our code quality here was better than C++‚Äôs, given all of its RAII, copy constructor, destructor, and so on, penalties.
Compilation Architecture</p>
<p>Our architecture involved three major components:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">C# Compiler: Performs lexing, parsing, and semantic analysis. Ultimately translates from C# textual source code into a CIL-based intermediate representation (IR).
</span><span style="color:#c0c5ce;">Bartok: Takes in said IR, does high-level MSIL-based analysis, transformations, and optimizations, and finally lowers this IR to something a bit closer to a more concrete machine representation. For example, generics are gone by the time Bartok is done with the IR.
</span><span style="color:#c0c5ce;">Phoenix: Takes in this lowered IR, and goes to town on it. This is where the bulk of the ‚Äúpedal to the metal‚Äù optimizations happen. The output is machine code.
</span></pre>
<p>The similarities here with Swift‚Äôs compiler design, particularly SIL, are evident. The .NET Native project also mirrors this architecture somewhat. Frankly, most AOT compilers for high level languages do.</p>
<p>In most places, the compiler‚Äôs internal representation leveraged static single assignment form (SSA). SSA was preserved until very late in the compilation. This facilitated and improved the use of many of the classical compiler optimizations mentioned earlier.</p>
<p>The goals of this architecture included:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Facilitate rapid prototyping and experimentation.
</span><span style="color:#c0c5ce;">Produce high-quality machine code on par with commerical C/C++ compilers.
</span><span style="color:#c0c5ce;">Support debugging optimized machine code for improved productivity.
</span><span style="color:#c0c5ce;">Facilitate profile-guided optimizations based on sampling and/or instrumenting code.
</span><span style="color:#c0c5ce;">Suitable for self-host:
</span><span style="color:#c0c5ce;">    The resulting compiled compiler is fast enough.
</span><span style="color:#c0c5ce;">    It is fast enough that the compiler developers enjoy using it.
</span><span style="color:#c0c5ce;">    It is easy to debug problems when the compiler goes astray.
</span></pre>
<p>Finally, a brief warning. We tried lots of stuff. I can‚Äôt remember it all. Both Bartok and Phoenix existed for years before I even got involved in them. Bartok was a hotbed of research on managed languages ‚Äì ranging from optimizations to GC to software transactional memory ‚Äì and Phoenix was meant to replace the shipping Visual C++ compiler. So, anyway, there‚Äôs no way I can tell the full story. But I‚Äôll do my best.
Optimizations</p>
<p>Let‚Äôs go deep on a few specific areas of classical compiler optimizations, extended to cover safe code.
Bounds check elimination</p>
<p>C# arrays are bounds checked. So were ours. Although it is important to eliminate superfluous bounds checks in regular C# code, it was even more so in our case, because even the lowest layers of the system used bounds checked arrays. For example, where in the bowels of the Windows or Linux kernel you‚Äôd see an int*, in Midori you‚Äôd see an int[].</p>
<p>To see what a bounds check looks like, consider a simple example:</p>
<p>var a = new int[100];
for (int i = 0; i &lt; 100; i++) {
... a[i] ...;
}</p>
<p>Here‚Äôs is an example of the resulting machine code for the inner loop array access, with a bounds check:</p>
<p>; First, put the array length into EAX:
3B15: 8B 41 08        mov         eax,dword ptr [rcx+8]
; If EDX &gt;= EAX, access is out of bounds; jump to error:
3B18: 3B D0           cmp         edx,eax
3B1A: 73 0C           jae         3B28
; Otherwise, access is OK; compute element's address, and assign:
3B1C: 48 63 C2        movsxd      rax,edx
3B1F: 8B 44 81 10     mov         dword ptr [rcx+rax*4+10h],r8d
; ...
; The error handler; just call a runtime helper that throws:
3B28: E8 03 E5 FF FF  call        2030</p>
<p>If you‚Äôre doing this bookkeeping on every loop iteration, you won‚Äôt get very tight loop code. And you‚Äôre certainly not going to have any hope of vectorizing it. So, we spent a lot of time and energy trying to eliminate such checks.</p>
<p>In the above example, it‚Äôs obvious to a human that no bounds checking is necessary. To a compiler, however, the analysis isn‚Äôt quite so simple. It needs to prove all sorts of facts about ranges. It also needs to know that a isn‚Äôt aliased and somehow modified during the loop body. It‚Äôs surprising how hard this problem quickly becomes.</p>
<p>Our system had multiple layers of bounds check eliminations.</p>
<p>First it‚Äôs important to note that CIL severely constraints an optimizer by being precise in certain areas. For example, accessing an array out of bounds throws an IndexOutOfRangeException, similar to Java‚Äôs ArrayOutOfBoundsException. And the CIL specifies that it shall do so at precisely the exception that threw it. As we will see later on, our error model was more relaxed. It was based fail-fast and permitted code motion that led to inevitable failures happening ‚Äúsooner‚Äù than they would have otherwise. Without this, our hands would have been tied for much of what I‚Äôm about to discuss.</p>
<p>At the highest level, in Bartok, the IR is still relatively close to the program input. So, some simple patterns could be matched and eliminated. Before lowering further, the ABCD algorithm ‚Äì a straightforward value range analysis based on SSA ‚Äì then ran to eliminate even more common patterns using a more principled approach than pattern matching. We were also able to leverage ABCD in the global analysis phase too, thanks to inter-procedural length and control flow fact propagation.</p>
<p>Next up, the Phoenix Loop Optimizer got its hands on things. This layer did all sorts of loop optimizations and, most relevant to this section, range analysis. For example:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Loop materialization: this analysis actually creates loops. It recognizes repeated patterns of code that would be more ideally represented as loops, and, when profitable, rewrites them as such. This includes unrolling hand-rolled loops so that a vectorizer can get its hands on them, even if they might be re-unrolled later on.
</span><span style="color:#c0c5ce;">Loop cloning, unrolling, and versioning: this analysis creates copies of loops for purposes of specialization. That includes loop unrolling, creating architectural-specific versions of a vectorized loop, and so on.
</span><span style="color:#c0c5ce;">Induction range optimization: this is the phase we are most concerned with in this section. It uses induction range analysis to remove unnecessary checks, in addition to doing classical induction variable optimizations such as widening. As a byproduct of this phase, bounds checks were eliminated and coalesced by hoisting them outside of loops.
</span></pre>
<p>This sort of principled analysis was more capable than what was shown earlier. For example, there are ways to write the earlier loop that can easily ‚Äútrick‚Äù the more basic techniques discussed earlier:</p>
<p>var a = new int[100];</p>
<p>// Trick #1: use the length instead of constant.
for (int i = 0; i &lt; a.length; i++) {
a[i] = i;
}</p>
<p>// Trick #2: start counting at 1.
for (int i = 1; i &lt;= a.length; i++) {
a[i-1] = i-1;
}</p>
<p>// Trick #3: count backwards.
for (int i = a.length - 1; i &gt;= 0; i--) {
a[i] = i;
}</p>
<p>// Trick #4: don't use a for loop at all.
int i = 0;
next:
if (i &lt; a.length) {
a[i] = i;
i++;
goto next;
}</p>
<p>You get the point. Clearly at some point you can screw the optimizer‚Äôs ability to do anything, especially if you start doing virtual dispatch inside the loop body, where aliasing information is lost. And obviously, things get more difficult when the array length isn‚Äôt known statically, as in the above example of 100. All is not lost, however, if you can prove relationships between the loop bounds and the array. Much of this analysis requires special knowledge of the fact that array lengths in C# are immutable.</p>
<p>At the end of the day, doing a good job at optimizing here is the difference between this:</p>
<p>; Initialize induction variable to 0:
3D45: 33 C0           xor         eax,eax
; Put bounds into EDX:
3D58: 8B 51 08        mov         edx,dword ptr [rcx+8]
; Check that EAX is still within bounds; jump if not:
3D5B: 3B C2           cmp         eax,edx
3D5D: 73 13           jae         3D72
; Compute the element address and store into it:
3D5F: 48 63 D0        movsxd      rdx,eax
3D62: 89 44 91 10     mov         dword ptr [rcx+rdx*4+10h],eax
; Increment the loop induction variable:
3D66: FF C0           inc         eax
; If still &lt; 100, then jump back to the loop beginning:
3D68: 83 F8 64        cmp         eax,64h
3D6B: 7C EB           jl          3D58
; ...
; Error routine:
3D72: E8 B9 E2 FF FF  call        2030</p>
<p>And the following, completely optimized, bounds check free, loop:</p>
<p>; Initialize induction variable to 0:
3D95: 33 C0           xor         eax,eax
; Compute the element address and store into it:
3D97: 48 63 D0        movsxd      rdx,eax
3D9A: 89 04 91        mov         dword ptr [rcx+rdx*4],eax
; Increment the loop induction variable:
3D9D: FF C0           inc         eax
; If still &lt; 100, then jump back to the loop beginning:
3D9F: 83 F8 64        cmp         eax,64h
3DA2: 7C F3           jl          3D97</p>
<p>It‚Äôs amusing that I‚Äôm now suffering deja vu as we go through this same exercise with C++‚Äôs new array_view<T> type. Sometimes I joke with my ex-Midori colleagues that we‚Äôre destined to repeat ourselves, slowly and patiently, over the course of the next 10 years. I know that sounds arrogant. But I have this feeling on almost a daily basis.
Overflow checking</p>
<p>As mentioned earlier, in Midori we compiled with checked arithmetic by default (by way of C#‚Äôs /checked flag). This eliminated classes of errors where developers didn‚Äôt anticipate, and therefore code correctly for, overflows. Of course, we kept the explicit checked and unchecked scoping constructs, to override the defaults when appropriate, but this was preferable because a programmer declared her intent.</p>
<p>Anyway, as you might expect, this can reduce code quality too.</p>
<p>For comparison, imagine we‚Äôre adding two variables:</p>
<p>int x = ...;
int y = ...;
int z = x + y;</p>
<p>Now imagine x is in ECX and y is in EDX. Here is a standard unchecked add operation:</p>
<p>03 C2              add         ecx,edx</p>
<p>Or, if you want to get fancy, one that uses the LEA instruction to also store the result in the EAX register using a single instruction, as many modern compilers might do:</p>
<p>8D 04 11           lea         eax,[rcx+rdx]</p>
<p>Well, here‚Äôs the equivalent code with a bounds check inserted into it:</p>
<p>3A65: 8B C1              mov         eax,ecx
3A67: 03 C2              add         eax,edx
3A69: 70 05              jo          3A70
; ...
3A70: E8 B3 E5 FF FF     call        2028</p>
<p>More of those damn conditional jumps (JO) with error handling routines (CALL 2028).</p>
<p>It turns out a lot of the analysis mentioned earlier that goes into proving bounds checks redundant also apply to proving that overflow checks are redundant. It‚Äôs all about proving facts about ranges. For example, if you can prove that some check is dominated by some earlier check, and that furthermore that earlier check is a superset of the later check, then the later check is unnecessary. If the opposite is true ‚Äì that is, the earlier check is a subset of the later check, then if the subsequent block postdominates the earlier one, you might move the stronger check to earlier in the program.</p>
<p>Another common pattern is that the same, or similar, arithmetic operation happens multiple times near one another:</p>
<p>int p = r * 32 + 64;
int q = r * 32 + 64 - 16;</p>
<p>It is obvious that, if the p assignment didn‚Äôt overflow, then the q one won‚Äôt either.</p>
<p>There‚Äôs another magical phenomenon that happens in real world code a lot. It‚Äôs common to have bounds checks and arithmetic checks in the same neighborhood. Imagine some code that reads a bunch of values from an array:</p>
<p>int data0 = data[dataOffset + (DATA_SIZE * 0)];
int data1 = data[dataOffset + (DATA_SIZE * 1)];
int data2 = data[dataOffset + (DATA_SIZE * 2)];
int data3 = data[dataOffset + (DATA_SIZE * 3)];
.. and so on ...</p>
<p>Well C# arrays cannot have negative bounds. If a compiler knows that DATA_SIZE is sufficiently small that an overflowed computation won‚Äôt wrap around past 0, then it can eliminate the range check in favor of the bounds check.</p>
<p>There are many other patterns and special cases you can cover. But the above demonstrates the power of a really good range optimizer that is integrated with loops optimization. It can cover a wide array of scenarios, array bounds and arithmetic operations included. It takes a lot of work, but it‚Äôs worth it in the end.
Inlining</p>
<p>For the most part, inlining is the same as with true native code. And just as important. Often more important, due to C# developers‚Äô tendency to write lots of little methods (like property accessors). Because of many of the topics throughout this article, getting small code can be more difficult than in C++ ‚Äì more branches, more checks, etc. ‚Äì and so, in practice, most managed code compilers inline a lot less than native code compilers, or at least need to be tuned very differently. This can actually make or break performance.</p>
<p>There are also areas of habitual bloat. The way lambdas are encoded in MSIL is unintelligable to a naive backend compiler, unless it reverse engineers that fact. For example, we had an optimization that took this code:</p>
<p>void A(Action a) {
a();
}</p>
<p>void B() {
int x = 42;
A(() =&gt; x++);
...
}</p>
<p>and, after inlining, was able to turn B into just:</p>
<p>void B() {
int x = 43;
...
}</p>
<p>That Action argument to A is a lambda and, if you know how the C# compiler encodes lambdas in MSIL, you‚Äôll appreciate how difficult this trick was. For example, here is the code for B:</p>
<p>.method private hidebysig instance void
B() cil managed
{
// Code size       36 (0x24)
.maxstack  3
.locals init (class P/'&lt;&gt;c__DisplayClass1' V_0)
IL_0000:  newobj     instance void P/'&lt;&gt;c__DisplayClass1'::.ctor()
IL_0005:  stloc.0
IL_0006:  nop
IL_0007:  ldloc.0
IL_0008:  ldc.i4.s   42
IL_000a:  stfld      int32 P/'&lt;&gt;c__DisplayClass1'::x
IL_000f:  ldarg.0
IL_0010:  ldloc.0
IL_0011:  ldftn      instance void P/'&lt;&gt;c__DisplayClass1'::'<B>b__0'()
IL_0017:  newobj     instance void [mscorlib]System.Action::.ctor(object,
native int)
IL_001c:  call       instance void P::A(class [mscorlib]System.Action)
IL_0021:  nop
IL_0022:  nop
IL_0023:  ret
}</p>
<p>To get the magic result required constant propagating the ldftn, recognizing how delegate construction works (IL_0017), leveraging that information to inline B and eliminate the lambda/delegate altogether, and then, again mostly through constant propagation, folding the arithmetic into the constant 42 initialization of x. I always found it elegant that this ‚Äúfell out‚Äù of a natural composition of multiple optimizations with separate concerns.</p>
<p>As with native code, profile guided optimization made our inlining decisions far more effective.
Structs</p>
<p>CLI structs are almost just like C structs. Except they‚Äôre not. The CLI imposes some semantics that incur overheads. These overheads almost always manifest as excessive copying. Even worse, these copies are usually hidden from your program. It‚Äôs worth noting, because of copy constructors and destructors, C++ also has some real issues here, often even worse than what I‚Äôm about to describe.</p>
<p>Perhaps the most annoying is that initializing a struct the CLI way requires a defensive copy. For example, consider this program, where the initialzer for S throws an exception:</p>
<p>class Program {
static void Main() {
S s = new S();
try {
s = new S(42);
}
catch {
System.Console.WriteLine(s.value);
}
}
}</p>
<p>struct S {
public int value;
public S(int value) {
this.value = value;
throw new System.Exception(&quot;Boom&quot;);
}
}</p>
<p>The program behavior here has to be that the value 0 is written to the console. In practice, that means that the assignment operation s = new S(42) must first create a new S-typed slot on the stack, construct it, and then and only then copy the value back over the s variable. For single-int structs like this one, that‚Äôs not a huge deal. For large structs, that means resorting to memcpy. In Midori, we knew what methods could throw, and which could not, thanks to our error model (more later), which meant we could avoid this overhead in nearly all cases.</p>
<p>Another annoying one is the following:</p>
<p>struct S {
// ...
public int Value { get { return this.value; } }
}</p>
<p>static readonly S s = new S();</p>
<p>Every single time we read from s.Value:</p>
<p>int x = s.Value;</p>
<p>we are going to get a local copy. This one‚Äôs actually visible in the MSIL. This is without readonly:</p>
<p>ldsflda    valuetype S Program::s
call       instance int32 S::get_Value()</p>
<p>And this is with it:</p>
<p>ldsfld     valuetype S Program::s
stloc.0
ldloca.s   V_0
call       instance int32 S::get_Value()</p>
<p>Notice that the compiler elected to use ldsfld followed by lodloca.s, rather than loading the address directly, by way of ldsflda in the first example. The resulting machine code is even nastier. I also can‚Äôt pass the struct around by-reference which, as I mention later on, requires copying it and again can be problematic.</p>
<p>We solved this in Midori because our compiler knew about methods that didn‚Äôt mutate members. All statics were immutable to begin with, so the above s wouldn‚Äôt need defensive copies. Alternatively, or in addition to this, the struct could have beem declared as immutable, as follows:</p>
<p>immutable struct S {
// As above ...
}</p>
<p>Or because all static values were immutable anyway. Alternatively, the properties or methods in question could have been annotated as readable meaning that they couldn‚Äôt trigger mutations and hence didn‚Äôt require defensive copies.</p>
<p>I mentioned by-reference passing. In C++, developers know to pass large structures by-reference, either using * or &amp;, to avoid excessive copying. We got in the habit of doing the same. For example, we had in parameters, as so:</p>
<p>void M(in ReallyBigStruct s) {
// Read, but don't assign to, s ...
}</p>
<p>I‚Äôll admit we probably took this to an extreme, to the point where our APIs suffered. If I could do it all over again, I‚Äôd go back and eliminate the fundamental distinction between class and struct in C#. It turns out, pointers aren‚Äôt that bad after all, and for systems code you really do want to deeply understand the distinction between ‚Äúnear‚Äù (value) and ‚Äúfar‚Äù (pointer). We did implement what amounted to C++ references in C#, which helped, but not enough. More on this in my upcoming deep dive on our programming language.
Code size</p>
<p>We pushed hard on code size. Even more than some C++ compilers I know.</p>
<p>A generic instantiation is just a fancy copy-and-paste of code with some substitutions. Quite simply, that means an explosion of code for the compiler to process, compared to what the developer actually wrote. I‚Äôve covered many of the performance challenges with generics in the past. A major problem there is the transitive closure problem. .NET‚Äôs straightforward-looking List<T> class actually creates 28 types in its transitive closure! And that‚Äôs not even speaking to all the methods in each type. Generics are a quick way to explode code size.</p>
<p>I never forgot the day I refactored our LINQ implementation. Unlike in .NET, which uses extension methods, we made all LINQ operations instance methods on the base-most class in our collection type hierarchy. That meant 100-ish nested classes, one for each LINQ operation, for every single collection instantiated! Refactoring this was an easy way for me to save over 100MB of code size across the entire Midori ‚Äúworkstation‚Äù operating system image. Yes, 100MB!</p>
<p>We learned to be more thoughtful about our use of generics. For example, types nested inside an outer generic are usually not good ideas. We also aggressively shared generic instantiations, even more than what the CLR does. Namely, we shared value type generics, where the GC pointers were at the same locations. So, for example, given a struct S:</p>
<p>struct S {
int Field;
}</p>
<p>we would share the same code representation of List<int> with List<S>. And, similarly, given:</p>
<p>struct S {
object A;
int B;
object C;
}</p>
<p>struct T {
object D;
int E;
object F;
}</p>
<p>we would share instantiations between List<S> and List<T>.</p>
<p>You might not realize this, but C# emits IL that ensures structs have sequential layout:</p>
<p>.class private sequential ansi sealed beforefieldinit S
extends [mscorlib]System.ValueType
{
...
}</p>
<p>As a result, we couldn‚Äôt share List<S> and List<T> with some hypothetical List<U>:</p>
<p>struct U {
int G;
object H;
object I;
}</p>
<p>For this, among other reasons ‚Äì like giving the compiler more flexibility around packing, cache alignment, and so on ‚Äì we made structs auto by default in our language. Really, sequential only matters if you‚Äôre doing unsafe code, which, in our programming model, wasn‚Äôt even legal.</p>
<p>We did not support reflection in Midori. In principle, we had plans to do it eventually, as a purely opt-in feature. In practice, we never needed it. What we found is that code generation was always a more suitable solution. We shaved off at least 30% of the best case C# image size by doing this. Significantly more if you factor in systems where the full MSIL is retained, as is usually the case, even for NGen and .NET AOT solutions.</p>
<p>In fact, we removed significant pieces of System.Type too. No Assembly, no BaseType, and yes, even no FullName. The .NET Framework‚Äôs mscorlib.dll contains about 100KB of just type names. Sure, names are useful, but our eventing framework leveraged code generation to produce just those you actually needed to be around at runtime.</p>
<p>At some point, we realized 40% of our image sizes were vtables. We kept pounding on this one relentlessly, and, after all of that, we still had plenty of headroom for improvements.</p>
<p>Each vtable consumes image space to hold pointers to the virtual functions used in dispatch, and of course has a runtime representation. Each object with a vtable also has a vtable pointer embedded within it. So, if you care about size (both image and runtime), you are going to care about vtables.</p>
<p>In C++, you only get a vtable if your type is polymorphic. In languages like C# and Java, on the other hand, you get a vtable even if you don‚Äôt want, need, or use it. In C#, at least, you can use a struct type to elide them. I actually love this aspect of Go, where you get a virtual dispatch- like thing, via interfaces, without needing to pay for vtables on every type; you only pay for what you use, at the point of coercing something to an interface.</p>
<p>Another vtable problem in C# is that all objects inherit three virtuals from System.Object: Equals, GetHashCode, and ToString. Besides the point that these generally don‚Äôt do the right thing in the right way anyways ‚Äì Equals requires reflection to work on value types, GetHashCode is nondeterministic and stamps the object header (or sync- block; more on that later), and ToString doesn‚Äôt offer formatting and localization controls ‚Äì they also bloat every vtable by three slots. This may not sound like much, but it‚Äôs certainly more than C++ which has no such overhead.</p>
<p>The main source of our remaining woes here was the assumption in C#, and frankly most OOP languages like C++ and Java, that RTTI is always available for downcasts. This was particularly painful with generics, for all of the above reasons. Although we aggressively shared instantiations, we could never quite fully fold together the type structures for these guys, even though disparate instantiations tended to be identical, or at least extraordinarily similar. If I could do it all over agan, I‚Äôd banish RTTI. In 90% of the cases, type discriminated unions or pattern matching are more appropriate solutions anyway.
Profile guided optimizations (PGO)</p>
<p>I‚Äôve mentioned profile guided optimization (PGO) already. This was a critical element to ‚Äúgo that last mile‚Äù after mostly everything else in this article had been made competitive. This gave our browser program boosts in the neighborhood of 30-40% on benchmarks like SunSpider and Octane.</p>
<p>Most of what went into PGO was similar to classical native profilers, with two big differences.</p>
<p>First, we tought PGO about many of the unique optimizations listed throughout this article, such as asynchronous stack probing, generics instantiations, lambdas, and more. As with many things, we could have gone on forever here.</p>
<p>Second, we experimented with sample profiling, in addition to the ordinary instrumented profiling. This is much nicer from a developer perspective ‚Äì they don‚Äôt need two builds ‚Äì and also lets you collect counts from real, live running systems in the data center. A good example of what‚Äôs possible is outlined in this Google-Wide Profiling (GWP) paper.
System Architecture</p>
<p>The basics described above were all important. But a number of even more impactful areas required deeper architectural co-design and co-evolution with the language, runtime, framework, and operating system itself. I‚Äôve written about the immense benefits of this sort of ‚Äúwhole system‚Äù approach before. It was kind of magical.
GC</p>
<p>Midori was garbage collected through-and-through. This was a key element of our overall model‚Äôs safety and productivity. In fact, at one point, we had 11 distinct collectors, each with its own unique characteristics. (For instance, see this study.) We had some ways to combat the usual problems, like long pause times. I‚Äôll go through those in a future post, however. For now, let‚Äôs stick to the realm of code quality.</p>
<p>The first top-level decision is: conservative or precise? A conservative collector is easier to wedge into an existing system, however it can cause troubles in certain areas. It often needs to scan more of the heap to get the same job done. And it can falsely keep objects alive. We felt both were unacceptable for a systems programming environment. It was an easy, quick decision: we sought precision.</p>
<p>Precision costs you something in the code generators, however. A precise collector needs to get instructions where to find its root set. That root set includes field offsets in data structures in the heap, and also places on the stack or, even in some cases, registers. It needs to find these so that it doesn‚Äôt miss an object and erroneously collect it or fail to adjust a pointer during a relocation, both of which would lead to memory safety problems. There was no magic trick to making this efficient other than close integration between runtime and code generator, and being thoughtful.</p>
<p>This brings up the topic of cooperative versus preemptive, and the notion of GC safe-points. A GC operating in cooperative mode will only collect when threads have reached so-called ‚Äúsafe-points.‚Äù A GC operating in preemptive mode, on the other hand, is free to stop threads in their tracks, through preemption and thread suspension, so that it may force a collection. In general, preemptive requires more bookkeeping, because the roots must be identifiable at more places, including things that have spilled into registers. It also makes certain low-level code difficult to write, of the ilk you‚Äôll probably find in an operating system‚Äôs kernel, because objects are subject to movement between arbitrary instructions. It‚Äôs difficult to reason about. (See this file, and its associated uses in the CLR codebase, if you don‚Äôt believe me.) As a result, we used cooperative mode as our default. We experimented with automatic safe-point probes inserted by the compiler, for example on loop back-edges, but opted to bank the code quality instead. It did mean GC ‚Äúlivelock‚Äù was possible, but in practice we seldom ran into this.</p>
<p>We used a generational collector. This has the advantage of reducing pause times because less of the heap needs to be inspected upon a given collection. It does come with one disadvantage from the code generator‚Äôs perspective, which is the need to insert write barriers into the code. If an older generation object ever points back at a younger generation object, then the collector ‚Äì which would have normally preferred to limit its scope to younger generations ‚Äì must know to look at the older ones too. Otherwise, it might miss something.</p>
<p>Write barriers show up as extra instructions after certain writes; e.g., note the call:</p>
<p>48 8D 49 08        lea         rcx,[rcx+8]
E8 7A E5 FF FF     call        0000064488002028</p>
<p>That barrier simply updates an entry in the card table, so the GC knows to look at that segment the next time it scans the heap. Most of the time this ends up as inlined assembly code, however it depends on the particulars of the situation. See this code for an example of what this looks like for the CLR on x64.</p>
<p>It‚Äôs difficult for the compiler to optimize these away because the need for write barriers is ‚Äútemporal‚Äù in nature. We did aggressively eliminate them for stack allocated objects, however. And it‚Äôs possible to write, or transform code, into less barrier hungry styles. For example, consider two ways of writing the same API:</p>
<p>bool Test(out object o);
object Test(out bool b);</p>
<p>In the resulting Test method body, you will find a write barrier in the former, but not the latter. Why? Because the former is writing a heap object reference (of type object), and the compiler has no idea, when analyzing this method in isolation, whether that write is to another heap object. It must be conservative in its analysis and assume the worst. The latter, of course, has no such problem, because a bool isn‚Äôt something the GC needs to scan.</p>
<p>Another aspect of GC that impacts code quality is the optional presence of more heavyweight concurrent read and write barriers, when using concurrent collection. A concurrent GC does some collection activities concurrent with the user program making forward progress. This is often a good use of multicore processors and it can reduce pause times and help user code make more forward progress over a given period of time.</p>
<p>There are many challenges with building a concurrent GC, however one is that the cost of the resulting barriers is high. The original concurrent GC by Henry Baker was a copying GC and had the notion of ‚Äúold‚Äù versus ‚Äúnew‚Äù space. All reads and writes had to be checked and, anything operation against the old space had to be forwarded to the new space. Subsequent research for the DEC Firefly used hardware memory protection to reduce the cost, but the faulting cases were still exceedingly expensive. And, worst of all, access times to the heap were unpredictable. There has been a lot of good research into solving this problem, however we abandoned copying.</p>
<p>Instead, we used a concurrent mark-sweep compacting collector. This means only write barriers are needed under normal program execution, however some code was cloned so that read barriers were present when programs ran in the presence of object movement. Our primary GC guy‚Äôs research was published, so you can read all about it. The CLR also has a concurrent collector, but it‚Äôs not quite as good. It uses copying to collect the youngest generation, mark-sweep for the older ones, and the mark phase is parallelized. There are unfortunately a few conditions that can lead to sequential pauses (think of this like a big ‚Äúlock‚Äù), sometimes over 10 milliseconds: 1) all threads must be halted and scanned, an operation that is bounded only by the number of threads and the size of their stacks; 2) copying the youngest generation is bounded only by the size of that generation (thankfully, in normal configurations, this is small); and 3) under worst case conditions, compaction and defragmentation, even of the oldest generation, can happen.
Separate compilation</p>
<p>The basic model to start with is static linking. In this model, you compile everything into a single executable. The benefits of this are obvious: it‚Äôs simple, easy to comprehend, conceptually straightforward to service, and less work for the entire compiler toolchain. Honestly, given the move to Docker containers as the unit of servicing, this model makes more and more sense by the day. But at some point, for an entire operating system, you‚Äôll want separate compilation. Not just because compile times can get quite long when statically linking an entire operating system, but also because the working set and footprint of the resulting processes will be bloated with significant duplication.</p>
<p>Separately compiling object oriented APIs is hard. To be honest, few people have actually gotten it to work. Problems include the fragile base class problem, which is a real killer for version resilient libraries. As a result, most real systems use a dumbed down ‚ÄúC ABI‚Äù at the boundary between components. This is why Windows, for example, has historically used flat C Win32 APIs and, even in the shift to more object orientation via WinRT, uses COM underneath it all. At some runtime expense, the ObjectiveC runtime addressed this challenge. As with most things in computer science, virtually all problems can be solved with an extra level of indirection; this one can be too.</p>
<p>The design pivot we took in Midori was that whole processes were sealed. There was no dynamic loading, so nothing that looked like classical DLLs or SOs. For those scenarios, we used the Asynchronous Everything programming model, which made it easy to dynamically connect to and use separately compiled and versioned processes.</p>
<p>We did, however, want separately compiled binaries, purely as a developer productivity and code sharing (working set) play. Well, I lied. What we ended up with was incrementally compiled binaries, where a change in a root node triggered a cascading recompilation of its dependencies. But for leaf nodes, such as applications, life was beautiful. Over time, we got smarter in the toolchain by understanding precisely which sorts of changes could trigger cascading invalidation of images. A function that was known to never have been inlined across modules, for example, could have its implementation ‚Äì but not its signature ‚Äì changed, without needing to trigger a rebuild. This is similar to the distinction between headers and objects in a classical C/C++ compilation model.</p>
<p>Our compilation model was very similar to C++‚Äôs, in that there was static and dynamic linking. The runtime model, of course, was quite different. We also had the notion of ‚Äúlibrary groups,‚Äù which let us cluster multiple logically distinct, but related, libraries into a single physical binary. This let us do more aggressive inter-module optimizations like inlining, devirtualization, async stack optimizations, and more.
Parametric polymorphism (a.k.a., generics)</p>
<p>That brings me to generics. They throw a wrench into everything.</p>
<p>The problem is, unless you implement an erasure model ‚Äì which utterly stinks performance-wise due to boxing allocations, indirections, or both ‚Äì there‚Äôs no way for you to possibly pre-instantiate all possible versions of the code ahead-of-time. For example, say you‚Äôre providing a List<T>. How do you know whether folks using your library will want a List<int>, List<string>, or List<SomeStructYouveNeverHeardOf>?</p>
<p>Solutions abound:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Do not specialize. Erase everything.
</span><span style="color:#c0c5ce;">Specialize only a subset of instantiations, and create an erased instantiation for the rest.
</span><span style="color:#c0c5ce;">Specialize everything. This gives the best performance, but at some complexity.
</span></pre>
<p>Java uses #1 (in fact, erasure is baked into the language). Many ML compilers use #2. .NET‚Äôs NGen compilation model is sort of a variant of #2, where things that can be trivially specialized are specialized, and everything else is JIT compiled. .NET Native doesn‚Äôt yet have a solution to this problem, which means 3rd party libraries, separate compilation, and generics are a very big TBD. As with everything in Midori, we picked the hardest path, with the most upside, which meant #3. Actually I‚Äôm being a little glib; we had several ML compiler legends on the team, and #2 is fraught with peril; just dig a little into some papers on how hard (and clever) this can get. It‚Äôs difficult to know a priori which instantiations are going to be performance critical to a program. My own experience trying to get C# code into the heart of Windows back in the Longhorn days also reinforced this; we didn‚Äôt want JIT‚Äôting and the rules for what generics you could and couldn‚Äôt use in that world were so mind boggling they eventually led to greek formulas.</p>
<p>Anyway, Midori‚Äôs approach turned out to be harder than it sounded at first.</p>
<p>Imagine you have a diamond. Library A exports a List<T> type, and libraries B and C both instantiate List<int>. A program D then consumes both B and C and maybe even passes List<T> objects returned from one to the other. How do we ensure that the versions of List<int> are compatible?</p>
<p>We called this problem the potentially multiply instantiated, or PMI for short, problem.</p>
<p>The CLR handles this problem by unifying the instantiations at runtime. All RTTI data structures, vtables, and whatnot, are built and/or aggressively patched at runtime. In Midori, on the other hand, we wanted all such data structures to be in readonly data segments and hence shareable across processes, wherever possible.</p>
<p>Again, everything can be solved with an indirection. But unlike solution #2 above, solution #3 permits you to stick indirections only in the rare places where you need them. And for purposes of this one, that meant RTTI and accessing static variables of just those generic types that might have been subject to PMI. First, that affected a vast subset of code (versus #2 which generally affects even loading of instance fields). Second, it could be optimized away for instantiations that were known not to be PMI, by attaching state and operations to the existing generic dictionary that was gets passed around as a hidden argument already. And finally, because of all of this, it was pay for play.</p>
<p>But damn was it complex.</p>
<p>It‚Äôs funny, but C++ RTTI for template instantiations actually suffers from many of the same problems. In fact, the Microsoft Visual C++ compiler resorts to a strcmp of the type names, to resolve diamond issues! (Thankfully there are well-known, more efficient ways to do this, which we are actively pursuing for the next release of VC++.)
Virtual dispatch</p>
<p>Although I felt differently when first switching from Java to C#, Midori made me love that C# made methods non-virtual by default. I‚Äôm sure we would have had to change this otherwise. In fact, we went even further and made classes sealed by default, requiring that you explicitly mark them virtual if you wanted to facilitate subclasses.</p>
<p>Aggressive devirtualization, however, was key to good performance. Each virtual means an indirection. And more impactfully, a lost opportunity to inline (which for small functions is essential). We of course did global intra-module analysis to devirtualize, but also extended this across modules, using whole program compilation, when multiple binaries were grouped together into a library group.</p>
<p>Although our defaults were right, my experience with C# developers is that they go a little hog-wild with virtuals and overly abstract code. I think the ecosystem of APIs that exploded around highly polymorphic abstractions, like LINQ and Reactive Extensions, encouraged this and instilled a bit of bad behavior (‚Äúgratuitous over-abstraction‚Äù). I guess you could make similar arguments about highly templated code in C++. As you can guess, there wasn‚Äôt very much of it in the lowest levels of our codebase ‚Äì where every allocation and instruction mattered ‚Äì but in higher level code, especially in applications that tended to be dominated by high-latency asynchronous operations, the overheads were acceptable and productivity benefits high. A strong culture around identifying and trimming excessive fat helped to ensure features like this were used appropriately, via code reviews, benchmarks, and aggressive static analysis checking.</p>
<p>Interfaces were a challenge.</p>
<p>There are just some poorly designed, inefficient patterns in the .NET Framework. IEnumerator<T> requires two interface dispatches simply to extract the next item! Compare that to C++ iterators which can compile down a pointer increment plus dereference. Many of these problems could be addressed simply with better library designs. (Our final design for enumeration didn‚Äôt even involve interfaces at all.)</p>
<p>Plus invoking a C# interface is tricky. Existing systems do not use pointer adjustment like C++ does so usually an interface dispatch requires a table search. First a level of indirection to get to the vtable, then another level to find the interface table for the interface in question. Some systems attempt to do callsite caching for monomorphic invocations; that is, caching the latest invocation in the hope that the same object kind passes through that callsite time and time again. This requires mutable stubs, however, not to mention an incredibly complex system of thunks and whatnot. In Midori, we never ever ever violated W^X; and we avoided mutable runtime data structures, because they inhibit sharing, both in terms of working set, but also amortizing TLB and data cache pressure.</p>
<p>Our solution took advantage of the memory ordering model earlier. We used so-called ‚Äúfat‚Äù interface pointers. A fat interface pointer was two words: the first, a pointer to the object itself; the second, a pointer to the interface vtable for that object. This made conversion to interfaces slightly slower ‚Äì because the interface vtable lookup had to happen ‚Äì but for cases where you are invoking it one or more times, it came out a wash or ahead. Usually, significantly. Go does something like this, but it‚Äôs slightly different for two reasons. First, they generate the interface tables on the fly, because interfaces are duck typed. Second, fat interface pointers are subject to tearing and hence can violate memory safety in Go, unlike Midori thanks to our strong concurrency model.</p>
<p>The finally challenge in this category was generic virtual methods, or GVMs. To cut to the chase, we banned them. Even if you NGen an image in .NET, all it takes is a call to the LINQ query a.Where(...).Select(...), and you‚Äôre pulling in the JIT compiler. Even in .NET Native, there is considerable runtime data structure creation, lazily, when this happens. In short, there is no known way to AOT compile GVMs in a way that is efficient at runtime. So, we didn‚Äôt even bother offering them. This was a slightly annoying limitation on the programming model but I‚Äôd have done it all over again thanks to the efficiencies that it bought us. It really is surprising how many GVMs are lurking in .NET.
Statics</p>
<p>I was astonished the day I learned that 10% of our code size was spent on static initialization checks.</p>
<p>Many people probably don‚Äôt realize that the CLI specification offers two static initialization modes. There is the default mode and beforefieldinit. The default mode is the same as Java‚Äôs. And it‚Äôs horrible. The static initializer will be run just prior to accessing any static field on that type, any static method on that type, any instance or virtual method on that type (if it‚Äôs a value type), or any constructor on that type. The ‚Äúwhen‚Äù part doesn‚Äôt matter as much as what it takes to make this happen; all of those places now need to be guarded with explicit lazy initialization checks in the resulting machine code!</p>
<p>The beforefieldinit relaxation is weaker. It guarantees the initializer will run sometime before actually accessing a static field on that type. This gives the compiler a lot of leeway in deciding on this placement. Thankfully the C# compiler will pick beforefieldinit automatically for you should you stick to using field initializers only. Most people don‚Äôt realize the incredible cost of choosing instead to use a static constructor, however, especially for value types where suddenly all method calls now incur initialization guards. It‚Äôs just the difference between:</p>
<p>struct S {
static int Field = 42;
}</p>
<p>and:</p>
<p>struct S {
static int Field;
static S() {
Field = 42;
}
}</p>
<p>Now imagine the struct has a property:</p>
<p>struct S {
// As above...
int InstanceField;
public int Property { get { return InstanceField; } }
}</p>
<p>Here‚Äôs the machine code for Property if S has no static initializer, or uses beforefieldinit (automatically injected by C# in the the field initializer example above):</p>
<p>; The struct is one word; move its value into EAX, and return it:
8B C2                mov         eax,edx
C3                   ret</p>
<p>And here‚Äôs what happens if you add a class constructor:</p>
<p>; Big enough to get a frame:
56                   push        rsi
48 83 EC 20          sub         rsp,20h
; Load the field into ESI:
8B F2                mov         esi,edx
; Load up the cctor's initialization state:
48 8D 0D 02 D6 FF FF lea         rcx,[1560h]
48 8B 09             mov         rcx,qword ptr [rcx]
BA 03 00 00 00       mov         edx,3
; Invoke the conditional initialization helper:
E8 DD E0 FF FF       call        2048
; Move the field from ESI into EAX, and return it:
8B C6                mov         eax,esi
48 83 C4 20          add         rsp,20h
5E                   pop         rsi</p>
<p>On every property access!</p>
<p>Of course, all static members still incur these checks, even if beforefieldinit is applied.</p>
<p>Although C++ doesn‚Äôt suffer this same problem, it does have mind-bending initialization ordering semantics. And, like C# statics, C++11 introduced thread-safe initialization, by way of the ‚Äúmagic statics‚Äù feature.</p>
<p>We virtually eliminated this entire mess in Midori.</p>
<p>I mentioned offhandedly earlier that Midori had no mutable statics. More accurately, we extended the notion of const to cover any kind of object. This meant that static values were evaluated at compile-time, written to the readonly segment of the resulting binary image, and shared across all processes. More importantly for code quality, all runtime initialization checks were removed, and all static accesses simply replaced with a constant address.</p>
<p>There were still mutable statics at the core of the system ‚Äì in the kernel, for example ‚Äì but these did not make their way up into user code. And because they were few and far between, we did not rely on the classical C#-style lazy initialization checks for them. They were manually initialized on system startup.</p>
<p>As I said earlier, a 10% reduction in code size, and lots of speed improvements. It‚Äôs hard to know exactly how much saved this was than a standard C# program because by the time we made the change, developers were well aware of the problems and liberally applied our [BeforeFieldInit] attribute all over their types, to avoid some of the overheads. So the 10% number is actually a lower bound on the savings we realized throughout this journey.
Async model</p>
<p>I already wrote a lot about our async model. I won‚Äôt rehash all of that here. I will reiterate one point: the compiler was key to making linked stacks work.</p>
<p>In a linked stacks model, the compiler needs to insert probes into the code that check for available stack space. In the event there isn‚Äôt enough to perform some operation ‚Äì make a function call, dynamically allocate on the stack, etc. ‚Äì the compiler needs to arrange for a new link to get appended, and to switch to it. Mostly this amounts to some range checking, a conditional call to a runtime function, and patching up RSP. A probe looked something like:</p>
<p>; Check amount of stack space:
lea     rax, [rsp-250h]
cmp     rax, qword ptr gs:[0]
ja      prolog
; If insufficient stack, link a new segment:
mov     eax, 10029h
call    ?g_LinkNewStackTrampoline
prolog:
; The real code goes here...</p>
<p>Needless to say, you want to probe as little as possible, for two reasons. First, they incur runtime expense. Second, they chew up code size. There are a few techniques we used to eliminate probes.</p>
<p>The compiler of course knew how to compute stack usage of functions. As a result, it could be smart about the amount of memory to probe for. We incorporated this knowledge into our global analyzer. We could coalesce checks after doing code motion and inlining. We hoisted checks out of loops. For the most part, we optimized for eliminating checks, sometimes at the expense of using a little more stack.</p>
<p>The most effective technique we used to eliminate probes was to run synchronous code on a classical stack, and to teach our compiler to elide probes altogether for them. This took advantage of our understanding of async in the type system. Switching between the classical stack and back again again amounted to twiddling RSP:</p>
<p>; Switch to the classical stack:
move    rsp, qword ptr gs:[10h]
sub     rsp, 20h</p>
<p>; Do some work (like interop w/ native C/C++ code)...</p>
<p>; Now switch back:
lea     rsp, [rbp-50h]</p>
<p>I know Go abandoned linked stacks because of these switches. At first they were pretty bad for us, however after about a man year or two of effort, the switching time faded away into the sub-0.5% noise.
Memory ordering model</p>
<p>Midori‚Äôs stance on safe concurrency had truly one amazing benefit: you get a sequentially consistent memory ordering model for free. You may wish to read that again. Free!</p>
<p>Why is this so? First, Midori‚Äôs process model ensured single-threaded execution by default. Second, any fine-grained parallelism inside of a process was governed by a finite number of APIs, all of which were race-free. The lack of races meant we could inject a fence at fork and join points, selectively, without a developer needing to care or know.</p>
<p>Obviously this had incredible benefits to developer productivity. The fact that Midori programmers never got bitten by memory reordering problems was certainly one of my proudest outcomes of the project.</p>
<p>But it also meant the compiler was free to make more aggressive code motion optimizations, without any sacrifices to this highly productive programming model. In other words, we got the best of both worlds.</p>
<p>A select few kernel developers had to think about the memory ordering model of the underlying machine. These were the people implementing the async model itself. For that, we eliminated C#‚Äôs notion of volatile ‚Äì which is utterly broken anyway ‚Äì in favor of something more like C++ atomics. That model is quite nice for two reasons. First, what kind of fence you need is explicit for every read and write, where it actually matters. (ences affect the uses of a variable, not its declaration. Second, the explicit model tells the compiler more information about what optimizations can or cannot take place, again at a specific uses, where it matters most.
Error model</p>
<p>Our error model journey was a long one and will be the topic of a future post. In a nutshell, however, we experimented with two ends of the spectrum ‚Äì exceptions and return codes ‚Äì and lots of points in betweeen.</p>
<p>Here is what we found from a code quality perspective.</p>
<p>Return codes are nice because the type system tells you an error can happen. A developer is thus forced to deal with them (provided they don‚Äôt ignore return values). Return codes are also simple, and require far less ‚Äúruntime magic‚Äù than exceptions or related mechanisms like setjmp/longjmp. So, lots to like here.</p>
<p>From a code quality persective, however, return codes suck. They force you to execute instructions in hot paths that wouldn‚Äôt have otherwise been executed, including when errors aren‚Äôt even happening. You need to return a value from your function ‚Äì occupying register and/or stack space ‚Äì and callers need to perform branches to check the results. Granted, we hope that these are predicted correctly, but the reality is, you‚Äôre just doing more work.</p>
<p>Untyped exceptions suck when you‚Äôre trying to build a reliable system. Operating systems need to be reliable. Not knowing that there‚Äôs a hidden control flow path when you‚Äôre calling a function is, quite simply, unacceptable. They also require heavier weight runtime support to unwind stacks, search for handlers, and so on. It‚Äôs also a real pain in the arse to model exceptional control flow in the compiler. (If you don‚Äôt believe me, just read through this mail exchange). So, lots to hate here.</p>
<p>Typed exceptions ‚Äì I got used to not saying checked exceptions for fear of hitting Java nerves ‚Äì address some of these shortcomings, but come with their own challenges. Again, I‚Äôll save detailed analysis for my future post.</p>
<p>From a code quality perspective, exceptions can be nice. First, you can organize code segments so that the ‚Äúcold‚Äù handlers aren‚Äôt dirtying your ICACHE on successful pathways. Second, you don‚Äôt need to perform any extra work during the normal calling convention. There‚Äôs no wrapping of values ‚Äì so no extra register or stack pressure ‚Äì and there‚Äôs no branching in callers. There can be some downsides to exceptions, however. In an untyped model, you must assume every function can throw, which obviously inhibits your ability to move code around.</p>
<p>Our model ended up being a hybrid of two things:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Fail-fast for programming bugs.
</span><span style="color:#c0c5ce;">Typed exceptions for dynamically recoverable errors.
</span></pre>
<p>I‚Äôd say the ratio of fail-fast to typed exceptions usage ended up being 10:1. Exceptions were generally used for I/O and things that dealt with user data, like the shell and parsers. Contracts were the biggest source of fail-fast.</p>
<p>The result was the best possible configuration of the above code quality attributes:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">No calling convention impact.
</span><span style="color:#c0c5ce;">No peanut butter associated with wrapping return values and caller branching.
</span><span style="color:#c0c5ce;">All throwing functions were known in the type system, enabling more flexible code motion.
</span><span style="color:#c0c5ce;">All throwing functions were known in the type system, giving us novel EH optimizations, like turning try/finally blocks into straightline code when the try could not throw.
</span></pre>
<p>A nice accident of our model was that we could have compiled it with either return codes or exceptions. Thanks to this, we actually did the experiment, to see what the impact was to our system‚Äôs size and speed. The exceptions-based system ended up being roughly 7% smaller and 4% faster on some key benchmarks.</p>
<p>At the end, what we ended up with was the most robust error model I‚Äôve ever used, and certainly the most performant one.
Contracts</p>
<p>As implied above, Midori‚Äôs programming language had first class contracts:</p>
<p>void Push(T element)
requires element != null
ensures this.Count == old.Count + 1
{
...
}</p>
<p>The model was simple:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">By default, all contracts are checked at runtime.
</span><span style="color:#c0c5ce;">The compiler was free to prove contracts false, and issue compile-time errors.
</span><span style="color:#c0c5ce;">The compiler was free to prove contracts true, and remove these runtime checks.
</span></pre>
<p>We had conditional compilation modes, however I will skip these for now. Look for an upcoming post on our language.</p>
<p>In the early days, we experimented with contract analyzers like MSR‚Äôs Clousot, to prove contracts. For compile-time reasons, however, we had to abandon this approach. It turns out compilers are already very good at doing simple constraint solving and propagation. So eventually we just modeled contracts as facts that the compiler knew about, and let it insert the checks wherever necessary.</p>
<p>For example, the loop optimizer complete with range information above can already leverage checks like this:</p>
<p>void M(int[] array, int index) {
if (index &gt;= 0 &amp;&amp; index &lt; array.Length) {
int v = array[index];
...
}
}</p>
<p>to eliminate the redundant bounds check inside the guarded if statement. So why not also do the same thing here?</p>
<p>void M(int[] array, int index)
requires index &gt;= 0 &amp;&amp; index &lt; array.Length {
int v = array[index];
...
}</p>
<p>These facts were special, however, when it comes to separate compilation. A contract is part of a method‚Äôs signature, and our system ensured proper subtyping substitution, letting the compiler do more aggressive optimizations at separately compiled boundaries. And it could do these optimizations faster because they didn‚Äôt depend on global analysis.
Objects and allocation</p>
<p>In a future post, I‚Äôll describe in great detail our war with the garbage collector. One technique that helped us win, however, was to aggressively reduce the size and quantity of objects a well-behaving program allocated on the heap. This helped with overall working set and hence made programs smaller and faster.</p>
<p>The first technique here was to shrink object sizes.</p>
<p>In C# and most Java VMs, objects have headers. A standard size is a single word, that is, 4 bytes on 32-bit architectures and 8 bytes on 64-bit. This is in addition to the vtable pointer. It‚Äôs typically used by the GC to mark objects and, in .NET, is used for random stuff, like COM interop, locking, memozation of hash codes, and more. (Even the source code calls it the ‚Äúkitchen sink‚Äù.)</p>
<p>Well, we ditched both.</p>
<p>We didn‚Äôt have COM interop. There was no unsafe free-threading so there was no locking (and locking on random objects is a bad idea anyway). Our Object didn‚Äôt define a GetHashCode. Etc. This saved a word per object with no discernable loss in the programming model (actually, to the contrary, it was improved), which is nothing to shake a stick at.</p>
<p>At that point, the only overhead per object was the vtable pointer. For structs, of course there wasn‚Äôt one (unless they were boxed). And we did our best to eliminate all of them. Sadly, due to RTTI, it was difficult to be aggressive. I think this is another area where I‚Äôd go back and entirely upend the C# type system, to follow a more C, C++, or even maybe Go-like, model. In the end, however, I think we did get to be fairly competitive with your average C++ program.</p>
<p>There were padding challenges. Switching the struct layout from C#‚Äôs current default of sequential, to our preferred default of auto, certainly helped. As did optimizations like the well-known C++ empty base optimization.</p>
<p>We also did aggressive escape analysis in order to more efficiently allocate objects. If an object was found to be stack-confined, it was allocated on the stack instead of the heap. Our initial implementation of this moved somewhere in the neighborhood of 10% static allocations from the heap to the stack, and let us be far more aggressive about pruning back the size of objects, eliminating vtable pointers and entire unused fields. Given how conservative this analysis had to be, I was pretty happy with these results.</p>
<p>We offered a hybrid between C++ references and Rust borrowing if developers wanted to give the compiler a hint while at the same time semantically enforcing some level of containment. For example, say I wanted to allocate a little array to share with a callee, but know for sure the callee does not remember a reference to it. This was as simple as saying:</p>
<p>void Caller() {
Callee(new[] { 0, 1, ..., 9 });
}</p>
<p>void Callee(int[]&amp; a) {
... guaranteed that <code>a</code> does not escape ...
}</p>
<p>The compiler used the int[]&amp; information to stack allocate the array and, often, eliminate the vtable for it entirely. Coupled with the sophisticated elimination of bounds checking, this gave us something far closer to C performance.</p>
<p>Lambdas/delegates in our system were also structs, so did not require heap allocation. The captured display frame was subject to all of the above, so frequently we could stack allocate them. As a result, the following code was heap allocation-free; in fact, thanks to some early optimizations, if the callee was inlined, it ran as though the actual lambda body was merely expanded as a sequence of instructions, with no call over head either!</p>
<p>void Caller() {
Callee(() =&gt; ... do something ... );
}</p>
<p>void Callee(Action&amp; callback) {
callback();
}</p>
<p>In my opinion, this really was the killer use case for the borrowing system. Developers avoided lambda-based APIs in the early days before we had this feature for fear of allocations and inefficiency. After doing this feature, on the other hand, a vibrant ecosystem of expressive lambda-based APIs flourished.
Throughput</p>
<p>All of the above have to do with code quality; that is, the size and speed of the resulting code. Another important dimension of compiler performance, however, is throughput; that is, how quickly you can compile the code. Here too a language like C# comes with some of its own challenges.</p>
<p>The biggest challenge we encountered has less to do with the inherently safe nature of a language, and more to do with one very powerful feature: parametric polymorphism. Or, said less pretentiously, generics.</p>
<p>I already mentioned earlier that generics are just a convenient copy-and-paste mechanism. And I mentioned some challenges this poses for code size. It also poses a problem for throughput, however. If a List<T> instantiation creates 28 types, each with its own handful of methods, that‚Äôs just more code for the compiler to deal with. Separate compilation helps, however as also noted earlier, generics often flow across module boundaries. As a result, there‚Äôs likely to be a non-trivial impact to compile time. Indeed, there was.</p>
<p>In fact, this is not very different from where most C++ compilers spend the bulk of their time. In C++, it‚Äôs templates. More modern C++ code-bases have similar problems, due to heavy use of templated abstractions, like STL, smart pointers, and the like. Many C++ code-bases are still just ‚ÄúC with classes‚Äù and suffer this problem less.</p>
<p>As I mentioned earlier, I wish we had banished RTTI. That would have lessened the generics problem. But I would guess generics still would have remained our biggest throughput challenge at the end of the day.</p>
<p>The funny thing ‚Äì in a not-so-funny kind of way ‚Äì is that you can try to do analysis to prune the set of generics and, though it is effective, this analysis takes time. The very thing you‚Äôre trying to save.</p>
<p>A metric we got in the habit of tracking was how much slower AOT compiling a program was than simply C# compiling it. This was a totally unfair comparison, because the C# compiler just needs to lower to MSIL whereas an AOT compler needs to produce machine code. It‚Äôd have been fairer to compare AOT compiling to JIT compiling. But no matter, doing a great job on throughput is especially important for a C# audience. The expectation of productivity was quite high. This was therefore the key metric we felt customers would judge us on, and so we laser-focused on it.</p>
<p>In the early days, the number was ridiculously bad. I remember it being 40x slower. After about a year and half with intense focus we got it down to 3x for debug builds and 5x for optimized builds. I was very happy with this!</p>
<p>There was no one secret to achieving this. Mostly it had to do with just making the compiler faster like you would any program. Since we built the compiler using Midori‚Äôs toolchain, however ‚Äì and compiled it using itself ‚Äì often this was done by first making Midori better, which then made the the compiler faster. It was a nice virtuous loop. We had real problems with string allocations which informed what to do with strings in our programming model. We found crazy generics instantiation closures which forced us to eliminate them and build tools to help find them proactively. Etc.
Culture</p>
<p>A final word before wrapping up. Culture was the most important aspect of what we did. Without the culture, such an amazing team wouldn‚Äôt have self-selected, and wouldn‚Äôt have relentlessly pursued all of the above achievements. I‚Äôll devote an entire post to this. However, in the context of compilers, two things helped:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">We measured everything in the lab. ‚ÄúIf it‚Äôs not in the lab, it‚Äôs dead to me.‚Äù
</span><span style="color:#c0c5ce;">We reviewed progress early and often. Even in areas where no progress was made. We were habitually self-critical.
</span></pre>
<p>Every sprint, we had a so-called ‚ÄúCQ Review‚Äù (where CQ stands for ‚Äúcode quality‚Äù). The compiler team prepared for a few days, by reviewing every benchmark ‚Äì ranging from the lowest of microbenchmarks to compiling and booting all of Windows ‚Äì and investigating any changes. All expected wins were confirmed (we called this ‚Äúconfirming your kill‚Äù), any unexpected regressions were root cause analyzed (and bugs filed), and any wins that didn‚Äôt materialize were also analyzed and reported on so that we could learn from it. We even stared at numbers that didn‚Äôt change, and asked ourselves, why didn‚Äôt they change. Was it expected? Do we feel bad about it and, if so, how will we change next sprint? We reviewed our competitors‚Äô latest compiler drops and monitored their rate of change. And so on.</p>
<p>This process was enormously healthy. Everyone was encouraged to be self-critical. This was not a ‚Äúwitch hunt‚Äù; it was an opportunity to learn as a team how to do better at achieving our goals.</p>
<p>Post-Midori, I have kept this process. I‚Äôve been surprised at how contentious this can be with some folks. They get threatened and worry their lack of progress makes them look bad. They use ‚Äúthe numbers aren‚Äôt changing because that‚Äôs not our focus right now‚Äù as justification for getting out of the rhythm. In my experience, so long as the code is changing, the numbers are changing. It‚Äôs best to keep your eye on them lest you get caught with your pants around your ankles many months later when it suddenly matters most. The discipline and constant drumbeat are the most important parts of these reviews, so skipping even just one can be detrimental, and hence was verboten.</p>
<p>This process was as much our secret sauce as anything else was.
Wrapping Up</p>
<p>Whew, that was a lot of ground to cover. I hope at the very least it was interesting, and I hope for the incredible team who built all of this that I did it at least a fraction of justice. (I know I didn‚Äôt.)</p>
<p>This journey took us over a decade, particularly if you account for the fact that both Bartok and Phoenix had existed for many years even before Midori formed. Merely AOT compiling C#, and doing it well, would have netted us many of the benefits above. But to truly achieve the magical native-like performance, and indeed even exceed it in certain areas, required some key ‚Äúwhole system‚Äù architectural bets. I hope that some day we can deliver safety into the world at this level of performance. Given the state of security all-up in the industry, mankind seriously needs it.</p>
<p>I‚Äôve now touched on our programming language enough that I need to go deep on it. Tune in next time!</p>
<h4 id="the-error-model">The error model<a class="zola-anchor" href="#the-error-model" aria-label="Anchor link for: the-error-model">üîó</a>
</h4>
<p><a href="http://joeduffyblog.com/2016/02/07/the-error-model/">source</a></p>
<p>Midori was written in an ahead-of-time compiled, type-safe language based on C#. Aside from our microkernel, the whole system was written in it, including drivers, the domain kernel, and all user code. I‚Äôve hinted at a few things along the way and now it‚Äôs time to address them head-on. The entire language is a huge space to cover and will take a series of posts. First up? The Error Model. The way errors are communicated and dealt with is fundamental to any language, especially one used to write a reliable operating system. Like many other things we did in Midori, a ‚Äúwhole system‚Äù approach was necessary to getting it right, taking several iterations over several years. I regularly hear from old teammates, however, that this is the thing they miss most about programming in Midori. It‚Äôs right up there for me too. So, without further ado, let‚Äôs start.
Introduction</p>
<p>The basic question an Error Model seeks to answer is: how do ‚Äúerrors‚Äù get communicated to programmers and users of the system? Pretty simple, no? So it seems.</p>
<p>One of the biggest challenges in answering this question turns out to be defining what an error actually is. Most languages lump bugs and recoverable errors into the same category, and use the same facilities to deal with them. A null dereference or out-of-bounds array access is treated the same way as a network connectivity problem or parsing error. This consistency may seem nice at first glance, but it has deep-rooted issues. In particular, it is misleading and frequently leads to unreliable code.</p>
<p>Our overall solution was to offer a two-pronged error model. On one hand, you had fail-fast ‚Äì we called it abandonment ‚Äì for programming bugs. And on the other hand, you had statically checked exceptions for recoverable errors. The two were very different, both in programming model and the mechanics behind them. Abandonment unapologetically tore down the entire process in an instant, refusing to run any user code while doing so. (Remember, a typical Midori program had many small, lightweight processes.) Exceptions, of course, facilitated recovery, but had deep type system support to aid checking and verification.</p>
<p>This journey was long and winding. To tell the tale, I‚Äôve broken this post into six major areas:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Ambitions and Learnings
</span><span style="color:#c0c5ce;">Bugs Aren‚Äôt Recoverable Errors!
</span><span style="color:#c0c5ce;">Reliability, Fault-Tolerance, and Isolation
</span><span style="color:#c0c5ce;">Bugs: Abandonment, Assertions, and Contracts
</span><span style="color:#c0c5ce;">Recoverable Errors: Type-Directed Exceptions
</span><span style="color:#c0c5ce;">Retrospective and Conclusions
</span></pre>
<p>In hindsight, certain outcomes seem obvious. Especially given modern systems languages like Go and Rust. But some outcomes surprised us. I‚Äôll cut to the chase wherever I can but I‚Äôll give ample back-story along the way. We tried out plenty of things that didn‚Äôt work, and I suspect that‚Äôs even more interesting than where we ended up when the dust settled.
Ambitions and Learnings</p>
<p>Let‚Äôs start by examining our architectural principles, requirements, and learnings from existing systems.
Principles</p>
<p>As we set out on this journey, we called out several requirements of a good Error Model:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Usable. It must be easy for developers to do the ‚Äúright‚Äù thing in the face of error, almost as if by accident. A friend and colleague famously called this falling into the The Pit of Success. The model should not impose excessive ceremony in order to write idiomatic code. Ideally it is cognitively familiar to our target audience.

</span><span style="color:#c0c5ce;">Reliable. The Error Model is the foundation of the entire system‚Äôs reliability. We were building an operating system, after all, so reliability was paramount. You might even have accused us as obsessively pursuing extreme levels of it. Our mantra guiding much of the programming model development was ‚Äúcorrect by construction.‚Äù

</span><span style="color:#c0c5ce;">Performant. The common case needs to be extremely fast. That means as close to zero overhead as possible for success paths. Any added costs for failure paths must be entirely ‚Äúpay-for-play.‚Äù And unlike many modern systems that are willing to overly penalize error paths, we had several performance-critical components for which this wasn‚Äôt acceptable, so errors had to be reasonably fast too.

</span><span style="color:#c0c5ce;">Concurrent. Our entire system was distributed and highly concurrent. This raises concerns that are usually afterthoughts in other Error Models. They needed to be front-and-center in ours.

</span><span style="color:#c0c5ce;">Diagnosable. Debugging failures, either interactively or after-the-fact, needs to be productive and easy.

</span><span style="color:#c0c5ce;">Composable. At the core, the Error Model is a programming language feature, sitting at the center of a developer‚Äôs expression of code. As such, it had to provide familiar orthogonality and composability with other features of the system. Integrating separately authored components had to be natural, reliable, and predictable.
</span></pre>
<p>It‚Äôs a bold claim, however I do think what we ended up with succeeded across all dimensions.
Learnings</p>
<p>Existing Error Models didn‚Äôt meet the above requirements for us. At least not fully. If one did well on a dimension, it‚Äôd do poorly at another. For instance, error codes can have good reliability, but many programmers find them error prone to use; further, it‚Äôs easy to do the wrong thing ‚Äì like forget to check one ‚Äì which clearly violates the ‚Äúpit of success‚Äù requirement.</p>
<p>Given the extreme level of reliability we sought, it‚Äôs little surprise we were dissatisfied with most models.</p>
<p>If you‚Äôre optimizing for ease-of-use over reliability, as you might in a scripting language, your conclusions will differ significantly. Languages like Java and C# struggle because they are right at the crossroads of scenarios ‚Äì sometimes being used for systems, sometimes being used for applications ‚Äì but overall their Error Models were very unsuitable for our needs.</p>
<p>Finally, also recall that this story began in the mid-2000s timeframe, before Go, Rust, and Swift were available for our consideration. These three languages have done some great things with Error Models since then.
Error Codes</p>
<p>Error codes are arguably the simplest Error Model possible. The idea is very basic and doesn‚Äôt even require language or runtime support. A function just returns a value, usually an integer, to indicate success or failure:</p>
<p>int foo() {
// <try something here>
if (failed) {
return 1;
}
return 0;
}</p>
<p>This is the typical pattern, where a return of 0 means success and non-zero means failure. A caller must check it:</p>
<p>int err = foo();
if (err) {
// Error!  Deal with it.
}</p>
<p>Most systems offer constants representing the set of error codes rather than magic numbers. There may or may not be functions you can use to get extra information about the most recent error (like errno in standard C and GetLastError in Win32). A return code really isn‚Äôt anything special in the language ‚Äì it‚Äôs just a return value.</p>
<p>C has long used error codes. As a result, most C-based ecosystems do. More low-level systems code has been written using the return code discipline than any other. Linux does, as do countless mission-critical and realtime systems. So it‚Äôs fair to say they have an impressive track record going for them!</p>
<p>On Windows, HRESULTs are equivalent. An HRESULT is just an integer ‚Äúhandle‚Äù and there are a bunch of constants and macros in winerror.h like S_OK, E_FAULT, and SUCCEEDED(), that are used to create and check values. The most important code in Windows is written using a return code discipline. No exceptions are to be found in the kernel. At least not intentionally.</p>
<p>In environments with manual memory management, deallocating memory on error is uniquely difficult. Return codes can make this (more) tolerable. C++ has more automatic ways of doing this using RAII, but unless you buy into the C++ model whole hog ‚Äì which a fair number of systems programmers don‚Äôt ‚Äì then there‚Äôs no good way to incrementally use RAII in your C programs.</p>
<p>More recently, Go has chosen error codes. Although Go‚Äôs approach is similar to C‚Äôs, it has been modernized with much nicer syntax and libraries.</p>
<p>Many functional languages use return codes disguised in monads and named things like Option<T>, Maybe<T>, or Error<T>, which, when coupled with a dataflow-style of programming and pattern matching, feel far more natural. This approach removes several major drawbacks to return codes that we‚Äôre about to discuss, especially compared to C. Rust has largely adopted this model but has dome some exciting things with it for systems programmers.</p>
<p>Despite their simplicity, return codes do come with some baggage; in summary:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Performance can suffer.
</span><span style="color:#c0c5ce;">Programming model usability can be poor.
</span><span style="color:#c0c5ce;">The biggie: You can accidentally forget to check for errors.
</span></pre>
<p>Let‚Äôs discuss each one, in order, with examples from the languages cited above.
Performance</p>
<p>Error codes fail the test of ‚Äúzero overhead for common cases; pay for play for uncommon cases‚Äù:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">There is calling convention impact. You now have two values to return (for non-void returning functions): the actual return value and the possible error. This burns more registers and/or stack space, making calls less efficient. Inlining can of course help to recover this for the subset of calls that can be inlined.

</span><span style="color:#c0c5ce;">There are branches injected into callsites anywhere a callee can fail. I call costs like this ‚Äúpeanut butter,‚Äù because the checks are smeared across the code, making it difficult to measure the impact directly. In Midori we were able to experiment and measure, and confirm that yes, indeed, the cost here is nontrivial. There is also a secondary effect which is, because functions contain more branches, there is more risk of confusing the optimizer.
</span></pre>
<p>This might be surprising to some people, since undoubtedly everyone has heard that ‚Äúexceptions are slow.‚Äù It turns out that they don‚Äôt have to be. And, when done right, they get error handling code and data off hot paths which increases I-cache and TLB performance, compared to the overheads above, which obviously decreases them.</p>
<p>Many high performance systems have been built using return codes, so you might think I‚Äôm nitpicking. As with many things we did, an easy criticism is that we took too extreme an approach. But the baggage gets worse.
Forgetting to Check Them</p>
<p>It‚Äôs easy to forget to check a return code. For example, consider a function:</p>
<p>int foo() { ... }</p>
<p>Now at the callsite, what if we silently ignore the returned value entirely, and just keep going?</p>
<p>foo();
// Keep going -- but foo might have failed!</p>
<p>At this point, you‚Äôve masked a potentially critical error in your program. This is easily the most vexing and damaging problem with error codes. As I will show later, option types help to address this for functional languages. But in C-based languages, and even Go with its modern syntax, this is a real issue.</p>
<p>This problem isn‚Äôt theoretical. I‚Äôve encountered numerous bugs caused by ignoring return codes and I‚Äôm sure you have too. Indeed, in the development of this very Error Model, my team encountered some fascinating ones. For example, when we ported Microsoft‚Äôs Speech Server to Midori, we found that 80% of Taiwan Chinese (zh-tw) requests were failing. Not failing in a way the developers immediately saw, however; instead, clients would get a gibberish response. At first, we thought it was our fault. But then we discovered a silently swallowed HRESULT in the original code. Once we got it over to Midori, the bug was thrown into our faces, found, and fixed immediately after porting. This experience certainly informed our opinion about error codes.</p>
<p>It‚Äôs surprising to me that Go made unused imports an error, and yet missed this far more critical one. So close!</p>
<p>It‚Äôs true you can add a static analysis checker, or maybe an ‚Äúunused return value‚Äù warning as most commercial C++ compilers do. But once you‚Äôve missed the opportunity to add it to the core of the language, as a requirement, none of those techniques will reach critical mass due to complaints about noisy analysis.</p>
<p>For what it‚Äôs worth, forgetting to use return values in our language was a compile time error. You had to explicitly ignore them; early on we used an API for this, but eventually devised language syntax ‚Äì the equivalent of &gt;/dev/null:</p>
<p>ignore foo();</p>
<p>We didn‚Äôt use error codes, however the inability to accidentally ignore a return value was important for the overall reliability of the system. How many times have you debugged a problem only to find that the root cause was a return value you forgot to use? There have even been security exploits where this was the root cause. Letting developers say ignore wasn‚Äôt bulletproof, of course, as they could still do the wrong thing. But it was at least explicit and auditable.
Programming Model Usability</p>
<p>In C-based languages with error codes, you end up writing lots of hand-crafted if checks everywhere after function calls. This can be especially tedious if many of your functions fail which, in C programs where allocation failures are also communicated with return codes, is frequently the case. It‚Äôs also clumsy to return multiple values.</p>
<p>A warning: this complaint is subjective. In many ways, the usability of return codes is actually elegant. You reuse very simple primitives ‚Äì integers, returns, and if branches ‚Äì that are used in myriad other situations. In my humble opinion, errors are an important enough aspect of programming that the language should be helping you out.</p>
<p>Go has a nice syntactic shortcut to make the standard return code checking slightly more pleasant:</p>
<p>if err := foo(); err != nil {
// Deal with the error.
}</p>
<p>Notice that we‚Äôve invoked foo and checked whether the error is non-nil in one line. Pretty neat.</p>
<p>The usability problems don‚Äôt stop there, however.</p>
<p>It‚Äôs common that many errors in a given function should share some recovery or remediation logic. Many C programmers use labels and gotos to structure such code. For example:</p>
<p>int error;</p>
<p>// ...</p>
<p>error = step1();
if (error) {
goto Error;
}</p>
<p>// ...</p>
<p>error = step2();
if (error) {
goto Error;
}</p>
<p>// ...</p>
<p>// Normal function exit.
return 0;</p>
<p>// ...
Error:
// Do something about <code>error</code>.
return error;</p>
<p>Needless to say, this is the kind of code only a mother could love.</p>
<p>In languages like D, C#, and Java, you have finally blocks to encode this ‚Äúbefore scope exits‚Äù pattern more directly. Similarly, Microsoft‚Äôs proprietary extensions to C++ offer __finally, even if you‚Äôre not fully buying into RAII and exceptions. And D provides scope and Go offers defer. All of these help to eradicate the goto Error pattern.</p>
<p>Next, imagine my function wants to return a real value and the possibility of an error? We‚Äôve burned the return slot already so there are two obvious possibilities:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">We can use the return slot for one of the two values (commonly the error), and another slot ‚Äì like a pointer parameter ‚Äì for the other of the two (commonly the real value). This is the common approach in C.

</span><span style="color:#c0c5ce;">We can return a data structure that carries the possibility of both in its very structure. As we will see, this is common in functional languages. But in a language like C, or Go even, that lacks parametric polymorphism, you lose typing information about the returned value, so this is less common to see. C++ of course adds templates, so in principle it could do this, however because it adds exceptions, the ecosystem around return codes is lacking.
</span></pre>
<p>In support of the performance claims above, imagine what both of these do to your program‚Äôs resulting assembly code.
Returning Values ‚ÄúOn The Side‚Äù</p>
<p>An example of the first approach in C looks like this:</p>
<p>int foo(int* out) {
// <try something here>
if (failed) {
return 1;
}
*out = 42;
return 0;
}</p>
<p>The real value has to be returned ‚Äúon the side,‚Äù making callsites clumsy:</p>
<p>int value;
int ret = foo(&amp;value);
if (ret) {
// Error!  Deal with it.
}
else {
// Use value...
}</p>
<p>In addition to being clumsy, this pattern perturbs your compiler‚Äôs definite assignment analysis which impairs your ability to get good warnings about things like using uninitialized values.</p>
<p>Go also takes aim at this problem with nicer syntax, thanks to multi-valued returns:</p>
<p>func foo() (int, error) {
if failed {
return 0, errors.New(&quot;Bad things happened&quot;)
}
return 42, nil
}</p>
<p>And callsites are much cleaner as a result. Combined with the earlier feature of single-line if checking for errors ‚Äì a subtle twist, since at first glance the value return wouldn‚Äôt be in scope, but it is ‚Äì this gets a touch nicer:</p>
<p>if value, err := foo(); err != nil {
// Error!  Deal with it.
} else {
// Use value ...
}</p>
<p>Notice that this also helps to remind you to check the error. It‚Äôs not bulletproof, however, because functions can return an error and nothing else, at which point forgetting to check it is just as easy as it is in C.</p>
<p>As I mentioned above, some would argue against me on the usability point. Especially Go‚Äôs designers, I suspect. A big appeal to Go using error codes is as a rebellion against the overly complex languages in today‚Äôs landscape. We have lost a lot of what makes C so elegant ‚Äì that you can usually look at any line of code and guess what machine code it translates into. I won‚Äôt argue against these points. In fact, I vastly prefer Go‚Äôs model over both unchecked exceptions and Java‚Äôs incarnation of checked exceptions. Even as I write this post, having written lots of Go lately, I look at Go‚Äôs simplicity and wonder, did we go too far with all the try and requires and so on that you‚Äôll see shortly? I‚Äôm not sure. Go‚Äôs error model tends to be one of the most divisive aspect of the language; it‚Äôs probably largely because you can‚Äôt be sloppy with errors as in most languages, however programmers really did enjoy writing code in Midori‚Äôs. In the end, it‚Äôs hard to compare them. I‚Äôm convinced both can be used to write reliable code.
Return Values in Data Structures</p>
<p>Functional languages address many of the usability challenges by packaging up the possibility of either a value or an error, into a single data structure. Because you‚Äôre forced to pick apart the error from the value if you want to do anything useful with the value at the callsite ‚Äì which, thanks to a dataflow style of programming, you probably will ‚Äì it‚Äôs easy to avoid the killer problem of forgetting to check for errors.</p>
<p>For an example of a modern take on this, check out Scala‚Äôs Option type. The unfortunate news is that some languages, like those in the ML family and even Scala (thanks to its JVM heritage), mix this elegant model with the world of unchecked exceptions. This taints the elegance of the monadic data structure approach.</p>
<p>Haskell does something even cooler and gives the illusion of exception handling while still using error values and local control flow:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">There is an old dispute between C++ programmers on whether exceptions or error return codes are the right way. Niklas Wirth considered exceptions to be the reincarnation of GOTO and thus omitted them in his languages. Haskell solves this problem a diplomatic way: Functions return error codes, but the handling of error codes does not uglify the code.
</span></pre>
<p>The trick here is to support all the familiar throw and catch patterns, but using monads rather than control flow.</p>
<p>Although Rust also uses error codes it is also in the style of the functional error types. For example, imagine we are writing a function named bar in Go: we‚Äôd like to call foo, and then simply propagate the error to our caller if it fails:</p>
<p>func bar() error {
if value, err := foo(); err != nil {
return err
} else {
// Use value ...
}
}</p>
<p>The longhand version in Rust isn‚Äôt any more concise. It might, however, send C programmers reeling with its foreign pattern matching syntax (a real concern but not a dealbreaker). Anyone comfortable with functional programming, however, probably won‚Äôt even blink, and this approach certainly serves as a reminder to deal with your errors:</p>
<p>fn bar() -&gt; Result&lt;(), Error&gt; {
match foo() {
Ok(value) =&gt; /* Use value ... */,
Err(err) =&gt; return Err(err)
}
}</p>
<p>But it gets better. Rust has a try! macro that reduces boilerplate like the most recent example to a single expression:</p>
<p>fn bar() -&gt; Result&lt;(), Error&gt; {
let value = try!(foo);
// Use value ...
}</p>
<p>This leads us to a beautiful sweet spot. It does suffer from the performance problems I mentioned earlier, but does very well on all other dimensions. It alone is an incomplete picture ‚Äì for that, we need to cover fail-fast (a.k.a. abandonment) ‚Äì but as we will see, it‚Äôs far better than any other exception-based model in widespread use today.
Exceptions</p>
<p>The history of exceptions is fascinating. During this journey I spent countless hours retracing the industry‚Äôs steps. That includes reading some of the original papers ‚Äì like Goodenough‚Äôs 1975 classic, Exception Handling: Issues and a Proposed Notation ‚Äì in addition to looking at the approaches of several languages: Ada, Eiffel, Modula-2 and 3, ML, and, most inspirationally, CLU. Many papers do a better job than I can summarizing the long and arduous journey, so I won‚Äôt do that here. Instead, I‚Äôll focus on what works and what doesn‚Äôt work for building reliable systems.</p>
<p>Reliability is the most important of our requirements above when developing the Error Model. If you can‚Äôt react appropriately to failures, your system, by definition, won‚Äôt be very reliable. Operating systems generally speaking need to be reliable. Sadly, the most commonplace model ‚Äì unchecked exceptions ‚Äì is the worst you can do in this dimension.</p>
<p>For these reasons, most reliable systems use return codes instead of exceptions. They make it possible to locally reason about and decide how best to react to error conditions. But I‚Äôm getting ahead of myself. Let‚Äôs dig in.
Unchecked Exceptions</p>
<p>A quick recap. In an unchecked exceptions model, you throw and catch exceptions, without it being part of the type system or a function‚Äôs signature. For example:</p>
<p>// Foo throws an unhandled exception:
void Foo() {
throw new Exception(...);
}</p>
<p>// Bar calls Foo, and handles that exception:
void Bar() {
try {
Foo();
}
catch (Exception e) {
// Handle the error.
}
}</p>
<p>// Baz also calls Foo, but does not handle that exception:
void Baz() {
Foo(); // Let the error escape to our callers.
}</p>
<p>In this model, any function call ‚Äì and sometimes any statement ‚Äì can throw an exception, transferring control non-locally somewhere else. Where? Who knows. There are no annotations or type system artifacts to guide your analysis. As a result, it‚Äôs difficult for anyone to reason about a program‚Äôs state at the time of the throw, the state changes that occur while that exception is propagated up the call stack ‚Äì and possibly across threads in a concurrent program ‚Äì and the resulting state by the time it gets caught or goes unhandled.</p>
<p>It‚Äôs of course possible to try. Doing so requires reading API documentation, doing manual audits of the code, leaning heavily on code reviews, and a healthy dose of luck. The language isn‚Äôt helping you out one bit here. Because failures are rare, this tends not to be as utterly disastrous as it sounds. My conclusion is that‚Äôs why many people in the industry think unchecked exceptions are ‚Äúgood enough.‚Äù They stay out of your way for the common success paths and, because most people don‚Äôt write robust error handling code in non-systems programs, throwing an exception usually gets you out of a pickle fast. Catching and then proceeding often works too. No harm, no foul. Statistically speaking, programs ‚Äúwork.‚Äù</p>
<p>Maybe statistical correctness is okay for scripting languages, but for the lowest levels of an operating system, or any mission critical application or service, this isn‚Äôt an appropriate solution. I hope this isn‚Äôt controversial.</p>
<p>.NET makes a bad situation even worse due to asynchronous exceptions. C++ has so-called ‚Äúasynchronous exceptions‚Äù too: these are failures that are triggered by hardware faults, like access violations. It gets really nasty in .NET, however. An arbitrary thread can inject a failure at nearly any point in your code. Even between the RHS and LHS of an assignment! As a result, things that look atomic in source code aren‚Äôt. I wrote about this 10 years ago and the challenges still exist, although the risk has lessened as .NET generally learned that thread aborts are problematic. The new CoreCLR even lacks AppDomains, and the new ASP.NET Core 1.0 stack certainly doesn‚Äôt use thread aborts like it used to. But the APIs are still there.</p>
<p>There‚Äôs a famous interview with Anders Hejlsberg, C#‚Äôs chief designer, called The Trouble with Checked Exceptions. From a systems programmer‚Äôs perspective, much of it leaves you scratching your head. No statement affirms that the target customer for C# was the rapid application developer more than this:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Bill Venners: But aren‚Äôt you breaking their code in that case anyway, even in a language without checked exceptions? If the new version of foo is going to throw a new exception that clients should think about handling, isn‚Äôt their code broken just by the fact that they didn‚Äôt expect that exception when they wrote the code?

</span><span style="color:#c0c5ce;">Anders Hejlsberg : No, because in a lot of cases, people don‚Äôt care. They‚Äôre not going to handle any of these exceptions. There‚Äôs a bottom level exception handler around their message loop. That handler is just going to bring up a dialog that says what went wrong and continue. The programmers protect their code by writing try finally‚Äôs everywhere, so they‚Äôll back out correctly if an exception occurs, but they‚Äôre not actually interested in handling the exceptions.
</span></pre>
<p>This reminds me of On Error Resume Next in Visual Basic, and the way Windows Forms automatically caught and swallowed errors thrown by the application, and attempted to proceed. I‚Äôm not blaming Anders for his viewpoint here; heck, for C#‚Äôs wild popularity, I‚Äôm convinced it was the right call given the climate at the time. But this sure isn‚Äôt the way to write operating system code.</p>
<p>C++ at least tried to offer something better than unchecked exceptions with its throw exception specifications. Unfortunately, the feature relied on dynamic enforcement which sounded its death knell instantaneously.</p>
<p>If I write a function void f() throw(SomeError), the body of f is still free to invoke functions that throw things other than SomeError. Similarly, if I state that f throws no exceptions, using void f() throw(), it‚Äôs still possible to invoke things that throw. To implement the stated contract, therefore, the compiler and runtime must ensure that, should this happen, std::unexpected is called to rip the process down in response.</p>
<p>I‚Äôm not the only person to recognize this design was a mistake. Indeed, throw is now deprecated. A detailed WG21 paper, Deprecating Exception Specifications, describes how C++ ended up here, and has this to offer in its opening statement:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Exception specifications have proven close to worthless in practice, while adding a measurable overhead to programs.
</span></pre>
<p>The authors list three reasons for deprecating throw. Two of the three reasons were a result of the dynamic choice: runtime checking (and its associated opaque failure mode) and runtime performance overheads. The third reason, lack of composition in generic code, could have been dealt with using a proper type system (admittedly at an expense).</p>
<p>But the worst part is that the cure relies on yet another dynamically enforced construct ‚Äì the noexcept specifier ‚Äì which, in my opinion, is just as bad as the disease.</p>
<p>‚ÄúException safety‚Äù is a commonly discussed practice in the C++ community. This approach neatly classifies how functions are intended to behave from a caller‚Äôs perspective with respect to failure, state transitions, and memory management. A function falls into one of four kinds: no-throw means forward progress is guaranteed and no exceptions will emerge; strong safety means that state transitions happen atomically and a failure will not leave behind partially committed state or broken invariants; basic safety means that, though a function might partially commit state changes, invariants will not be broken and leaks are prevented; and finally, no safety means anything‚Äôs possible. This taxonomy is quite helpful and I encourage anyone to be intentional and rigorous about error behavior, either using this approach or something similar. Even if you‚Äôre using error codes. The problem is, it‚Äôs essentially impossible to follow these guidelines in a system using unchecked exceptions, except for leaf node data structures that call a small and easily auditable set of other functions. Just think about it: to guarantee strong safety everywhere, you would need to consider the possibility of all function calls throwing, and safeguard the surrounding code accordingly. That either means programming defensively, trusting another function‚Äôs documented English prose (that isn‚Äôt being checked by a computer), getting lucky and only calling noexcept functions, or just hoping for the best. Thanks to RAII, the leak-freedom aspect of basic safety is easier to attain ‚Äì and pretty common these days thanks to smart pointers ‚Äì but even broken invariants are tricky to prevent. The article Exception Handling: A False Sense of Security sums this up well.</p>
<p>For C++, the real solution is easy to predict, and rather straightforward: for robust systems programs, don‚Äôt use exceptions. That‚Äôs the approach Embedded C++ takes, in addition to numerous realtime and mission critical guidelines for C++, including NASA‚Äôs Jet Propulsion Laboratory‚Äôs. C++ on Mars sure ain‚Äôt using exceptions anytime soon.</p>
<p>So if you can safely avoid exceptions and stick to C-like return codes in C++, what‚Äôs the beef?</p>
<p>The entire C++ ecosystem uses exceptions. To obey the above guidance, you must avoid significant parts of the language and, it turns out, significant chunks of the library ecosystem. Want to use the Standard Template Library? Too bad, it uses exceptions. Want to use Boost? Too bad, it uses exceptions. Your allocator likely throws bad_alloc. And so on. This even causes insanity like people creating forks of existing libraries that eradicates exceptions. The Windows kernel, for instance, has its own fork of the STL that doesn‚Äôt use exceptions. This bifurcation of the ecosystem is neither pleasant nor practical to sustain.</p>
<p>This mess puts us in a bad spot. Especially because many languages use unchecked exceptions. It‚Äôs clear that they are ill-suited for writing low-level, reliable systems code. (I‚Äôm sure I will make a few C++ enemies by saying this so bluntly.) After writing code in Midori for years, it brings me tears to go back and write code that uses unchecked exceptions; even simply code reviewing is torture. But ‚Äúthankfully‚Äù we have checked exceptions from Java to learn and borrow from ‚Ä¶ Right?
Checked Exceptions</p>
<p>Ah, checked exceptions. The rag doll that nearly every Java programmer, and every person who‚Äôs observed Java from an arm‚Äôs length distance, likes to beat on. Unfairly so, in my opinion, when you compare it to the unchecked exceptions mess.</p>
<p>In Java, you know mostly what a method might throw, because a method must say so:</p>
<p>void foo() throws FooException, BarException {
...
}</p>
<p>Now a caller knows that invoking foo could result in either FooException or BarException being thrown. At callsites a programmer must now decide: 1) propagate thrown exceptions as-is, 2) catch and deal with them, or 3) somehow transform the type of exception being thrown (possibly even ‚Äúforgetting‚Äù the type altogether). For instance:</p>
<p>// 1) Propagate exceptions as-is:
void bar() throws FooException, BarException {
foo();
}</p>
<p>// 2) Catch and deal with them:
void bar() {
try {
foo();
}
catch (FooException e) {
// Deal with the FooException error conditions.
}
catch (BarException e) {
// Deal with the BarException error conditions.
}
}</p>
<p>// 3) Transform the exception types being thrown:
void bar() throws Exception {
foo();
}</p>
<p>This is getting much closer to something we can use. But it fails on a few accounts:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Exceptions are used to communicate unrecoverable bugs, like null dereferences, divide-by-zero, etc.

</span><span style="color:#c0c5ce;">You don‚Äôt actually know everything that might be thrown, thanks to our little friend RuntimeException. Because Java uses exceptions for all error conditions ‚Äì even bugs, per above ‚Äì the designers realized people would go mad with all those exception specifications. And so they introduced a kind of exception that is unchecked. That is, a method can throw it without declaring it, and so callers can invoke it seamlessly.

</span><span style="color:#c0c5ce;">Although signatures declare exception types, there is no indication at callsites what calls might throw.

</span><span style="color:#c0c5ce;">People hate them.
</span></pre>
<p>That last one is interesting, and I shall return to it later when describing the approach Midori took. In summary, peoples‚Äô distaste for checked exceptions in Java is largely derived from, or at least significantly reinforced by, the other three bullets above. The resulting model seems to be the worst of both worlds. It doesn‚Äôt help you to write bulletproof code and it‚Äôs hard to use. You end up writing down a lot of gibberish in your code for little perceived benefit. And versioning your interfaces is a pain in the ass. As we‚Äôll see later, we can do better.</p>
<p>That versioning point is worth a ponder. If you stick to a single kind of throw, then the versioning problem is no worse than error codes. Either a function fails or it doesn‚Äôt. It‚Äôs true that if you design version 1 of your API to have no failure mode, and then want to add failures in version 2, you‚Äôre screwed. As you should be, in my opinion. An API‚Äôs failure mode is a critical part of its design and contract with callers. Just as you wouldn‚Äôt change the return type of an API silently without callers needing to know, you shouldn‚Äôt change its failure mode in a semantically meaningful way. More on this controversial point later on.</p>
<p>CLU has an interesting approach, as described in this crooked and wobbly scan of a 1979 paper by Barbara Liskov, Exception Handling in CLU. Notice that they focus a lot on ‚Äúlinguistics‚Äù; in other words, they wanted a language that people would love. The need to check and repropagate all errors at callsites felt a lot more like return values, yet the programming model had that richer and slightly declarative feel of what we now know as exceptions. And most importantly, signals (their name for throw) were checked. There were also convenient ways to terminate the program should an unexpected signal occur.
Universal Problems with Exceptions</p>
<p>Most exception systems get a few major things wrong, regardless of whether they are checked or unchecked.</p>
<p>First, throwing an exception is usually ridiculously expensive. This is almost always due to the gathering of a stack trace. In managed systems, gathering a stack trace also requires groveling metadata, to create strings of function symbol names. If the error is caught and handled, however, you don‚Äôt even need that information at runtime! Diagnostics are better implemented in the logging and diagnostics infrastructure, not the exception system itself. The concerns are orthogonal. Although, to really nail the diagnostics requirement above, something needs to be able to recover stack traces; never underestimate the power of printf debugging and how important stack traces are to it.</p>
<p>Next, exceptions can significantly impair code quality. I touched on this topic in my last post, and there are good papers on the topic in the context of C++. Not having static type system information makes it hard to model control flow in the compiler, which leads to overly conservative optimizers.</p>
<p>Another thing most exception systems get wrong is encouraging too coarse a granularity of handling errors. Proponents of return codes love that error handling is localized to a specific function call. (I do too!) In exception handling systems, it‚Äôs all too easy to slap a coarse-grained try/catch block around some huge hunk of code, without carefully reacting to individual failures. That produces brittle code that‚Äôs almost certainly wrong; if not today, then after the inevitable refactoring that will occur down the road. A lot of this has to do with having the right syntaxes.</p>
<p>Finally, control flow for throws is usually invisible. Even with Java, where you annotate method signatures, it‚Äôs not possible to audit a body of code and see precisely where exceptions come from. Silent control flow is just as bad as goto, or setjmp/longjmp, and makes writing reliable code very difficult.
Where Are We?</p>
<p>Before moving on, let‚Äôs recap where we are:</p>
<p>Good-Bad-Ugly</p>
<p>Wouldn‚Äôt it be great if we could take all of The Goods and leave out The Bads and The Uglies?</p>
<p>This alone would be a great step forward. But it‚Äôs insufficient. This leads me to our first big ‚Äúah-hah‚Äù moment that shaped everything to come. For a significant class of error, none of these approaches are appropriate!
Bugs Aren‚Äôt Recoverable Errors!</p>
<p>A critical distinction we made early on is the difference between recoverable errors and bugs:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">A recoverable error is usually the result of programmatic data validation. Some code has examined the state of the world and deemed the situation unacceptable for progress. Maybe it‚Äôs some markup text being parsed, user input from a website, or a transient network connection failure. In these cases, programs are expected to recover. The developer who wrote this code must think about what to do in the event of failure because it will happen in well-constructed programs no matter what you do. The response might be to communicate the situation to an end-user, retry, or abandon the operation entirely, however it is a predictable and, frequently, planned situation, despite being called an ‚Äúerror.‚Äù

</span><span style="color:#c0c5ce;">A bug is a kind of error the programmer didn‚Äôt expect. Inputs weren‚Äôt validated correctly, logic was written wrong, or any host of problems have arisen. Such problems often aren‚Äôt even detected promptly; it takes a while until ‚Äúsecondary effects‚Äù are observed indirectly, at which point significant damage to the program‚Äôs state might have occurred. Because the developer didn‚Äôt expect this to happen, all bets are off. All data structures reachable by this code are now suspect. And because these problems aren‚Äôt necessarily detected promptly, in fact, a whole lot more is suspect. Depending on the isolation guarantees of your language, perhaps the entire process is tainted.
</span></pre>
<p>This distinction is paramount. Surprisingly, most systems don‚Äôt make one, at least not in a principled way! As we saw above, Java, C#, and dynamic languages just use exceptions for everything; and C and Go use return codes. C++ uses a mixture depending on the audience, but the usual story is a project picks a single one and uses it everywhere. You usually don‚Äôt hear of languages suggesting two different techniques for error handling, however.</p>
<p>Given that bugs are inherently not recoverable, we made no attempt to try. All bugs detected at runtime caused something called abandonment, which was Midori‚Äôs term for something otherwise known as ‚Äúfail-fast‚Äù.</p>
<p>Each of the above systems offers abandonment-like mechanisms. C# has Environment.FailFast; C++ has std::terminate; Go has panic; Rust has panic!; and so on. Each rips down the surrounding context abruptly and promptly. The scope of this context depends on the system ‚Äì for example, C# and C++ terminate the process, Go the current Goroutine, and Rust the current thread, optionally with a panic handler attached to salvage the process.</p>
<p>Although we did use abandonment in a more disciplined and ubiquitous way than is common, we certainly weren‚Äôt the first to recognize this pattern. This Haskell essay, articulates this distinction quite well:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">I was involved in the development of a library that was written in C++. One of the developers told me that the developers are divided into the ones who like exceptions and the other ones who prefer return codes. As it seem to me, the friends of return codes won. However, I got the impression that they debated the wrong point: Exceptions and return codes are equally expressive, they should however not be used to describe errors. Actually the return codes contained definitions like ARRAY_INDEX_OUT_OF_RANGE. But I wondered: How shall my function react, when it gets this return code from a subroutine? Shall it send a mail to its programmer? It could return this code to its caller in turn, but it will also not know how to cope with it. Even worse, since I cannot make assumptions about the implementation of a function, I have to expect an ARRAY_INDEX_OUT_OF_RANGE from every subroutine. My conclusion is that ARRAY_INDEX_OUT_OF_RANGE is a (programming) error. It cannot be handled or fixed at runtime, it can only be fixed by its developer. Thus there should be no according return code, but instead there should be asserts.
</span></pre>
<p>Abandoning fine grained mutable shared memory scopes is suspect ‚Äì like Goroutines or threads or whatever ‚Äì unless your system somehow makes guarantees about the scope of the potential damage done. However, it‚Äôs great that these mechanisms are there for us to use! It means using an abandonment discipline in these languages is indeed possible.</p>
<p>There are architectural elements necessary for this approach to succeed at scale, however. I‚Äôm sure you‚Äôre thinking ‚ÄúIf I tossed the entire process each time I had a null dereference in my C# program, I‚Äôd have some pretty pissed off customers‚Äù; and, similarly, ‚ÄúThat wouldn‚Äôt be reliable at all!‚Äù Reliability, it turns out, might not be what you think.
Reliability, Fault-Tolerance, and Isolation</p>
<p>Before we get any further, we need to state a central belief: Shi Failure Happens.
To Build a Reliable System</p>
<p>Common wisdom is that you build a reliable system by systematically guaranteeing that failure can never happen. Intuitively, that makes a lot of sense. There‚Äôs one problem: in the limit, it‚Äôs impossible. If you can spend millions of dollars on this property alone ‚Äì like many mission critical, realtime systems do ‚Äì then you can make a significant dent. And perhaps use a language like SPARK (a set of contract-based extensions to Ada) to formally prove the correctness of each line written. However, experience shows that even this approach is not foolproof.</p>
<p>Rather than fighting this fact of life, we embraced it. Obviously you try to eliminate failures where possible. The error model must make them transparent and easy to deal with. But more importantly, you architect your system so that the whole remains functional even when individual pieces fail, and then teach your system to recover those failing pieces gracefully. This is well known in distributed systems. So why is it novel?</p>
<p>At the center of it all, an operating system is just a distributed network of cooperating processes, much like a distributed cluster of microservices or the Internet itself. The main differences include things like latency; what levels of trust you can establish and how easily; and various assumptions about locations, identity, etc. But failure in highly asynchronous, distributed, and I/O intensive systems is just bound to happen. My impression is that, largely because of the continued success of monolithic kernels, the world at large hasn‚Äôt yet made the leap to ‚Äúoperating system as a distributed system‚Äù insight. Once you do, however, a lot of design principles become apparent.</p>
<p>As with most distributed systems, our architecture assumed process failure was inevitable. We went to great length to defend against cascading failures, journal regularly, and to enable restartability of programs and services.</p>
<p>You build things differently when you go in assuming this.</p>
<p>In particular, isolation is critical. Midori‚Äôs process model encouraged lightweight fine-grained isolation. As a result, programs and what would ordinarily be ‚Äúthreads‚Äù in modern operating systems were independent isolated entities. Safeguarding against failure of one such connection is far easier than when sharing mutable state in an address space.</p>
<p>Isolation also encourages simplicity. Butler Lampson‚Äôs classic Hints on Computer System Design explores this topic. And I always loved this quote from Hoare:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">The unavoidable price of reliability is simplicity. (C. Hoare).
</span></pre>
<p>By keeping programs broken into smaller pieces, each of which can fail or succeed on its own, the state machines within them stay simpler. As a result, recovering from failure is easier. In our language, the points of possible failure were explicit, further helping to keep those internal state machines correct, and pointing out those connections with the messier outside world. In this world, the price of individual failure is not nearly as dire. I can‚Äôt over-emphasize this point. None of the language features I describe later would have worked so well without this architectural foundation of cheap and ever-present isolation.</p>
<p>Erlang has been very successful at building this property into the language in a fundamental way. It, like Midori, leverages lightweight processes connected by message passing, and encourages fault-tolerant architectures. A common pattern is the ‚Äúsupervisor,‚Äù where some processes are responsible for watching and, in the event of failure, restarting other processes. This article does a terrific job articulating this philosophy ‚Äì ‚Äúlet it crash‚Äù ‚Äì and recommended techniques for architecting reliable Erlang programs in practice.</p>
<p>The key thing, then, is not preventing failure per se, but rather knowing how and when to deal with it.</p>
<p>Once you‚Äôve established this architecture, you beat the hell out of it to make sure it works. For us, this meant week-long stress runs, where processes would come and go, some due to failures, to ensure the system as a whole kept making good forward progress. This reminds me of systems like Netflix‚Äôs Chaos Monkey which just randomly kills entire machines in your cluster to ensure the service as a whole stays healthy.</p>
<p>I expect more of the world to adopt this philosophy as the shift to more distributed computing happens. In a cluster of microservices, for example, the failure of a single container is often handled seamlessly by the enclosing cluster management software (Kubernetes, Amazon EC2 Container Service, Docker Swarm, etc). As a result, what I describe in this post is possibly helpful for writing more reliable Java, Node.js/JavaScript, Python, and even Ruby services. The unfortunate news is you‚Äôre likely going to be fighting your languages to get there. A lot of code in your process is going to work real damn hard to keep limping along when something goes awry.
Abandonment</p>
<p>Even when processes are cheap and isolated and easy to recreate, it‚Äôs still reasonable to think that abandoning an entire process in the face of a bug is an overreaction. Let me try to convince you otherwise.</p>
<p>Proceeding in the face of a bug is dangerous when you‚Äôre trying to build a robust system. If a programmer didn‚Äôt expect a given situation that‚Äôs arisen, who knows whether the code will do the right thing anymore. Critical data structures may have been left behind in an incorrect state. As an extreme (and possibly slightly silly) example, a routine that is meant to round your numbers down for banking purposes might start rounding them up.</p>
<p>And you might be tempted to whittle down the granularity of abandonment to something smaller than a process. But that‚Äôs tricky. To take an example, imagine a thread in your process encounters a bug, and fails. This bug might have been triggered by some state stored in a static variable. Even though some other thread might appear to have been unaffected by the conditions leading to failure, you cannot make this conclusion. Unless some property of your system ‚Äì isolation in your language, isolation of the object root-sets exposed to independent threads, or something else ‚Äì it‚Äôs safest to assume that anything other than tossing the entire address space out the window is risky and unreliable.</p>
<p>Thanks to the lightweight nature of Midori processes, abandoning a process was more like abandoning a single thread in a classical system than a whole process. But our isolation model let us do this reliably.</p>
<p>I‚Äôll admit the scoping topic is a slippery slope. Maybe all the data in the world has become corrupt, so how do you know that tossing the process is even enough?! There is an important distinction here. Process state is transient by design. In a well designed system it can be thrown away and recreated on a whim. It‚Äôs true that a bug can corrupt persistent state, but then you have a bigger problem on your hands ‚Äì a problem that must be dealt with differently.</p>
<p>For some background, we can look to fault-tolerant systems design. Abandonment (fail-fast) is already a common technique in that realm, and we can apply much of what we know about these systems to ordinary programs and processes. Perhaps the most important technique is regularly journaling and checkpointing precious persistent state. Jim Gray‚Äôs 1985 paper, Why Do Computers Stop and What Can Be Done About It?, describes this concept nicely. As programs continue moving to the cloud, and become aggressively decomposed into smaller independent services, this clear separation of transient and persistent state is even more important. As a result of these shifts in how software is written, abandonment is far more achievable in modern architectures than it once was. Indeed, abandonment can help you avoid data corruption, because bugs detected before the next checkpoint prevent bad state from ever escaping.</p>
<p>Bugs in Midori‚Äôs kernel were handled differently. A bug in the microkernel, for instance, is an entirely different beast than a bug in a user-mode process. The scope of possible damage was greater, and the safest response was to abandon an entire ‚Äúdomain‚Äù (address space). Thankfully, most of what you‚Äôd think of being classic ‚Äúkernel‚Äù functionality ‚Äì the scheduler, memory manager, filesystem, networking stack, and even device drivers ‚Äì was run instead in isolated processes in user-mode where failures could be contained in the usual ways described above.
Bugs: Abandonment, Assertions, and Contracts</p>
<p>A number of kinds of bugs in Midori might trigger abandonment:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">An incorrect cast.
</span><span style="color:#c0c5ce;">An attempt to dereference a null pointer.
</span><span style="color:#c0c5ce;">An attempt to access an array outside of its bounds.
</span><span style="color:#c0c5ce;">Divide-by-zero.
</span><span style="color:#c0c5ce;">An unintended mathematical over/underflow.
</span><span style="color:#c0c5ce;">Out-of-memory.
</span><span style="color:#c0c5ce;">Stack overflow.
</span><span style="color:#c0c5ce;">Explicit abandonment.
</span><span style="color:#c0c5ce;">Contract failures.
</span><span style="color:#c0c5ce;">Assertion failures.
</span></pre>
<p>Our fundamental belief was that each is a condition the program cannot recover from. Let‚Äôs discuss each one.
Plain Old Bugs</p>
<p>Some of these situations are unquestionably indicative of a program bug.</p>
<p>An incorrect cast, attempt to dereference null, array out-of-bounds access, or divide-by-zero are clearly problems with the program‚Äôs logic, in that it attempted an undeniably illegal operation. As we will see later, there are ways out (e.g., perhaps you want NaN-style propagation for DbZ). But by default we assume it‚Äôs a bug.</p>
<p>Most programmers were willing to accept this without question. And dealing with them as bugs this way brought abandonment to the inner development loop where bugs during development could be found and fixed fast. Abandonment really did help to make people more productive at writing code. This was a surprise to me at first, but it makes sense.</p>
<p>Some of these situations, on the other hand, are subjective. We had to make a decision about the default behavior, often with controversy, and sometimes offer programmatic control.
Arithmetic Over/Underflow</p>
<p>Saying an unintended arithmetic over/underflow represents a bug is certainly a contentious stance. In an unsafe system, however, such things frequently lead to security vulnerabilities. I encourage you to review the National Vulnerability Database to see the sheer number of these.</p>
<p>In fact, the Windows TrueType Font parser, which we ported to Midori (with gains in performance), has suffered over a dozen of them in the past few years alone. (Parsers tend to be farms for security holes like this.)</p>
<p>This has given rise to packages like SafeInt, which essentially moves you away from your native language‚Äôs arithmetic operations, in favor of checked library ones.</p>
<p>Most of these exploits are of course also coupled with an access to unsafe memory. You could reasonably argue therefore that overflows are innocuous in a safe language and therefore should be permitted. It‚Äôs pretty clear, however, based on the security experience, that a program often does the wrong thing in the face of an unintended over/underflow. Simply put, developers frequently overlook the possibility, and the program proceeds to do unplanned things. That‚Äôs the definition of a bug which is precisely what abandonment is meant to catch. The final nail in the coffin on this one is that philisophically, when there was any question about correctness, we tended to err on the side of explicit intent.</p>
<p>Hence, all unannotated over/underflows were considered bugs and led to abandonment. This was similar to compiling C# with the /checked switch, except that our compiler aggressively optimized redundant checks away. (Since few people ever think to throw this switch in C#, the code-generators don‚Äôt do nearly as aggressive a job in removing the inserted checks.) Thanks to this language and compiler co-development, the result was far better than what most C++ compilers will produce in the face of SafeInt arithmetic. Also as with C#, the unchecked scoping construct could be used where over/underflow was intended.</p>
<p>Although the initial reactions from most C# and C++ developers I‚Äôve spoken to about this idea are negative about it, our experience was that 9 times out of 10, this approach helped to avoid a bug in the program. That remaining 1 time was usually an abandonment sometime late in one of our 72 hour stress runs ‚Äì in which we battered the entire system with browsers and multimedia players and anything else we could do to torture the system ‚Äì when some harmless counter overflowed. I always found it amusing that we spent time fixing these instead of the classical way products mature through the stress program, which is to say deadlocks and race conditions. Between you and me, I‚Äôll take the overflow abandonments!
Out-of-Memory and Stack Overflow</p>
<p>Out-of-memory (OOM) is complicated. It always is. And our stance here was certainly contentious also.</p>
<p>In environments where memory is manually managed, error code-style of checking is the most common approach:</p>
<p>X* x = (X*)malloc(...);
if (!x) {
// Handle allocation failure.
}</p>
<p>This has one subtle benefit: allocations are painful, require thought, and therefore programs that use this technique are often more frugal and deliberate with the way they use memory. But it has a huge downside: it‚Äôs error prone and leads to huge amounts of frequently untested code-paths. And when code-paths are untested, they usually don‚Äôt work.</p>
<p>Developers in general do a terrible job making their software work properly right at the edge of resource exhaustion. In my experience with Windows and the .NET Framework, this is where egregious mistakes get made. And it leads to ridiculously complex programming models, like .NET‚Äôs so-called Constrained Execution Regions. A program limping along, unable to allocate even tiny amounts of memory, can quickly become the enemy of reliability. Chris Brumme‚Äôs wondrous Reliability post describes this and related challenges in all its gory glory.</p>
<p>Parts of our system were of course ‚Äúhardened‚Äù in a sense, like the lowest levels of the kernel, where abandonment‚Äôs scope would be necessarily wider than a single process. But we kept this to as little code as possible.</p>
<p>For the rest? Yes, you guessed it: abandonment. Nice and simple.</p>
<p>It was surprising how much of this we got away with. I attribute most of this to the isolation model. In fact, we could intentionally let a process suffer OOM, and ensuing abandonment, as a result of resource management policy, and still remain confident that stability and recovery were built in to the overall architecture.</p>
<p>It was possible to opt-in to recoverable failure for individual allocations if you really wanted. This was not common in the slightest, however the mechanisms to support it were there. Perhaps the best motivating example is this: imagine your program wants to allocate a buffer of 1MB in size. This situation is different than your ordinary run-of-the-mill sub-1KB object allocation. A developer may very well be prepared to think and explicitly deal with the fact that a contiguous block of 1MB in size might not be available, and deal with it accordingly. For example:</p>
<p>var bb = try new byte[1024*1024] else catch;
if (bb.Failed) {
// Handle allocation failure.
}</p>
<p>Stack overflow is a simple extension of this same philosophy. Stack is just a memory-backed resource. In fact, thanks to our asynchronous linked stacks model, running out of stack was physically identical to running out of heap memory, so the consistency in how it was dealt with was hardly surprising to developers. Many systems treat stack overflow this way these days.
Assertions</p>
<p>An assertion was a manual check in the code that some condition held true, triggering abandonment if it did not. As with most systems, we had both debug-only and release code assertions, however unlike most other systems, we had more release ones than debug. In fact, our code was peppered liberally with assertions. Most methods had multiple.</p>
<p>This kept with the philosophy that it‚Äôs better to find a bug at runtime than to proceed in the face of one. And, of course, our backend compiler was taught how to optimize them aggressively as with everything else. This level of assertion density is similar to what guidelines for highly reliable systems suggest. For example, from NASA‚Äôs paper, The Power of Ten -Rules for Developing Safety Critical Code:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Rule: The assertion density of the code should average to a minimum of two assertions per function. Assertions are used to check for anomalous conditions that should never happen in real-life executions. Assertions must always be side-effect free and should be defined as Boolean tests.

</span><span style="color:#c0c5ce;">Rationale: Statistics for industrial coding efforts indicate that unit tests often find at least one defect per 10 to 100 lines of code written. The odds of intercepting defects increase with assertion density. Use of assertions is often also recommended as part of strong defensive coding strategy.
</span></pre>
<p>To indicate an assertion, you simply called Debug.Assert or Release.Assert:</p>
<p>void Foo() {
Debug.Assert(something); // Debug-only assert.
Release.Assert(something); // Always-checked assert.
}</p>
<p>We also implemented functionality akin to <strong>FILE</strong> and <strong>LINE</strong> macros like in C++, in addition to <strong>EXPR</strong> for the text of the predicate expression, so that abandonments due to failed assertions contained useful information.</p>
<p>In the early days, we used different ‚Äúlevels‚Äù of assertions than these. We had three levels, Contract.Strong.Assert, Contract.Assert, and Contract.Weak.Assert. The strong level meant ‚Äúalways checked,‚Äù the middle one meant ‚Äúit‚Äôs up to the compiler,‚Äù and the weak one meant ‚Äúonly checked in debug mode.‚Äù I made the controversial decision to move away from this model. In fact, I‚Äôm pretty sure 49.99% of the team absolutely hated my choice of terminology (Debug.Assert and Release.Assert), but I always liked them because it‚Äôs pretty unambiguous what they do. The problem with the old taxonomy was that nobody ever knew exactly when the assertions would be checked; confusion in this area is simply not acceptable, in my opinion, given how important good assertion discipline is to the reliability of one‚Äôs program.</p>
<p>As we moved contracts to the language (more on that soon), we tried making assert a keyword too. However, we eventually switched back to using APIs. The primary reason was that assertions were not part of an API‚Äôs signature like contracts are; and given that assertions could easily be implemented as a library, it wasn‚Äôt clear what we gained from having them in the language. Furthermore, policies like ‚Äúchecked in debug‚Äù versus ‚Äúchecked in release‚Äù simply didn‚Äôt feel like they belonged in a programming language. I‚Äôll admit, years later, I‚Äôm still on the fence about this.
Contracts</p>
<p>Contracts were the central mechanism for catching bugs in Midori. Despite us beginning with Singularity, which used Sing#, a variant of Spec#, we quickly moved away to vanilla C# and had to rediscover what we wanted. We ultimately ended up in a very different place after living with the model for years.</p>
<p>All contracts and assertions were proven side-effect free thanks to our language‚Äôs understanding of immutability and side-effects. This was perhaps the biggest area of language innovation, so I‚Äôll be sure to write a post about it soon.</p>
<p>As with other areas, we were inspired and influenced by many other systems. Spec# is the obvious one. Eiffel was hugely influential especially as there are many published case studies to learn from. Research efforts like Ada-based SPARK and proposals for realtime and embedded systems too. Going deeper into the theoretical rabbit‚Äôs hole, programming logic like Hoare‚Äôs axiomatic semantics provide the foundation for all of it. For me, however, the most philosophical inspiration came from CLU‚Äôs, and later Argus‚Äôs, overall approach to error handling.
Preconditions and Postconditions</p>
<p>The most basic form of contract is a method precondition. This states what conditions must hold for the method to be dispatched. This is most often used to validate arguments. Sometimes it‚Äôs used to validate the state of the target object, however this was generally frowned upon, since modality is a tough thing for programmers to reason about. A precondition is essentially a guarantee the caller provides to the callee.</p>
<p>In our final model, a precondition was stated using the requires keyword:</p>
<p>void Register(string name)
requires !string.IsEmpty(name) {
// Proceed, knowing the string isn't empty.
}</p>
<p>A slightly less common form of contract is a method postcondition. This states what conditions hold after the method has been dispatched. This is a guarantee the callee provides to the caller.</p>
<p>In our final model, a postcondition was stated using the ensures keyword:</p>
<p>void Clear()
ensures Count == 0 {
// Proceed; the caller can be guaranteed the Count is 0 when we return.
}</p>
<p>It was also possible to mention the return value in the postcondition, through the special name return. Old values ‚Äì such as necessary for mentioning an input in a post-condition ‚Äì could be captured through old(..); for example:</p>
<p>int AddOne(int value)
ensures return == old(value)+1 {
...
}</p>
<p>Of course, pre- and postconditions could be mixed. For example, from our ring buffer in the Midori kernel:</p>
<p>public bool PublishPosition()
requires RemainingSize == 0
ensures UnpublishedSize == 0 {
...
}</p>
<p>This method could safely execute its body knowing that RemainingSize is 0 and callers could safely execute after the return knowing that UnpublishedSize is also 0.</p>
<p>If any of these contracts are found to be false at runtime, abandonment occurs.</p>
<p>This is an area where we differ from other efforts. Contracts have recently became popular as an expression of program logics used in advanced proof techniques. Such tools prove truths or falsities about stated contracts, often using global analysis. We took a simpler approach. By default, contracts are checked at runtime. If a compiler could prove truth or falsehood at compile-time, it was free to elide runtime checks or issue a compile-time error, respectively.</p>
<p>Modern compilers have constraint-based analyses that do a good job at this, like the range analysis I mentioned in my last post. These propagate facts and use them to optimize code already. This includes eliminating redundant checks: either explicitly encoded in contracts, or in normal program logic. And they are trained to perform these analyses in reasonable amounts of time, lest programmers switch to a different, faster compiler. The theorem proving techniques simply did not scale for our needs; our core system module took over a day to analyze using the best in breed theorem proving analysis framework!</p>
<p>Furthermore, the contracts a method declared were part of its signature. This meant they would automatically show up in documentation, IDE tooltips, and more. A contract was as important as a method‚Äôs return and argument types. Contracts really were just an extension of the type system, using arbitrary logic in the language to control the shape of exchange types. As a result, all the usual subtyping requirements applied to them. And, of course, this facilitated modular local analysis which could be done in seconds using standard optimizing compiler techniques.</p>
<p>90-something% of the typical uses of exceptions in .NET and Java became preconditions. All of the ArgumentNullException, ArgumentOutOfRangeException, and related types and, more importantly, the manual checks and throws were gone. Methods are often peppered with these checks in C# today; there are thousands of these in .NET‚Äôs CoreFX repo alone. For example, here is System.IO.TextReader‚Äôs Read method:</p>
<p>/// <summary>
/// ...
/// </summary>
/// <exception cref="ArgumentNullException">Thrown if buffer is null.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown if index is less than zero.</exception>
/// <exception cref="ArgumentOutOfRangeException">Thrown if count is less than zero.</exception>
/// <exception cref="ArgumentException">Thrown if index and count are outside of buffer's bounds.</exception>
public virtual int Read(char[] buffer, int index, int count) {
if (buffer == null) {
throw new ArgumentNullException(&quot;buffer&quot;);
}
if (index &lt; 0) {
throw new ArgumentOutOfRangeException(&quot;index&quot;);
}
if (count &lt; 0) {
throw new ArgumentOutOfRangeException(&quot;count&quot;);
}
if (buffer.Length - index &lt; count) {
throw new ArgumentException();
}
...
}</p>
<p>This is broken for a number of reasons. It‚Äôs laboriously verbose, of course. All that ceremony! But we have to go way out of our way to document the exceptions when developers really ought not to ever catch them. Instead, they should find the bug during development and fix it. All this exception nonsense encourages very bad behavior.</p>
<p>If we use Midori-style contracts, on the other hand, this collapses to:</p>
<p>/// <summary>
/// ...
/// </summary>
public virtual int Read(char[] buffer, int index, int count)
requires buffer != null
requires index &gt;= 0
requires count &gt;= 0
requires buffer.Length - index &gt;= count {
...
}</p>
<p>There are a few appealing things about this. First, it‚Äôs more concise. More importantly, however, it self-describes the contract of the API in a way that documents itself and is easy to understand by callers. Rather than requiring programmers to express the error condition in English, the actual expressions are available for callers to read, and tools to understand and leverage. And it uses abandonment to communicate failure.</p>
<p>I should also mention we had plenty of contracts helpers to help developers write common preconditions. The above explicit range checking is very messy and easy to get wrong. Instead, we could have written:</p>
<p>public virtual int Read(char[] buffer, int index, int count)
requires buffer != null
requires Range.IsValid(index, count, buffer.Length) {
...
}</p>
<p>And, totally aside from the conversation at hand, coupled with two advanced features ‚Äì arrays as slices and non-null types ‚Äì we could have reduced the code to the following, while preserving the same guarantees:</p>
<p>public virtual int Read(char[] buffer) {
...
}</p>
<p>But I‚Äôm jumping way ahead ‚Ä¶
Humble Beginnings</p>
<p>Although we landed on the obvious syntax that is very Eiffel- and Spec#-like ‚Äì coming full circle ‚Äì as I mentioned earlier, we really didn‚Äôt want to change the language at the outset. So we actually began with a simple API approach:</p>
<p>public bool PublishPosition() {
Contract.Requires(RemainingSize == 0);
Contract.Ensures(UnpublishedSize == 0);
...
}</p>
<p>There are a number of problems with this approach, as the .NET Code Contracts effort discovered the hard way.</p>
<p>First, contracts written this way are part of the API‚Äôs implementation, whereas we want them to be part of the signature. This might seem like a theoretical concern but it is far from being theoretical. We want the resulting program to contain built-in metadata so tools like IDEs and debuggers can display the contracts at callsites. And we want tools to be in a position to auto-generate documentation from the contracts. Burying them in the implementation doesn‚Äôt work unless you somehow disassemble the method to extract them later on (which is a hack).</p>
<p>This also makes it tough to integrate with a backend compiler which we found was necessary for good performance.</p>
<p>Second, you might have noticed an issue with the call to Contract.Ensures. Since Ensures is meant to hold on all exit paths of the function, how would we implement this purely as an API? The answer is, you can‚Äôt. One approach is rewriting the resulting MSIL, after the language compiler emitted it, but that‚Äôs messy as all heck. At this point, you begin to wonder, why not simply acknowledge that this is a language expressivity and semantics issue, and add syntax?</p>
<p>Another area of perpetual struggle for us was whether contracts are conditional or not. In many classical systems, you‚Äôd check contracts in debug builds, but not the fully optimized ones. For a long time, we had the same three levels for contracts that we did assertions mentioned earlier:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Weak, indicated by Contract.Weak.*, meaning debug-only.
</span><span style="color:#c0c5ce;">Normal, indicated simply by Contract.*, leaving it as an implementation decision when to check them.
</span><span style="color:#c0c5ce;">Strong, indicated by Contract.Strong.*, meaning always checked.
</span></pre>
<p>I‚Äôll admit, I initially found this to be an elegant solution. Unfortunately, over time we found that there was constant confusion about whether ‚Äúnormal‚Äù contracts were on in debug, release, or all of the above (and so people misused weak and strong accordingly). Anyway, when we began integrating this scheme into the language and backend compiler toolchain, we ran into substantial issues and had to backpedal a little bit.</p>
<p>First, if you simply translated Contract.Weak.Requires to weak requires and Contract.Strong.Requires to strong requires, in my opinion, you end up with a fairly clunky and specialized language syntax, with more policy than made me comfortable. It immediately calls out for parameterization and substitutability of the weak/strong policies.</p>
<p>Next, this approach introduces a sort of new mode of conditional compilation that, to me, felt awkward. In other words, if you want a debug-only check, you can already say something like:</p>
<p>#if DEBUG
requires X
#endif</p>
<p>Finally ‚Äì and this was the nail in the coffin for me ‚Äì contracts were supposed to be part of an API‚Äôs signature. What does it even mean to have a conditional contract? How is a tool supposed to reason about it? Generate different documentation for debug builds than release builds? Moreover, as soon as you do this, you lose a critical guarantee, which is that code doesn‚Äôt run if its preconditions aren‚Äôt met.</p>
<p>As a result, we nuked the entire conditional compilation scheme.</p>
<p>We ended up with a single kind of contract: one that was part of an API‚Äôs signature and checked all the time. If a compiler could prove the contract was satisfied at compile-time ‚Äì something we spent considerable energy on ‚Äì it was free to elide the check altogether. But code was guaranteed it would never execute if its preconditions weren‚Äôt satisfied. For cases where you wanted conditional checks, you always had the assertion system (described above).</p>
<p>I felt better about this bet when we deployed the new model and found that lots of people had been misusing the ‚Äúweak‚Äù and ‚Äústrong‚Äù notions above out of confusion. Forcing developers to make the decision led to healthier code.
Future Directions</p>
<p>A number of areas of development were at varying stages of maturity when our project wound down.
Invariants</p>
<p>We experimented a lot with invariants. Anytime we spoke to someone versed in design-by-contract, they were borderline appalled that we didn‚Äôt have them from day one. To be honest, our design did include them from the outset. But we never quite got around to finishing the implementation and deploying it. This was partly just due to engineering bandwidth, but also because some difficult questions remained. And honestly the team was almost always satisfied with the combination of pre- and post-conditions plus assertions. I suspect that in the fullness of time we‚Äôd have added invariants for completeness, but to this day some questions remain for me. I‚Äôd need to see it in action for a while.</p>
<p>The approach we had designed was where an invariant becomes a member of its enclosing type; for example:</p>
<p>public class List<T> {
private T[] array;
private int count;
private invariant index &gt;= 0 &amp;&amp; index &lt; array.Length;
...
}</p>
<p>Notice that the invariant is marked private. An invariant‚Äôs accessibility modifier controlled which members the invariant was required to hold for. For example, a public invariant only had to hold at the entry and exit of functions with public accessibility; this allowed for the common pattern of private functions temporarily violating invariants, so long as public entrypoints preserved them. Of course, as in the above example, a class was free to declare a private invariant too, which was required to hold at all function entries and exits.</p>
<p>I actually quite liked this design, and I think it would have worked. The primary concern we all had was the silent introduction of checks all over the place. To this day, that bit still makes me nervous. For example, in the List<T> example, you‚Äôd have the index &gt;= 0 &amp;&amp; index &lt; array.Length check at the beginning and end of every single function of the type. Now, our compiler eventually got very good at recognizing and coalescing redundant contract checks; and there were ample cases where the presence of a contract actually made code quality better. However, in the extreme example given above, I‚Äôm sure there would have been a performance penalty. That would have put pressure on us changing the policy for when invariants are checked, which would have possibly complicated the overall contracts model.</p>
<p>I really wish we had more time to explore invariants more deeply. I don‚Äôt think the team sorely missed not having them ‚Äì certainly I didn‚Äôt hear much complaining about their absence (probably because the team was so performance conscious) ‚Äì but I do think invariants would have been a nice icing to put on the contracts cake.
Advanced Type Systems</p>
<p>I always liked to say that contracts begin where the type system leaves off. A type system allows you to encode attributes of variables using types. A type limits the expected range values that a variable might hold. A contract similarly checks the range of values that a variable holds. The difference? Types are proven at compile-time through rigorous and composable inductive rules that are moderately inexpensive to check local to a function, usually, but not always, aided by developer-authored annotations. Contracts are proven at compile-time where possible and at runtime otherwise, and as a result, permit far less rigorous specification using arbitrary logic encoded in the language itself.</p>
<p>Types are preferable, because they are guaranteed to be compile-time checked; and guaranteed to be fast to check. The assurances given to the developer are strong and the overall developer productivity of using them is better.</p>
<p>Limitations in a type system are inevitable, however; a type system needs to leave some wiggle room, otherwise it quickly grows unwieldly and unusable and, in the extreme, devolves into bi-value bits and bytes. On the other hand, I was always disappointed by two specific areas of wiggle room that required the use of contracts:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Nullability.
</span><span style="color:#c0c5ce;">Numeric ranges.
</span></pre>
<p>Approximately 90% of our contracts fell into these two buckets. As a result, we seriously explored more sophisticated type systems to classify the nullability and ranges of variables using the type system instead of contracts.</p>
<p>To make it concrete, this was the difference between this code which uses contracts:</p>
<p>public virtual int Read(char[] buffer, int index, int count)
requires buffer != null
requires index &gt;= 0
requires count &gt;= 0
requires buffer.Length - index &lt; count {
...
}</p>
<p>And this code which didn‚Äôt need to, and yet carried all the same guarantees, checked statically at compile-time:</p>
<p>public virtual int Read(char[] buffer) {
...
}</p>
<p>Placing these properties in the type system significantly lessens the burden of checking for error conditions. Lets say that for any given 1 producer of state there are 10 consumers. Rather than having each of those 10 defend themselves against error conditions, we can push the responsibility back onto that 1 producer, and either require a single assertion that coerces the type, or even better, that the value is stored into the right type in the first place.
Non-Null Types</p>
<p>The first one‚Äôs really tough: guaranteeing statically that variables do not take on the null value. This is what Tony Hoare has famously called his ‚Äúbillion dollar mistake‚Äù. Fixing this for good is a righteous goal for any language and I‚Äôm happy to see newer language designers tackling this problem head-on.</p>
<p>Many areas of the language fight you every step of the way on this one. Generics, zero-initialization, constructors, and more. Retrofitting non-null into an existing language is tough!
The Type System</p>
<p>In a nutshell, non-nullability boiled down to some simple type system rules:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">All unadorned types T were non-null by default.
</span><span style="color:#c0c5ce;">Any type could be modified with a ?, as in T?, to mark it nullable.
</span><span style="color:#c0c5ce;">null is an illegal value for variables of non-null types.
</span><span style="color:#c0c5ce;">T implicitly converts to T?. In a sense, T is a subtype of T? (although not entirely true).
</span><span style="color:#c0c5ce;">Operators exist to convert a T? to a T, with runtime checks that abandoned on null.
</span></pre>
<p>Most of this is probably ‚Äúobvious‚Äù in the sense that there aren‚Äôt many choices. The name of the game is systematically ensuring all avenues of null are known to the type system. In particular, no null can ever ‚Äúsneakily‚Äù become the value of a non-null T type; this meant addressing zero-initialization, perhaps the hardest problem of all.
The Syntax</p>
<p>Syntactically, we offered a few ways to accomplish #5, converting from T? to T. Of course, we discouraged this, and preferred you to stay in ‚Äúnon-null‚Äù space as long as possible. But sometimes it‚Äôs simply not possible. Multi-step initialization happens from time to time ‚Äì especially with collections data structures ‚Äì and had to be supported.</p>
<p>Imagine for a moment we have a map:</p>
<p>Map&lt;int, Customer&gt; customers = ...;</p>
<p>This tells us three things by construction:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">The Map itself is not null.
</span><span style="color:#c0c5ce;">The int keys inside of it will not be null.
</span><span style="color:#c0c5ce;">The Customer values inside of it will also not be null.
</span></pre>
<p>Let‚Äôs now say that the indexer actually returns null to indicate the key was missing:</p>
<p>public TValue? this[TKey key] {
get { ... }
}</p>
<p>Now we need some way of checking at callsites whether the lookup succeeded. We debated many syntaxes.</p>
<p>The easiest we landed on was a guarded check:</p>
<p>Customer? customer = customers[id];
if (customer != null) {
// In here, <code>customer</code> is of non-null type <code>Customer</code>.
}</p>
<p>I‚Äôll admit, I was always on the fence about the ‚Äúmagical‚Äù type coercions. It annoyed me that it was hard to figure out what went wrong when it failed. For example, it didn‚Äôt work if you compared c to a variable that held the null value, only the literal null. But the syntax was easy to remember and usually did the right thing.</p>
<p>These checks dynamically branch to a different piece of logic if the value is indeed null. Often you‚Äôd want to simply assert that the value is non-null and abandon otherwise. There was an explicit type-assertion operator to do that:</p>
<p>Customer? maybeCustomer = customers[id];
Customer customer = notnull(maybeCustomer);</p>
<p>The notnull operator turned any expression of type T? into an expression of type T.
Generics</p>
<p>Generics are hard, because there are multiple levels of nullability to consider. Consider:</p>
<p>class C {
public T M<T>();
public T? N<T>();
}</p>
<p>var a = C.M<object>();
var b = C.M&lt;object?&gt;();
var c = C.N<object>();
var d = C.N&lt;object?&gt;();</p>
<p>The basic question is, what are the types of a, b, c, and d?</p>
<p>I think we made this one harder initially than we needed to largely because C#‚Äôs existing nullable is a pretty odd duck and we got distracted trying to mimic it too much. The good news is we finally found our way, but it took a while.</p>
<p>To illustrate what I mean, let‚Äôs go back to the example. There are two camps:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">The .NET camp: a is object; b, c, and d are object?.
</span><span style="color:#c0c5ce;">The functional language camp: a is object; b and c are object?; d is object??.
</span></pre>
<p>In other words, the .NET camp thinks you should collapse any sequence of 1 or more ?s into a single ?. The functional language camp ‚Äì who understands the elegance of mathematical composition ‚Äì eschews the magic and lets the world be as it is. We eventually realized that the .NET route is incredibly complex, and requires runtime support.</p>
<p>The functional language route does bend your mind slightly at first. For example, the map example from earlier:</p>
<p>Map&lt;int, Customer?&gt; customers = ...;
Customer?? customer = customers[id];
if (customer != null) {
// Notice, <code>customer</code> is still <code>Customer?</code> in here, and could still be <code>null</code>!
}</p>
<p>In this model, you need to peel off one layer of ? at a time. But honestly, when you stop to think about it, that makes sense. It‚Äôs more transparent and reflects precisely what‚Äôs going on under here. Best not to fight it.</p>
<p>There‚Äôs also the question of implementation. The easiest implementation is to expand T? into some ‚Äúwrapper type,‚Äù like Maybe<T>, and then inject the appropriate wrap and unwrap operations. Indeed, that‚Äôs a reasonable mental model for how the implementation works. There are two reasons this simple model doesn‚Äôt work, however.</p>
<p>First, for reference type T, T? must not carry a wasteful extra bit; a pointer‚Äôs runtime representation can carry null as a value already, and for a systems language, we‚Äôd like to exploit this fact and store T? as efficiently as T. This can be done fairly easily by specializing the generic instantiation. But this does mean that non-null can no longer simply be a front-end trick. It requires back-end compiler support.</p>
<p>(Note that this trick is not so easy to extend to T??!)</p>
<p>Second, Midori supported safe covariant arrays, thanks to our mutability annotations. If T and T? have a different physical representation, however, then converting T[] to T?[] is a non-transforming operation. This was a minor blemish, particularly since covariant arrays become far less useful once you plug the safety holes they already have.</p>
<p>Anyway, we eventually burned the ships on .NET Nullable<T> and went with the more composable multi-? design.
Zero-Initialization</p>
<p>Zero-initialization is a real pain in the butt. To tame it meant:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">All non-null fields of a class must be initialized at construction time.
</span><span style="color:#c0c5ce;">All arrays of non-null elements must be fully initialized at construction time.
</span></pre>
<p>But it gets worse. In .NET, value types are implicitly zero-initialized. The initial rule was therefore:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">All fields of a struct must be nullable.
</span></pre>
<p>But that stunk. It infected the whole system with nullable types immediately. My hypothesis was that nullability only truly works if nullable is the uncommon (say 20%) case. This would have destroyed that in an instant.</p>
<p>So we went down the path of eliminating automatic zero-initialization semantics. This was quite a large change. (C# 6 went down the path of allowing structs to provide their own zero-arguments constructors and eventually had to back it out due to the sheer impact this had on the ecosystem.) It could have been made to work but veered pretty far off course, and raised some other problems that we probably got too distracted with. If I could do it all over again, I‚Äôd just eliminate the value vs. reference type distinction altogether in C#. The rationale for that‚Äôll become clearer in an upcoming post on battling the garbage collector.
The Fate of Non-Null Types</p>
<p>We had a solid design, and several prototypes, but never deployed this one across the entire operating system. The reason why was tied up in our desired level of C# compatibility. To be fair, I waffled on this one quite a bit, and I suppose it was ultimately my decision. In the early days of Midori, we wanted ‚Äúcognitive familiarity.‚Äù In the later days of the project, we actually considered whether all of the features could be done as ‚Äúadd on‚Äù extensions to C#. It was that later mindset that prevented us from doing non-null types in earnest. My belief to this day is that additive annotations just won‚Äôt work; Spec# tried this with ! and the polarity always felt inverted. Non-null needs to be the default for this to have the impact we desired.</p>
<p>One of my biggest regrets is that we waited so long on non-null types. We only explored it in earnest once contracts were a known quantity, and we noticed the thousands of requires x != nulls all over the place. It would have been complex and expensive, however this would have been a particularly killer combination if we nuked the value type distinction at the same time. Live and learn!</p>
<p>If we shipped our language as a standalone thing, different from C# proper, I‚Äôm convinced this would have made the cut.
Range Types</p>
<p>We had a design for adding range types to C#, but it always remained one step beyond my complexity limit.</p>
<p>The basic idea is that any numeric type can be given a lower and upper bound type parameter. For example, say you had an integer that could only hold the numbers 0 through 1,000,000, exclusively. It could be stated as int&lt;0..1000000&gt;. Of course, this points out that you probably should be using a uint instead and the compiler would warn you. In fact, the full set of numbers could be conceptually represented as ranges in this way:</p>
<p>typedef byte number&lt;0..256&gt;;
typedef sbyte number&lt;-128..128&gt;;
typedef short number&lt;-32768..32768&gt;;
typedef ushort number&lt;0..65536&gt;;
typedef int number&lt;-2147483648..2147483648&gt;;
typedef uint number&lt;0..4294967295&gt;;
// And so on ...</p>
<p>The really ‚Äúcool‚Äù ‚Äì but scary complicated ‚Äì part is to then use dependent types to permit symbolic range parameters. For example, say I have an array and want to pass an index whose range is guaranteed to be in-bounds. Normally I‚Äôd write:</p>
<p>T Get(T[] array, int index)
requires index &gt;= 0 &amp;&amp; index &lt; array.Length {
return array[index];
}</p>
<p>Or maybe I‚Äôd use a uint to eliminate the first half of the check:</p>
<p>T Get(T[] array, uint index)
index &lt; array.Length {
return array[index];
}</p>
<p>Given range types, I can instead associate the upper bound of the number‚Äôs range with the array length directly:</p>
<p>T Get(T[] array, number&lt;0, array.Length&gt; index) {
return array[index];
}</p>
<p>Of course, there‚Äôs no guarantee the compiler will eliminate the bounds check, if you somehow trip up its alias analysis. But we would hope that it does no worse a job with these types than with normal contracts checks. And admittedly this approach is a more direct encoding of information in the type system.</p>
<p>Anyway, I still chalk this one up to a cool idea, but one that‚Äôs still in the realm of ‚Äúnice to have but not critical.‚Äù</p>
<p>The ‚Äúnot critical‚Äù aspect is especially true thanks to slices being first class in the type system. I‚Äôd say 66% or more of the situations where range checks were used would have been better written using slices. I think mainly people were still getting used to having them and so they‚Äôd write the standard C# thing rather than just using a slice. I‚Äôll cover slices in an upcoming post, but they removed the need for writing range checks altogether in most code.
Recoverable Errors: Type-Directed Exceptions</p>
<p>Abandonment isn‚Äôt the only story, of course. There are still plenty of legitimate situations where an error the programmer can reasonably recover from occurs. Examples include:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">File I/O.
</span><span style="color:#c0c5ce;">Network I/O.
</span><span style="color:#c0c5ce;">Parsing data (e.g., a compiler parser).
</span><span style="color:#c0c5ce;">Validating user data (e.g., a web form submission).
</span></pre>
<p>In each of these cases, you usually don‚Äôt want to trigger abandonment upon encountering a problem. Instead, the program expects it to occur from time to time, and needs to deal with it by doing something reasonable. Often by communicating it to someone: the user typing into a webpage, the administrator of the system, the developer using a tool, etc. Of course, abandonment is one method call away if that‚Äôs the most appropriate action to take, but it‚Äôs often too drastic for these situations. And, especially for IO, it runs the risk of making the system very brittle. Imagine if the program you‚Äôre using decided to wink out of existence every time your network connection dropped a packet!
Enter Exceptions</p>
<p>We used exceptions for recoverable errors. Not the unchecked kind, and not quite the Java checked kind, either.</p>
<p>First thing‚Äôs first: although Midori had exceptions, a method that wasn‚Äôt annotated as throws could never throw one. Never ever ever. There were no sneaky RuntimeExceptions like in Java, for instance. We didn‚Äôt need them anyway, because the same situations Java used runtime exceptions for were instead using abandonment in Midori.</p>
<p>This led to a magical property of the result system. 90-something% of the functions in our system could not throw exceptions! By default, in fact, they could not. This was a stark contrast to systems like C++ where you must go out of your way to abstain from exceptions and state that fact using noexcept. APIs could still fail due to abandonment, of course, but only when callers fail meet the stated contract, similar to passing an argument of the wrong type.</p>
<p>Our choice of exceptions was controversial at the outset. We had a mixture of imperative, procedural, object oriented, and functional language perspective on the team. The C programmers wanted to use error codes and were worried we would recreate the Java, or worse, C# design. The functional perspective would be to use dataflow for all errors, but exceptions were very control-flow-oriented. In the end, I think what we chose was a nice compromise between all of the available recoverable error models available to us. As we‚Äôll see later, we did offer a mechanism for treating errors as first class values for that rare case where a more dataflow style of programming was what the developer wanted.</p>
<p>Most importantly, however, we wrote a lot of code in this model, and it worked very well for us. Even the functional language guys came around eventually. As did the C programmers, thanks to some cues we took from return codes.
Language and Type System</p>
<p>At some point, I made a controversial observation and decision. Just as you wouldn‚Äôt change a function‚Äôs return type with the expectation of zero compatibility impact, you should not be changing a function‚Äôs exception type with such an expectation. In other words, an exception, as with error codes, is just a different kind of return value!</p>
<p>This has been one of the parroted arguments against checked exceptions. My answer may sound trite, but it‚Äôs simple: too bad. You‚Äôre in a statically typed programming language, and the dynamic nature of exceptions is precisely the reason they suck. We sought to address these very problems, so therefore we embraced it, embellished strong typing, and never looked back. This alone helped to bridge the gap between error codes and exceptions.</p>
<p>Exceptions thrown by a function became part of its signature, just as parameters and return values are. Remember, due to the rare nature of exceptions compared to abandonment, this wasn‚Äôt as painful as you might think. And a lot of intuitive properties flowed naturally from this decision.</p>
<p>The first thing is the Liskov substitution principle. In order to avoid the mess that C++ found itself in, all ‚Äúchecking‚Äù has to happen statically, at compile time. As a result, all of those performance problems mentioned in the WG21 paper were not problems for us. This type system must be bulletproof, however, with no backdoors to defeat it. Because we needed to address those performance challenges by depending on throws annotations in our optimizing compiler, type safety hinged on this property.</p>
<p>We tried many many different syntaxes. Before we committed to changing the language, we did everything with C# attributes and static analysis. The user experience wasn‚Äôt very good and it‚Äôs hard to do a real type system that way. Furthermore, it felt too bolted on. We experimented with approaches from the Redhawk project ‚Äì what eventually became .NET Native and CoreRT ‚Äì however, that approach also didn‚Äôt leverage the language and relied instead on static analysis, though it shares many similar principles with our final solution.</p>
<p>The basic gist of the final syntax was to simply state a method throws as a single bit:</p>
<p>void Foo() throws {
...
}</p>
<p>(For many years, we actually put the throws at the beginning of the method, but that read wrong.)</p>
<p>At this point, the issue of substitutability is quite simple. A throws function cannot take the place of a non- throws function (illegal strengthening). A non-throws function, on the other hand, can take the place of a throws function (legal weakening). This obviously impacts virtual overrides, interface implementation, and lambdas.</p>
<p>Of course, we did the expected co- and contravariance substitution bells and whistles. For example, if Foo were virtual and you overrode it but didn‚Äôt throw exceptions, you didn‚Äôt need to state the throws contract. Anybody invoking such a function virtually, of course, couldn‚Äôt leverage this but direct calls could.</p>
<p>For example, this is legal:</p>
<p>class Base {
public virtual void Foo() throws {...}
}</p>
<p>class Derived : Base {
// My particular implementation doesn't need to throw:
public override void Foo() {...}
}</p>
<p>and callers of Derived could leverage the lack of throws; whereas this is wholly illegal:</p>
<p>class Base {
public virtual void Foo () {...}
}</p>
<p>class Derived : Base {
public override void Foo() throws {...}
}</p>
<p>Encouraging a single failure mode was quite liberating. A vast amount of the complexity that comes with Java‚Äôs checked exceptions evaporated immediately. If you look at most APIs that fail, they have a single failure mode anyway (once all bug failure modes are done with abandonment): IO failed, parsing failed, etc. And many recovery actions a developer tends to write don‚Äôt actually depend on the specifics of what exactly failed when, say, doing an IO. (Some do, and for those, the keeper pattern is often the better answer; more on this topic shortly.) Most of the information in modern exceptions are not actually there for programmatic use; instead, they are for diagnostics.</p>
<p>We stuck with just this ‚Äúsingle failure mode‚Äù for 2-3 years. Eventually I made the controversial decision to support multiple failure modes. It wasn‚Äôt common, but the request popped up reasonably often from teammates, and the scenarios seemed legitimate and useful. It did come at the expense of type system complexity, but only in all the usual subtyping ways. And more sophisticated scenarios ‚Äì like aborts (more on that later) ‚Äì required that we do this.</p>
<p>The syntax looked like this:</p>
<p>int Foo() throws FooException, BarException {
...
}</p>
<p>In a sense, then, the single throws was a shortcut for throws Exception.</p>
<p>It was very easy to ‚Äúforget‚Äù the extra detail if you didn‚Äôt care. For example, perhaps you wanted to bind a lambda to the above Foo API, but didn‚Äôt want callers to care about FooException or BarException. That lambda must be marked throws, of course, but no more detail was necessary. This turned out to be a very common pattern: An internal system would use typed exceptions like this for internal control flow and error handling, but translate all of them into just plain throws at the public boundary of the API, where the extra detail wasn‚Äôt required.</p>
<p>All of this extra typing added great power to recoverable errors. But if contracts outnumbered exceptions by 10:1, then simple throws exceptional methods outnumbered multi-failure-mode ones by another 10:1.</p>
<p>At this point, you may be wondering, what differentiated this from Java‚Äôs checked exceptions?</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">The fact that the lion‚Äôs share of errors were expressed using abandonment meant most APIs didn‚Äôt throw.

</span><span style="color:#c0c5ce;">The fact that we encouraged a single mode of failure simplified the entire system greatly. Moreover, we made it easy to go from the world of multiple modes, to just a single and back again.
</span></pre>
<p>The rich type system support around weakening and strengthening also helped, as did something else we did to that helped bridge the gap between return codes and exceptions, improved code maintainability, and more ‚Ä¶
Easily Auditable Callsites</p>
<p>At this point in the story, we still haven‚Äôt achieved the full explicit syntax of error codes. The declarations of functions say whether they can fail (good), but callers of those functions still inherit silent control flow (bad).</p>
<p>This brings about something I always loved about our exceptions model. A callsite needs to say try:</p>
<p>int value = try Foo();</p>
<p>This invokes the function Foo, propagates its error if one occurs, and assigns the return value to value otherwise.</p>
<p>This has a wonderful property: all control flow remains explicit in the program. You can think of try as a kind of conditional return (or conditional throw if you prefer). I freaking loved how much easier this made code reviewing error logic! For example, imagine a long function with a few trys inside of it; having the explicit annotation made the points of failure, and therefore control flow, as easy to pick out as return statements:</p>
<p>void doSomething() throws {
blah();
var x = blah_blah(blah());
var y = try blah(); // &lt;-- ah, hah! something that can fail!
blahdiblahdiblahdiblahdi();
blahblahblahblah(try blahblah()); // &lt;-- another one!
and_so_on(...);
}</p>
<p>If you have syntax highlighting in your editor, so the trys are bold and blue, it‚Äôs even better.</p>
<p>This delivered many of the strong benefits of return codes, but without all the baggage.</p>
<p>(Both Rust and Swift now support a similar syntax. I have to admit I‚Äôm sad we didn‚Äôt ship this to the general public years ago. Their implementations are very different, however consider this a huge vote of confidence in their syntax.)</p>
<p>Of course, if you are trying a function that throws like this, there are two possibilities:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">The exception escapes the calling function.
</span><span style="color:#c0c5ce;">There is a surrounding try/catch block that handles the error.
</span></pre>
<p>In the first case, you are required to declare that your function throws too. It is up to you whether to propagate strong typing information should the callee declare it, or simply leverage the single throws bit, of course.</p>
<p>In the second case, we of course understood all the typing information. As a result, if you tried to catch something that wasn‚Äôt declared as being thrown, we could give you an error about dead code. This was yet another controversial departure from classical exceptions systems. It always bugged me that catch (FooException) is essentially hiding a dynamic type test. Would you silently permit someone to call an API that returns just object and automatically assign that returned value to a typed variable? Hell no! So we didn‚Äôt let you do that with exceptions either.</p>
<p>Here too CLU influenced us. Liskov talks about this in A History of CLU:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">CLU‚Äôs mechanism is unusual in its treatment of unhandled exceptions. Most mechanisms pass these through: if the caller does not handle an exception raised by a called procedure, the exception is propagated to its caller, and so on. We rejected this approach because it did not fit our ideas about modular program construction. We wanted to be able to call a procedure knowing just its specification, not its implementation. However, if exceptions are propagated automatically, a procedure may raise an exception not described in its specification.
</span></pre>
<p>Although we discouraged wide try blocks, this was conceptually a shortcut for propagating an error code. To see what I mean, consider what you‚Äôd do in a system with error codes. In Go, you might say the following:</p>
<p>if err := doSomething(); err != nil {
return err
}</p>
<p>In our system, you say:</p>
<p>try doSomething();</p>
<p>But we used exceptions, you might say! It‚Äôs completely different! Sure, the runtime systems differ. But from a language ‚Äúsemantics‚Äù perspective, they are isomorphic. We encouraged people to think in terms of error codes and not the exceptions they knew and loved. This might seem funny: Why not just use return codes, you might wonder? In an upcoming section, I will describe the true isomorphism of the situation to try to convince you of our choice.
Syntactic Sugar</p>
<p>We also offered some syntactic sugar for dealing with errors. The try/catch block scoping construct is a bit verbose, especially if you‚Äôre following our intended best practices of handling errors as locally as possible. It also still retains a bit of that unfortunate goto feel for some, especially if you are thinking in terms of return codes. That gave way to a type we called Result<T>, which was simply either a T value or an Exception.</p>
<p>This essentially bridged from the world of control-flow to the world of dataflow, for scenarios in which the latter was more natural. Both certainly had their place, although most developers preferred the familiar control flow syntax.</p>
<p>To illustrate common usage, imagine you want to log all errors that occur, before repropagating the exception. Though this is a common pattern, using try/catch blocks feels a little too control flow heavy for my taste:</p>
<p>int v;
try {
v = try Foo();
// Maybe some more stuff...
}
catch (Exception e) {
Log(e);
rethrow;
}
// Use the value <code>v</code>...</p>
<p>The ‚Äúmaybe some more stuff‚Äù bit entices you to squeeze more than you should into the try block. Compare this to using Result<T>, leading to a more return-code feel and more convenient local handling:</p>
<p>Result<int> value = try Foo() else catch;
if (value.IsFailure) {
Log(value.Exception);
throw value.Exception;
}
// Use the value <code>value.Value</code>...</p>
<p>The try ... else construct also permitted you to substitute your own value instead, or even trigger abandonment, in response to failure:</p>
<p>int value1 = try Foo() else 42;
int value2 = try Foo() else Release.Fail();</p>
<p>We also supported NaN-style propagation of dataflow errors by lifting access to Ts members out of the Result<T>. For example, let‚Äôs say I have two Result<int>s and want to add them together. I can do so:</p>
<p>Result<int> x = ...;
Result<int> y = ...;
Result<int> z = x + y;</p>
<p>Notice that third line, where we added the two Result<int>s together, yielding a ‚Äì that‚Äôs right ‚Äì third Result<T>. This is the NaN-style dataflow propagation, similar to C#‚Äôs new .? feature.</p>
<p>This approach blends what I found to be an elegant mixture of exceptions, return codes, and dataflow error propagation.
Implementation</p>
<p>The model I just described doesn‚Äôt have to be implemented with exceptions. It‚Äôs abstract enough to be reasonably implemented using either exceptions or return codes. This isn‚Äôt theoretical. We actually tried it. And this is what led us to choose exceptions instead of return codes for performance reasons.</p>
<p>To illustrate how the return code implementation might work, imagine some simple transformations:</p>
<p>int foo() throws {
if (...p...) {
throw new Exception();
}
return 42;
}</p>
<p>becomes:</p>
<p>Result<int> foo() {
if (...p...) {
return new Result<int>(new Exception());
}
return new Result<int>(42);
}</p>
<p>And code like this:</p>
<p>int x = try foo();</p>
<p>becomes something more like this:</p>
<p>int x;
Result<int> tmp = foo();
if (tmp.Failed) {
throw tmp.Exception;
}
x = tmp.Value;</p>
<p>An optimizing compiler can represent this more efficiently, eliminating excessive copying. Especially with inlining.</p>
<p>If you try to model try/catch/finally this same way, probably using goto, you‚Äôll quickly see why compilers have a hard time optimizing in the presence of unchecked exceptions. All those hidden control flow edges!</p>
<p>Either way, this exercise very vividly demonstrates the drawbacks of return codes. All that goop ‚Äì which is meant to be rarely needed (assuming, of course, that failure is rare) ‚Äì is on hot paths, mucking with your program‚Äôs golden path performance. This violates one of our most important principles.</p>
<p>I described the results of our dual mode experiment in my last post. In summary, the exceptions approach was 7% smaller and 4% faster as a geomean across our key benchmarks, thanks to a few things:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">No calling convention impact.
</span><span style="color:#c0c5ce;">No peanut butter associated with wrapping return values and caller branching.
</span><span style="color:#c0c5ce;">All throwing functions were known in the type system, enabling more flexible code motion.
</span><span style="color:#c0c5ce;">All throwing functions were known in the type system, giving us novel EH optimizations, like turning try/finally blocks into straightline code when the try could not throw.
</span></pre>
<p>There were other aspects of exceptions that helped with performance. I already mentioned that we didn‚Äôt grovel the callstack gathering up metadata as most exceptions systems do. We left diagnostics to our diagnostics subsystem. Another common pattern that helped, however, was to cache exceptions as frozen objects, so that each throw didn‚Äôt require an allocation:</p>
<p>const Exception retryLayout = new Exception();
...
throw retryLayout;</p>
<p>For systems with high rates of throwing and catching ‚Äì as in our parser, FRP UI framework, and other areas ‚Äì this was important to good performance. And this demonstrates why we couldn‚Äôt simply take ‚Äúexceptions are slow‚Äù as a given.
Patterns</p>
<p>A number of useful patterns came up that we embellished in our language and libraries.
Concurrency</p>
<p>Back in 2007, I wrote this note about concurrency and exceptions. I wrote it mainly from the perspective of parallel, shared memory computations, however similar challenges exist in all concurrent orchestration patterns. The basic issue is that the way exceptions are implemented assumes single, sequential stacks, with single failure modes. In a concurrent system, you have many stacks and many failure modes, where 0, 1, or many may happen ‚Äúat once.‚Äù</p>
<p>A simple improvement that Midori made was simply ensuring all Exception-related infrastructure handled cases with multiple inner errors. At least then a programmer wasn‚Äôt forced to decide to toss away 1/N‚Äôth of the failure information, as most exceptions systems encourage today. More than that, however, our scheduling and stack crawling infrastructure fundamentally knew about cactus-style stacks, thanks to our asynchronous model, and what to do with them.</p>
<p>At first, we didn‚Äôt support exceptions across asynchronous boundaries. Eventually, however, we extended the ability to declare throws, along with optional typed exceptions clauses, across asynchronous process boundaries. This brought a rich, typed programming model to the asynchronous actors programming model and felt like a natural extension. This borrowed a page from CLU‚Äôs successor, Argus.</p>
<p>Our diagnostics infrastructure embellished this to give developers debugging experiences with full-blown cross-process causality in their stack views. Not only are stacks cactuses in a highly concurrent system, but they are often smeared across process message passing boundaries. Being able to debug the system this way was a big time-saver.
Aborts</p>
<p>Sometimes a subsystem needs to ‚Äúget the hell out of Dodge.‚Äù Abandonment is an option, but only in response to bugs. And of course nobody in the process can stop it in its tracks. What if we want to back out the callstack to some point, know that no-one on the stack is going to stop us, but then recover and keep going within the same process?</p>
<p>Exceptions were close to what we wanted here. But unfortunately, code on the stack can catch an in-flight exception, thereby effectively suppressing the abort. We wanted something unsuppressable.</p>
<p>Enter aborts. We invented aborts mainly in support of our UI framework which used Functional Reactive Programming (FRP), although the pattern came up in a few spots. As an FRP recalculation was happening, it‚Äôs possible that events would enter the system, or new discoveries got made, that invalidate the current recalculation. If that happened ‚Äì typically deep within some calculation whose stack was an interleaving of user and system code ‚Äì the FRP engine needed to quickly get back to top of its stack where it could safely begin a recalculation. Thanks to all of that user code on the stack being functionally pure, aborting it mid-stream was easy. No errant side-effects would be left behind. And all engine code that was traversed was audited and hardened thoroughly, thanks to typed exceptions, to ensure invariants were maintained.</p>
<p>The abort design borrows a page from the capability playbook. First, we introduce a base type called AbortException. It may be used directly or subclassed. One of these is special: nobody can catch-and-ignore it. The exception is reraised automatically at the end of any catch block that attempts to catch it. We say that such exceptions are undeniable.</p>
<p>But someone‚Äôs got to catch an abort. The whole idea is to exit a context, not tear down the entire process a la abandonment. And here‚Äôs where capabilities enter the picture. Here‚Äôs the basic shape of AbortException:</p>
<p>public immutable class AbortException : Exception {
public AbortException(immutable object token);
public void Reset(immutable object token);
// Other uninteresting members omitted...
}</p>
<p>Notice that, at the time of construction, an immutable token is provided; in order to suppress the throw, Reset is called, and a matching token must be provided. If the token doesn‚Äôt match, abandonment occurs. The idea is that the throwing and intended catching parties of an abort are usually the same, or at least in cahoots with one another, such that sharing the token securely with one another is easy to do. This is a great example of objects as unforgeable capabilities in action.</p>
<p>And yes, an arbitrary piece of code on the stack can trigger an abandonment, but such code could already do that by simply dereferencing null. This technique prohibits executing in the aborting context when it might not have been ready for it.</p>
<p>Other frameworks have similar patterns. The .NET Framework has ThreadAbortException which is also undeniable unless you invoke Thread.ResetAbort; sadly, because it isn‚Äôt capability-based, a clumsy combination of security annotations and hosting APIs are required to stop unintended swallowing of aborts. More often, this goes unchecked.</p>
<p>Thanks to exceptions being immutable, and the token above being immutable, a common pattern was to cache these guys in static variables and use singletons. For example:</p>
<p>class MyComponent {
const object abortToken = new object();
const AbortException abortException = new AbortException(abortToken);</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">void Abort() throws AbortException {
</span><span style="color:#c0c5ce;">    throw abortException;
</span><span style="color:#c0c5ce;">}

</span><span style="color:#c0c5ce;">void TopOfTheStack() {
</span><span style="color:#c0c5ce;">    while (true) {
</span><span style="color:#c0c5ce;">        // Do something that calls deep into some callstacks;
</span><span style="color:#c0c5ce;">        // deep down it might Abort, which we catch and reset:
</span><span style="color:#c0c5ce;">        let result = try ... else catch&lt;AbortException&gt;;
</span><span style="color:#c0c5ce;">        if (result.IsFailed) {
</span><span style="color:#c0c5ce;">            result.Exception.Reset(abortToken);
</span><span style="color:#c0c5ce;">        }
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>}</p>
<p>This pattern made aborts very efficient. An average FRP recalculation aborted multiple times. Remember, FRP was the backbone of all UI in the system, so the slowness often attributed to exceptions was clearly not acceptable. Even allocating an exception object would have been unfortunate, due to the ensuing GC pressure.
Opt-in ‚ÄúTry‚Äù APIs</p>
<p>I mentioned a number of operations that abandoned upon failure. That included allocating memory, performing arithmetic operations that overflowed or divided-by-zero, etc. In a few of these instances, a fraction of the uses are appropriate for dynamic error propagation and recovery, rather than abandonment. Even if abandonment is better in the common case.</p>
<p>This turned out to be a pattern. Not terribly common, but it came up. As a result, we had a whole set of arithmetic APIs that used a dataflow-style of propagation should overflow, NaN, or any number of things happen.</p>
<p>I also already mentioned a concrete instance of this earlier, which is the ability to try new an allocation, when OOM yields a recoverable error rather than abandonment. This was super uncommon, but could crop up if you wanted to, say, allocate a large buffer for some multimedia operation.
Keepers</p>
<p>The last pattern I‚Äôll cover is called the keeper pattern.</p>
<p>In a lot of ways, the way recoverable exceptions are handled is ‚Äúinside out.‚Äù A bunch of code is called, passing arguments down the callstack, until finally some code is reached that deems that state unacceptable. In the exceptions model, control flow is then propagated back up the callstack, unwinding it, until some code is found that handles the error. At that point if the operation is to be retried, the sequence of calls must be reissued, etc.</p>
<p>An alternative pattern is to use a keeper. The keeper is an object that understands how to recover from errors ‚Äúin situ,‚Äù so that the callstack needn‚Äôt be unwound. Instead, the code that would have otherwise thrown an exception consults the keeper, who instructs the code how to proceed. A nice aspect of keepers is that often, when done as a configured capability, surrounding code doesn‚Äôt even need to know they exist ‚Äì unlike exceptions which, in our system, had to be declared as part of the type system. Another aspect of keepers is that they are simple and cheap.</p>
<p>Keepers in Midori could be used for prompt operations, but more often spanned asynchronous boundaries.</p>
<p>The canonical example of a keeper is one guarding filesystem operations. Accessing files and directories on a file system typically has failure modes such as:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Invalid path specification.
</span><span style="color:#c0c5ce;">File not found.
</span><span style="color:#c0c5ce;">Directory not found.
</span><span style="color:#c0c5ce;">File in use.
</span><span style="color:#c0c5ce;">Insufficient privileges.
</span><span style="color:#c0c5ce;">Media full.
</span><span style="color:#c0c5ce;">Media write-protected.
</span></pre>
<p>One option is to annotate each filesystem API with a throws clause for each. Or, like Java, to create an IOException hierarchy with each of these as subclasses. An alternative is to use a keeper. This ensures the overall application doesn‚Äôt need to know or care about IO errors, permitting recovery logic to be centralized. Such a keeper interface might look like this:</p>
<p>async interface IFileSystemKeeper {
async string InvalidPathSpecification(string path) throws;
async string FileNotFound(string path) throws;
async string DirectoryNotFound(string path) throws;
async string FileInUse(string path) throws;
async Credentials InsufficientPrivileges(Credentials creds, string path) throws;
async string MediaFull(string path) throws;
async string MediaWriteProtected(string path) throws;
}</p>
<p>The idea is that, in each case, the relevant inputs are provided to the keeper when failure occurs. The keeper is then permitted to perform an operation, possibly asynchronous, to recover. In many cases, the keeper can optionally return updated arguments for the operation. For example, InsufficientPrivileges could return alternative Credentials to use. (Maybe the program prompted the user and she switched to an account with write access.) In each case shown, the keeper could throw an exception if it didn‚Äôt want to handle the error, although this part of the pattern was optional.</p>
<p>Finally, I should note that Windows‚Äôs Structured Exception Handling (SEH) system supports ‚Äúcontinuable‚Äù exceptions which are conceptually attempting to achieve this same thing. They let some code decide how to restart the faulting computation. Unfortunately, they‚Äôre done using ambient handlers on the callstack, rather than first class objects in the language, and so are far less elegant ‚Äì and significantly more error prone ‚Äì than the keepers pattern.
Future Directions: Effect Typing</p>
<p>Most people asked us about whether having async and throws as type system attributes bifurcated the entire universe of libraries. The answer was ‚ÄúNo, not really.‚Äù But it sure was painful in highly polymorphic library code.</p>
<p>The most jarring example was combinators like map, filter, sort, etc. In those cases, you often have arbitrary functions and want the async and throws attributes of those functions to ‚Äúflow through‚Äù transparently.</p>
<p>The design we had to solve this was to let you parameterize over effects. For instance, here is a universal mapping function, Map, that propagates the async or throws effect of its func parameter:</p>
<p>U[] Map&lt;T, U, effect E&gt;(T[] ts, Func&lt;T, U, E&gt; func) E {
U[] us = new U[ts.Length];
for (int i = 0; i &lt; ts.Length; i++) {
us[i] = effect(E) func(ts[i]);
}
return us;
}</p>
<p>Notice here that we‚Äôve got an ordinary generic type, E, except that its declaration is prefixed by the keyword effect. We then use E symbolically in place of the effects list of the Map signature, in addition to using it in the ‚Äúpropagate‚Äù position via effect(E) when invoking func. It‚Äôs a pretty trivial exercise in substitution, replacing E with throws and effect(E) with try, to see the logical transformation.</p>
<p>A legal invocation might be:</p>
<p>int[] xs = ...;
string[] ys = try Map&lt;int, string, throws&gt;(xs, x =&gt; ...);</p>
<p>Notice here that the throws flows through, so that we can pass a callback that throws exceptions.</p>
<p>As a total aside, we discussed taking this further, and allowing programmers to declare arbitrary effects. I‚Äôve hypothesized about such a type system previously. We were concerned, however, that this sort of higher order programming might be gratuitously clever and hard to understand, no matter how powerful. The simple model above probably would‚Äôve been a sweet spot and I think we‚Äôd have done it given a few more months.
Retrospective and Conclusions</p>
<p>We‚Äôve reached the end of this particular journey. As I said at the outset, a relatively predictable and tame outcome. But I hope all that background helped to take you through the evolution as we sorted through the landscape of errors.</p>
<p>In summary, the final model featured:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">An architecture that assumed fine-grained isolation and recoverability from failure.
</span><span style="color:#c0c5ce;">Distinguishing between bugs and recoverable errors.
</span><span style="color:#c0c5ce;">Using contracts, assertions, and, in general, abandonment for all bugs.
</span><span style="color:#c0c5ce;">Using a slimmed down checked exceptions model for recoverable errors, with a rich type system and language syntax.
</span><span style="color:#c0c5ce;">Adopting some limited aspects of return codes ‚Äì like local checking ‚Äì that improved reliability.
</span></pre>
<p>And, though this was a multi-year journey, there were areas of improvement we were actively working on right up until our project‚Äôs untimely demise. I classified them differently because we didn‚Äôt have enough experience using them to claim success. I would have hoped we‚Äôd have tidied up most of them and shipped them if we ever got that far. In particular, I‚Äôd have liked to put this one into the final model category:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Leveraging non-null types by default to eliminate a large class of nullability annotations.
</span></pre>
<p>Abandonment, and the degree to which we used it, was in my opinion our biggest and most successful bet with the Error Model. We found bugs early and often, where they are easiest to diagnose and fix. Abandonment-based errors outnumbered recoverable errors by a ratio approaching 10:1, making checked exceptions rare and tolerable to the developer.</p>
<p>Although we never had a chance to ship this, we have since brought some of these lessons learned to other settings.</p>
<p>During the Microsoft Edge browser rewrite from Internet Explorer, for example, we adopted abandonment in a few areas. The key one, applied by a Midori engineer, was OOM. The old code would attempt to limp along as I described earlier and almost always did the wrong thing. My understanding is that abandonment has found numerous lurking bugs, as was our experience regularly in Midori when porting existing codebases. The great thing too is that abandonment is more of an architectural discipline that can be adopted in existing code-bases ranging in programming languages.</p>
<p>The architectural foundation of fine-grained isolation is critical, however many systems have an informal notion of this architecture. A reason why OOM abandonment works well in a browser is that most browsers devote separate processes to individual tabs already. Browsers mimic operating systems in many ways and here too we see this playing out.</p>
<p>More recently, we‚Äôve been exploring proposals to bring some of this discipline ‚Äì including contracts ‚Äì to C++. There are also concrete proposals to bring some of these features to C# too. We are actively iterating on a proposal that would bring some non-null checking to C#. I have to admit, I wish all of those proposals the best, however nothing will be as bulletproof as an entire stack written in the same error discipline. And remember, the entire isolation and concurrency model is essential for abandonment at scale.</p>
<p>I am hopeful that continued sharing of knowledge will lead to even more wide-scale adoption some of these ideas.</p>
<p>And, of course, I‚Äôve mentioned that Go, Rust, and Swift have given the world some very good systems-appropriate error models in the meantime. I might have some minor nits here and there, but the reality is that they‚Äôre worlds beyond what we had in the industry at the time we began the Midori journey. It‚Äôs a good time to be a systems programmer!</p>
<p>Next time I‚Äôll talk more about the language. Specifically, we‚Äôll see how Midori was able to tame the garbage collector using a magical elixir of architecture, language support, and libraries. I hope to see you again soon!</p>
<h4 id="performance-culture">Performance culture<a class="zola-anchor" href="#performance-culture" aria-label="Anchor link for: performance-culture">üîó</a>
</h4>
<p><a href="http://joeduffyblog.com/2016/04/10/performance-culture/">source</a></p>
<p>In this essay, I‚Äôll talk about ‚Äúperformance culture.‚Äù Performance is one of the key pillars of software engineering, and is something that‚Äôs hard to do right, and sometimes even difficult to recognize. As a famous judge once said, ‚ÄúI know it when I see it.‚Äù I‚Äôve spoken at length about performance and culture independently before, however the intersection of the two is where things get interesting. Teams who do this well have performance ingrained into nearly all aspects of how the team operates from the start, and are able to proactively deliver loveable customer experiences that crush the competition. There‚Äôs no easy cookie-cutter recipe for achieving a good performance culture, however there are certainly some best practices you can follow to plant the requisite seeds into your team. So, let‚Äôs go!
Introduction</p>
<p>Why the big focus on performance, anyway?</p>
<p>Partly it‚Äôs my background. I‚Äôve worked on systems, runtimes, compilers, ‚Ä¶ things that customers expect to be fast. It‚Äôs always much easier to incorporate goals, metrics, and team processes at the outset of such a project, compared to attempting to recover it later on. I‚Äôve also worked on many teams, some that have done amazing at this, some that have done terribly, and many in between. The one universal truth is that the differentiating factor is always culture.</p>
<p>Partly it‚Äôs because, no matter the kind of software, performance is almost always worse than our customers would like it to be. This is a simple matter of physics: it‚Äôs impossible to speed up all aspects of a program, given finite time, and the tradeoffs involved between size, speed, and functionality. But I firmly believe that on the average teams spend way less attention to developing a rigorous performance culture. I‚Äôve heard the ‚Äúperformance isn‚Äôt a top priority for us‚Äù statement many times only to later be canceled out by a painful realization that without it the product won‚Äôt succeed.</p>
<p>And partly it‚Äôs just been top of mind for all of us in DevDiv, as we focus on .NET core performance, ASP.NET scalability, integrating performance-motivated features into C# and the libraries, making Visual Studio faster, and more. It‚Äôs particularly top of mind for me, as I‚Äôve been comparing our experiences to my own in Midori (which heavily inspired this blog post).
Diagnosis and The Cure</p>
<p>How can you tell whether your performance culture is on track? Well, here are some signs that it‚Äôs not:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Answering the question, ‚Äúhow is the product doing on my key performance metrics,‚Äù is difficult.
</span><span style="color:#c0c5ce;">Performance often regresses and team members either don‚Äôt know, don‚Äôt care, or find out too late to act.
</span><span style="color:#c0c5ce;">Blame is one of the most common responses to performance problems (either people, infrastructure, or both).
</span><span style="color:#c0c5ce;">Performance tests swing wildly, cannot be trusted, and are generally ignored by most of the team.
</span><span style="color:#c0c5ce;">Performance is something one, or a few, individuals are meant to keep an eye on, instead of the whole team.
</span><span style="color:#c0c5ce;">Performance issues in production are common, and require ugly scrambles to address (and/or cannot be reproduced).
</span></pre>
<p>These may sound like technical problems. It may come as a surprise, however, that they are primarily human problems.</p>
<p>The solution isn‚Äôt easy, especially once your culture is in the weeds. It‚Äôs always easier to not dig a hole in the first place than it is to climb out of one later on. But the first rule when you‚Äôre in a hole is to stop digging! The cultural transformation must start from the top ‚Äì management taking an active role in performance, asking questions, seeking insights, demanding rigor ‚Äì while it simultaneously comes from the bottom ‚Äì engineers actively seeking to understand performance of the code they are writing, ruthlessly taking a zero-tolerance stance on regressions, and being ever-self-critical and on the lookout for proactive improvements.</p>
<p>This essay will describe some ways to ensure this sort of a culture, in addition to some best practices I‚Äôve found help to increase its effectiveness once you have one in place. A lot of it may seem obvious, but believe me, it‚Äôs pretty rare to see everything in here working in harmony in practice. But when it is, wow, what a difference it can make.</p>
<p>A quick note on OSS software. I wrote this essay from the perspective of commercial software development. As such, you‚Äôll see the word ‚Äúmanagement‚Äù a lot. Many of the same principles work in OSS too. So, if you like, anytime you see ‚Äúmanagement,‚Äù mentally transform it into ‚Äúmanagement or the project‚Äôs committers.‚Äù
It Starts, and Ends, with Culture</p>
<p>The key components of a healthy performance culture are:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Performance is part of the daily dialogue and ‚Äúbuzz‚Äù within the team. Everybody plays a role.
</span><span style="color:#c0c5ce;">Management must care ‚Äì truly, not superficially ‚Äì about good performance, and understand what it takes.
</span><span style="color:#c0c5ce;">Engineers take a scientific, data-driven, inquisitive approach to performance. (Measure, measure, measure!)
</span><span style="color:#c0c5ce;">Robust engineering systems are in place to track goals, past and present performance, and to block regressions.
</span></pre>
<p>I‚Äôll spend a bit of time talking about each of these roughly in turn.
Dialogue, Buzz, and Communication</p>
<p>The entire team needs to be on the hook for performance.</p>
<p>In many teams where I‚Äôve seen this go wrong, a single person is anointed the go-to performance guy or gal. Now, that‚Äôs fine and can help the team scale, can be useful when someone needs to spearhead an investigation, and having a vocal advocate of performance is great, but it must not come at the expense of the rest of the team‚Äôs involvement.</p>
<p>This can lead to problems similar to those Microsoft use to have with the ‚Äútest‚Äù discipline; engineers learned bad habits by outsourcing the basic quality of their code, assuming that someone else would catch any problems that arise. The same risks are present when there‚Äôs a central performance czar: engineers on the team won‚Äôt write performance tests, won‚Äôt proactively benchmark, won‚Äôt profile, won‚Äôt ask questions about the competitive standing of the product, and generally won‚Äôt do all the things you need all of the engineers doing to build a healthy performance culture.</p>
<p>Magical things happen when the whole team is obsessed about performance. The hallways are abuzz with excitement, as news of challenges and improvements spreads organically. ‚ÄúDid you see Martin‚Äôs hashtable rebalancing change that reduced process footprint by 30%?‚Äù ‚ÄúJared just checked in a feature that lets you stack allocate arrays. I was thinking of hacking the networking stack this weekend to use it ‚Äì care to join in?‚Äù Impromptu whiteboard sessions, off-the-cuff ideation, group learning. It‚Äôs really awesome to see. The excitement and desire to win propels the team forward, naturally, and without relying on some heavyweight management ‚Äústick.‚Äù</p>
<p>I hate blame and I hate defensiveness. My number one rule is ‚Äúno jerks,‚Äù so naturally all critiques must be delivered in the most constructive and respectful way. I‚Äôve found a high occurrence of blame, defensiveness, and intellectual dishonesty in teams that do poorly on performance, however. Like jerks, these are toxic to team culture and must be weeded out aggressively. It can easily make or break your ability to develop the right performance culture. There‚Äôs nothing wrong with saying we need to do better on some key metric, especially if you have some good ideas on how to do so!</p>
<p>In addition to the ad-hoc communication, there of course needs to be structured communication also. I‚Äôll describe some techniques later on. But getting a core group of people in a room regularly to discuss the past, present, and future of performance for a particular area of the product is essential. Although the organic conversations are powerful, everyone gets busy, and it‚Äôs important to schedule time as a reminder to keep pushing ahead.
Management: More Carrots, Fewer Sticks</p>
<p>In every team with a poor performance culture, it‚Äôs management‚Äôs fault. Period. End of conversation.</p>
<p>Engineers can and must make a difference, of course, but if the person at the top and everybody in between aren‚Äôt deeply involved, budgeting for the necessary time, and rewarding the work and the superstars, the right culture won‚Äôt take hold. A single engineer alone can‚Äôt possibly infuse enough of this culture into an entire team, and most certainly not if the entire effort is running upstream against the management team.</p>
<p>It‚Äôs painful to watch managers who don‚Äôt appreciate performance culture. They‚Äôll often get caught by surprise and won‚Äôt realize why ‚Äì or worse, think that this is just how engineering works. (‚ÄúWe can‚Äôt predict where performance will matter in advance!‚Äù) Customers will complain that the product doesn‚Äôt perform as expected in key areas and, realizing it‚Äôs too late for preventative measures, a manager whose team has a poor performance culture will start blaming things. Guess what? The blame game culture spreads like wildfire, the engineers start doing it too, and accountability goes out the window. Blame doesn‚Äôt solve anything. Blaming is what jerks do.</p>
<p>Notice I said management must be ‚Äúdeeply involved‚Äù: this isn‚Äôt some superficial level of involvement. Sure, charts with greens, reds, and trendlines probably need to be floating around, and regular reviews are important. I suppose you could say that these are pointy-haired manager things. (Believe me, however they do help.) A manager must go deeper than this, however, proactively and regularly reviewing the state of performance across the product, alongside the other basic quality metrics and progress on features. It‚Äôs a core tenet of the way the team does its work. It must be treated as such. A manager must wonder about the competitive landscape and ask the team good, insightful questions that get them thinking.</p>
<p>Performance doesn‚Äôt come for free. It costs the team by forcing them to slow down at times, to spend energy on things other than cranking out features, and hence requires some amount of intelligent tradeoff. How much really depends on the scenario. Managers need to coach the team to spend the right ratio of time. Those who assume it will come for free usually end up spending 2-5x the amount it would have taken, just at an inopportune time later on (e.g., during the endgame of shipping the product, in production when trying to scale up from 1,000 customers to 100,000, etc).</p>
<p>A mentor of mine used to say ‚ÄúYou get from your teams what you reward.‚Äù It‚Äôs especially true with performance and the engineering systems surrounding them. Consider two managers:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Manager A gives lip service to performance culture. She, however, packs every sprint schedule with a steady stream of features ‚Äì ‚Äúwe‚Äôve got to crush competitor Z and must reach feature parity!‚Äù ‚Äì with no time for breaks in-between. She spends all-hands team meetings praising new features, demos aplenty, and even gives out a reward to an engineer at each one for ‚Äúthe most groundbreaking feature.‚Äù As a result, her team cranks out features at an impressive clip, delivers fresh demos to the board every single time, and gives the sales team plenty of ammo to pursue new leads. There aren‚Äôt performance gates and engineers generally don‚Äôt bother to think much about it.

</span><span style="color:#c0c5ce;">Manager B takes a more balanced approach. She believes that given the competitive landscape, and the need to impress customers and board members with whizbang demos, new features need to keep coming. But she is also wary of building up too much debt in areas like performance, reliability, and quality for areas she expects to stick. So she intentionally puts her foot on the brake and pushes the team just as hard on these areas as she does features. She demands good engineering systems and live flighting of new features with performance telemetry built-in, for example. This requires that she hold board members and product managers at bay, which is definitely unpopular and difficult. In addition to a reward for ‚Äúthe most groundbreaking feature‚Äù award at each all-hands, she shows charts of performance progress and delivers a ‚Äúperformance ninja‚Äù award too, to the engineer who delivered the most impactful performance improvement. Note that engineering systems improvements also qualify!
</span></pre>
<p>Which manager do you think is going to ship a quality product, on time, that customers are in love with? My money is on Manager B. Sometimes you‚Äôve got to slow down to speed up.</p>
<p>Microsoft is undergoing two interesting transitions recently that are related to this point: on one hand, the elimination of ‚Äútest‚Äù as a discipline mentioned earlier; and, on the other hand, a renewed focus on engineering systems. It‚Äôs been a bumpy ride. Surprisingly, one of the biggest hurdles to get over wasn‚Äôt with the individual engineers at all ‚Äì it was the managers! ‚ÄúDevelopment managers‚Äù in the old model got used to focusing on features, features, features, and left most of the engineering systems work to contractors, and most of the quality work to testers. As a result, they were ill-prepared to recognize and reward the kind of work that is essential to building a great performance culture. The result? You guessed it: a total lack of performance culture. But, more subtly, you also ended up with ‚Äúleadership holes‚Äù; until recently, there were virtually no high-ranking engineers working on the mission-critical engineering systems that make the entire team more productive and capable. Who wants to make a career out of the mere grunt work assigned to contractors and underappreciated by management? Again, you get what you reward.</p>
<p>There‚Äôs a catch-22 with early prototyping where you don‚Äôt know if the code is going to survive at all, and so the temptation is to spend zero time on performance. If you‚Äôre hacking away towards a minimum viable product (MVP), and you‚Äôre a startup burning cash, it‚Äôs understandable. But I strongly advise against this. Architecture matters, and some poorly made architectural decisions made at the outset can lay the foundation for an entire skyscraper of ill-performing code atop. It‚Äôs better to make performance part of the feasibility study and early exploration.</p>
<p>Finally, to tie up everything above, as a manager of large teams, I think it‚Äôs important to get together regularly ‚Äì every other sprint or two ‚Äì to review performance progress with the management team. This is in addition to the more fine-grained engineer, lead, and architect level pow-wows that happen continuously. There‚Äôs a bit of a ‚Äústick‚Äù aspect of such a review, but it‚Äôs more about celebrating the team‚Äôs self-driven accomplishments, and keeping it on management‚Äôs radar. Such reviews should be driven from the lab and manually generated numbers should be outlawed.</p>
<p>Which brings me to ‚Ä¶
Process and Infrastructure</p>
<p>‚ÄúProcess and infrastructure‚Äù ‚Äì how boring!</p>
<p>Good infrastructure is a must. A team lacking the above cultural traits won‚Äôt even stop to invest in infrastructure; they will simply live with what should be an infuriating lack of rigor. And good process must ensure effective use of this infrastructure. Here is the bare minimum in my book:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">All commits must pass a set of gated performance tests beforehand.
</span><span style="color:#c0c5ce;">Any commits that slip past this and regress performance are reverted without question. I call this the zero tolerance rule.
</span><span style="color:#c0c5ce;">Continuous performance telemetry is reported from the lab, flighting, and live environments.
</span><span style="color:#c0c5ce;">This implies that performance tests and infrastructure have a few important characteristics:
</span><span style="color:#c0c5ce;">    They aren‚Äôt noisy.
</span><span style="color:#c0c5ce;">    They measure the ‚Äúright‚Äù thing.
</span><span style="color:#c0c5ce;">    They can be run in a ‚Äúreasonable‚Äù amount of time.
</span></pre>
<p>I have this saying: ‚ÄúIf it‚Äôs not automated, it‚Äôs dead to me.‚Äù</p>
<p>This highlights the importance of good infrastructure and avoids the dreaded ‚Äúit worked fine on my computer‚Äù that everybody, I‚Äôm sure, has encountered: a test run on some random machine ‚Äì under who knows what circumstances ‚Äì is quoted to declare success on a benchmark‚Ä¶ only to find out some time later that the results didn‚Äôt hold. Why is this?</p>
<p>There are countless possibilities. Perhaps a noisy process interfered, like AntiVirus, search indexing, or the application of operating system updates. Maybe the developer accidentally left music playing in the background on their multimedia player. Maybe the BIOS wasn‚Äôt properly adjusted to disable dynamic clock scaling. Perhaps it was due to an innocent data-entry error when copy-and-pasting the numbers into a spreadhseet. Or maybe the numbers for two comparison benchmarks came from two, incomparable machine configurations. I‚Äôve seen all of these happen in practice.</p>
<p>In any manual human activity, mistakes happen. These days, I literally refuse to look at or trust any number that didn‚Äôt come from the lab. The solution is to automate everything and focus your energy on making the automation infrastructure as damned good as possible. Pay some of your best people to make this rock solid for the rest of the team. Encourage everybody on the team to fix broken windows, and take a proactive approach to improving the infrastructure. And reward it heartily. You might have to go a little slower, but it‚Äôll be worth it, trust me.
Test Rings</p>
<p>I glossed over a fair bit above when I said ‚Äúall commits must pass a set of performance tests,‚Äù and then went on to talk about how a checkin might ‚Äúslip past‚Äù said tests. How is this possible?</p>
<p>The reality is that it‚Äôs usually not possible to run all tests and find all problems before a commit goes in, at least not within a reasonable amount of time. A good performance engineering system should balance the productivity of speedy codeflow with the productivity and assurance of regression prevention.</p>
<p>A decent approach for this is to organize tests into so-called ‚Äúrings‚Äù:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">An inner ring containing tests that all developers on the team measure before each commit.
</span><span style="color:#c0c5ce;">An inner ring containing tests that developers on your particular sub-team measure before each commit.
</span><span style="color:#c0c5ce;">An inner ring containing tests that developers run at their discretion before each commit.
</span><span style="color:#c0c5ce;">Any number of successive rings outside of this:
</span><span style="color:#c0c5ce;">    Gates for each code-flow point between branches.
</span><span style="color:#c0c5ce;">    Post-commit testing ‚Äì nightly, weekly, etc. ‚Äì based on time/resource constraints.
</span><span style="color:#c0c5ce;">    Pre-release verification.
</span><span style="color:#c0c5ce;">    Post-release telemetry and monitoring.
</span></pre>
<p>As you can see, there‚Äôs a bit of flexibility in how this gets structured in practice. I wish I could lie and say that it‚Äôs a science, however it‚Äôs an art that requires intelligently trading off many factors. This is a constant source of debate and one that the management team should be actively involved in.</p>
<p>A small team might settle on one standard set of benchmarks across the whole team. A larger team might need to split inner ring tests along branching lines. And no matter the size, we would expect the master/main branch to enforce the most important performance metrics for the whole team, ensuring no code ever flows in that damages a core scenario.</p>
<p>In some cases, we might leave running certain pre-commit tests to the developer‚Äôs discretion. (Note, this does not mean running pre-commit tests altogether is optional ‚Äì only a particular set of them!) This might be the case if, for example, the test covered a lesser-used component and we know the nightly tests would catch any post-commit regression. In general, when you have a strong performance culture, it‚Äôs okay to trust judgement calls sometimes. Trust but verify.</p>
<p>Let‚Äôs take a few concrete examples. Performance tests often range from micro to macro in size. These typically range from easier to harder to pinpoint the source of a regression, respectively. (Micro measures just one thing, and so fluctuations tend to be easier to understand, whereas macro measures an entire system, where fluctuations tend to take a bit of elbow grease to track down.) A web server team might include a range of micro and macro tests in the innermost pre-commit suite of tests: number of bytes allocated per requests (micro), request response time (micro), ‚Ä¶ perhaps a half dozen other micro-to-midpoint benchmarks ‚Ä¶, and TechEmpower (macro), let‚Äôs say. Thanks to lab resources, test parallelism, and the awesomeness of GitHub webhooks, let‚Äôs say these all complete in 15 minutes, nicely integrated into your pull request and code review processes. Not too bad. But this clearly isn‚Äôt perfect coverage. Maybe every night, TechEmpower is run for 4 hours, to measure performance over a longer period of time to identify leaks. It‚Äôs possible a developer could pass the pre-commit tests, and then fail this longer test, of course. Hence, the team lets developers run this test on-demand, so a good doobie can avoid getting egg on his or her face. But alas, mistakes happen, and again there isn‚Äôt a culture of blame or witchhunting; it is what it is.</p>
<p>This leads me to back to the zero tolerance rule.</p>
<p>Barring exceptional circumstances, regressions should be backed out immediately. In teams where I‚Äôve seen this succeed, there were no questions asked, and no IOUs. As soon as you relax this stance, the culture begins to break down. Layers of regressions pile on top of one another and you end up ceding ground permanently, no matter the best intentions of the team. The commit should be undone, the developer should identify the root cause, remedy it, ideally write a new test if appropriate, and then go through all the hoops again to submit the checkin, this time ensuring good performance.
Measurement, Metrics, and Statistics</p>
<p>Decent engineers intuit. Good engineers measure. Great engineers do both.</p>
<p>Measure what, though?</p>
<p>I put metrics into two distinct categories:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Consumption metrics. These directly measure the resources consumed by running a test.
</span><span style="color:#c0c5ce;">Observational metrics. These measure the outcome of running a test, observationally, using metrics ‚Äúoutside‚Äù of the system.
</span></pre>
<p>Examples of consumption metrics are hardware performance counters, such as instructions retired, data cache misses, instruction cache misses, TLB misses, and/or context switches. Software performance counters are also good candidates, like number of I/Os, memory allocated (and collected), interrupts, and/or number of syscalls. Examples of observational metrics include elapsed time and cost of running the test as billed by your cloud provider. Both are clearly important for different reasons.</p>
<p>Seeing a team measure time and time alone literally brings me to tears. It‚Äôs a good measure of what an end-user will see ‚Äì and therefore makes a good high-level test ‚Äì however it is seriously lacking in the insights it can give you. And if there‚Äôs no visibility into variance, it can be borderline useless.</p>
<p>Consumption metrics are obviously much more helpful to an engineer trying to understand why something changed. In our above web server team example, imagine request response time regressed by 30%. All the test report tells us is the time. It‚Äôs true, a developer can then try to reproduce the scenario locally, and manually narrow down the cause, however can be tedious, takes time, and is likely imperfect due to differences in lab versus local hardware. What if, instead, both instructions retired and memory allocated were reported alongside the regression in time? From this, it could be easy to see that suddenly 256KB of memory was being allocated per request that wasn‚Äôt there before. Being aware of recent commits, this could make it easy for an engineer to quickly pinpoint and back out the culprit in a timely manner before additional commits pile on top, further obscuring the problem. It‚Äôs like printf debugging.</p>
<p>Speaking of printf debugging, telemetry is essential for long-running tests. Even low-tech approaches like printfing the current set of metrics every so often (e.g., every 15 seconds), can help track down where something went into the weeds simply by inspecting a database or logfile. Imagine trying to figure out where the 4-hour web server test went off the rails at around the 3 1/2 hour mark. This can can be utterly maddening without continuous telemetry! Of course, it‚Äôs also a good idea to go beyond this. The product should have a built-in way to collect this telemtry out in the wild, and correlate it back to key metrics. StatsD is a fantastic option.</p>
<p>Finally, it‚Äôs important to measure these metrics as scientifically as possible. That includes tracking standard deviation, coefficient of variation (CV), and geomean, and using these to ensure tests don‚Äôt vary wildly from one run to the next. (Hint: commits that tank CV should be blocked, just as those that tank the core metric itself.) Having a statistics wonk on your team is also a good idea!
Goals and Baselines</p>
<p>Little of the above matters if you lack goals and baselines. For each benchmark/metric pair, I recommend recognizing four distinct concepts in your infrastructure and processes:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Current: the current performance (which can span multiple metrics).
</span><span style="color:#c0c5ce;">Baseline: the threshold the product must stay above/below, otherwise tests fail.
</span><span style="color:#c0c5ce;">Sprint Goal: where the team must get to before the current sprint ends.
</span><span style="color:#c0c5ce;">Ship Goal: where the team must get to in order to ship a competitive feature/scenario.
</span></pre>
<p>Assume a metric where higher is better (like throughput); then it‚Äôs usually the case that Ship Goal &gt;= Sprint Goal &gt;= Current &gt;= Baseline. As wins and losses happen, continual adjustments should be made.</p>
<p>For example, a ‚Äúbaseline ratcheting‚Äù process is necessary to lock in improvements. A reasonable approach is to ratchet the baseline automatically to within some percentage of the current performance, ideally based on standard deviation and/or CV. Another approach is to require that developers do it manually, so that all ratcheting is intentional and accounted for. And interestingly, you may find it helpful to ratchet in the other direction too. That is, block commits that improve performance dramatically and yet do not ratchet the baseline. This forces engineers to stop and think about whether performance changes were intentional ‚Äì even the good ones! A.k.a., ‚Äúconfirm your kill.‚Äù</p>
<p>It‚Äôs of course common that sprint goals remain stable from one sprint to the next. All numbers can‚Äôt be improving all the time. But this system also helps to ensure that the team doesn‚Äôt backslide on prior achievements.</p>
<p>I‚Äôve found it useful to organize sprint goals behind themes. Make this sprint about ‚Äúserver performance.‚Äù Or ‚Äúshake out excessive allocations.‚Äù Or something else that gives the team a sense of cohesion, shared purpose, and adds a little fun into the mix. As managers, we often forget how important fun is. It turns out performance can be the greatest fun of all; it‚Äôs hugely measurable ‚Äì which engineers love ‚Äì and, speaking for myself, it‚Äôs a hell of a time to pull out the scythe and start whacking away! It can even be a time to learn as a team, and to even try out some fun, new algorithmic techniques, like bloom filters.</p>
<p>Not every performance test needs this level of rigor. Any that are important enough to automatically run pre-commit most certainly demand it. And probably those that are run daily or monthly. But managing all these goals and baselines and whatnot can get really cumbersome when there are too many of them. This is a real risk especially if you‚Äôre tracking multiple metrics for each of your benchmarks.</p>
<p>This is where the idea of ‚Äúkey performance indicators‚Äù (KPIs) becomes very important. These are the performance metrics important enough to track at a management level, to the whole team how healthy the overall product is at any given time. In my past team who built an operating system and its components, this included things like process startup time, web server throughput, browser performance on standard industry benchmarks, and number of frames dropped in our realtime audio/video client, including multiple metrics apiece plus the abovementioned statistics metrics. These were of course in the regularly running pre- and post-commit test suites, but rolling them up in one place, and tracking against the goals, was a hugely focusing exercise.
In Summary</p>
<p>This post just scratches the surface of how to do good performance engineering, but I hope you walk away with at least one thing: doing performance well is all about having a great performance culture.</p>
<p>This culture needs to be infused throughout the entire organization, from management down to engineers, and everybody in between. It needs to be transparent, respectful, aggressive, data-driven, self-critical, and relentlessly ambitious. Great infrastructure and supporting processes are a must, and management needs to appreciate and reward these, just as they would feature work (and frequently even more). Only then will the self-reinforcing flywheel get going.</p>
<p>Setting goals, communicating regularly, and obsessively tracking goals and customer-facing metrics is paramount.</p>
<p>It‚Äôs not easy to do everything I‚Äôve written in this article. It‚Äôs honestly very difficult to remember to slow down and be disciplined in these areas, and it‚Äôs easy to trick yourself into thinking running as fast as possible and worrying about performance later is the right call. Well, I‚Äôm sorry to tell you, sometimes it is. You‚Äôve got to use your intuition and your gut, however, in my experience, we tend to undervalue performance considerably compared to features.</p>
<p>If you‚Äôre a manager, your team will thank you for instilling a culture like this, and you‚Äôll be rewarded by shipping better performing software on schedule. If you‚Äôre an engineer, I guarantee you‚Äôll spend far less time scrambling, more time being proactive, and more time having fun, in a team obsessed over customer performance. I‚Äôd love to hear what you think and your own experiences establishing a performance culture.</p>
<h4 id="15-years-of-concurrency">15 years of concurrency<a class="zola-anchor" href="#15-years-of-concurrency" aria-label="Anchor link for: 15-years-of-concurrency">üîó</a>
</h4>
<p><a href="http://joeduffyblog.com/2016/11/30/15-years-of-concurrency/">source</a></p>
<p>In a Tale of Three Safeties, we discussed three kinds of safety: type, memory, and concurrency. In this follow-on article, we will dive deeper into the last, and perhaps the most novel yet difficult, one. Concurrency-safety led me to the Midori project in the first place, having spent years on .NET and C++ concurrency models leading up to joining. We built some great things that I‚Äôm very proud of during this time. Perhaps more broadly interesting, however, are the reflections on this experience after a few years away from the project.</p>
<p>I‚Äôve tried to write this article about 6 times since earlier this year, and I‚Äôm thrilled to finally share it. I hope that it‚Äôs useful to anyone interested in the field, and especially anybody who is actively innovating in this area. Although the code samples and lessons learned are deeply rooted in C#, .NET, and the Midori project, I have tried to generalize the ideas so they are easily consumable regardless of programming language. I hope you enjoy!
Background</p>
<p>For most of the 2000s, my job was figuring out how to get concurrency into the hands of developers, starting out as a relatively niche job on the CLR team at Microsoft.
Niche Beginnings</p>
<p>Back then, this largely entailed building better versions of the classic threading, locking, and synchronization primitives, along with attempts to solidify best practices. For example, we introduced a thread-pool to .NET 1.1, and used that experience to improve the scalability of the Windows kernel, its scheduler, and its own thread-pool. We had this crazy 128-processor NUMA machine that kept us busy with all sorts of esoteric performance challenges. We developed rules for how to do concurrency right ‚Äì lock leveling, and so on ‚Äì and experimented with static analysis. I even wrote a book about it.</p>
<p>Why concurrency in the first place?</p>
<p>In short, it was enormously challenging, technically-speaking, and therefore boatloads of fun.</p>
<p>I had always been a languages wonk. So, I was naturally fascinated by the decades of deep work in academia, including programming language and runtime symbiosis (especially Cilk and NESL), advanced type systems, and even specialized parallel hardware architectures (especially radical ones like the Connection Machine, and MIMD supercomputers, that innovated beyond our trustworthy pal, von Neumann).</p>
<p>Although some very large customers actually ran symmetric multiprocessor (SMP) servers ‚Äì yes, we actually used to call them that ‚Äì I wouldn‚Äôt say that concurrency was a very popular area to specialize in. And certainly any mention of those cool ‚Äúresearchy‚Äù sources would have gotten an odd glance from my peers and managers. Nevertheless, I kept at it.</p>
<p>Despite having fun, I wouldn‚Äôt say the work we did during this period was immensely impactful to the casual observer. We raised the abstractions a little bit ‚Äì so that developers could schedule logical work items, think about higher levels of synchronization, and so on ‚Äì but nothing game-changing. Nonetheless, this period was instrumental to laying the foundation, both technically and socially, for what was to come later on, although I didn‚Äôt know it at the time.
No More Free Lunch; Enter Multicore</p>
<p>Then something big happened.</p>
<p>In 2004, Intel and AMD approached us about Moore‚Äôs Law, notably its imminent demise. Power wall challenges would seriously curtail the ever-increasing year-over-year clock speed improvements that the industry had grown accustomed to.</p>
<p>Suddenly management cared a whole lot more about concurrency. Herb Sutter‚Äôs 2005 ‚ÄúFree Lunch is Over‚Äù article captured the fever pitch. If we couldn‚Äôt enable developers to write massively parallel software ‚Äì something that was historically very difficult and unlikely to happen without significantly lower barriers to entry ‚Äì both Microsoft and Intel‚Äôs businesses, and mutually beneficial business models, were in trouble. If the hardware didn‚Äôt get faster in the usual ways, software couldn‚Äôt automatically get better, and people would have less reason to buy new hardware and software. An end to the Wintel era and Andy and Bill‚Äôs Law, ‚ÄúWhat Andy giveth, Bill taketh away‚Äù.</p>
<p>Or, so the thinking went.</p>
<p>This is when the term ‚Äúmulticore‚Äù broke into the mainstream, and we began envisioning a world with 1,024 core processors and even more forward-looking ‚Äúmanycore‚Äù architectures that took a page from DSPs, mixing general purpose cores with specialized ones that could offload heavy-duty functions like encryption, compression, and the like.</p>
<p>As an aside, with 10 years of hindsight, things didn‚Äôt unfold exactly as we thought they would. We don‚Äôt run PCs with 1,024 traditional cores, although our GPUs have blown way past that number, and we do see more heterogeneity than ever before, especially in the data center where FPGAs are now offloading critical tasks like encryption and compression.</p>
<p>The real big miss, in my opinion, was mobile. This was precisely when the thinking around power curves, density, and heterogeneity should have told us that mobile was imminent, and in a big way. Instead of looking to beefier PCs, we should have been looking to PCs in our pockets. Instead, the natural instinct was to cling to the past and ‚Äúsave‚Äù the PC business. This is a classical innovator‚Äôs dilemma although it sure didn‚Äôt seem like one at the time. And of course PCs didn‚Äôt die overnight, so the innovation here was not wasted, it just feels imbalanced against the backdrop of history. Anyway, I digress.
Making Concurrency Easier</p>
<p>As a concurrency geek, this was the moment I was waiting for. Almost overnight, finding sponsors for all this innovative work I had been dreaming about got a lot easier, because it now had a real, and very urgent, business need.</p>
<p>In short, we needed to:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Make it easier to write parallel code.
</span><span style="color:#c0c5ce;">Make it easier to avoid concurrency pitfalls.
</span><span style="color:#c0c5ce;">Make both of these things happen almost ‚Äúby accident.‚Äù
</span></pre>
<p>We already had threads, thread-pools, locks, and basic events. Where to go from here?</p>
<p>Three specific projects were hatched around this point and got an infusion of interest and staffing.
Software Transactional Memory</p>
<p>Ironically, we began with safety first. This foreshadows the later story, because in general, safety took a serious backseat until I was able to pick it back up in the context of Midori.</p>
<p>Developers already had several mechanisms for introducing concurrency, and yet struggled to write correct code. So we sought out those higher level abstractions that could enable correctness as if by accident.</p>
<p>Enter software transactional memory (STM). An outpouring of promising research had been coming out in the years since Herlihy and Moss‚Äôs seminal 1993 paper and, although it wasn‚Äôt a panacea, a number of us became enamored with its ability to raise the abstraction level.</p>
<p>STM let you write things like this, and get automatic safety:</p>
<p>void Transfer(Account from, Account to, int amt) {
atomic {
from.Withdraw(amt);
to.Deposit(amt);
}
}</p>
<p>Look ma, no locks!</p>
<p>STM could handle all of the decisions transparently like figuring out how coarse- or fine-grained synchronization to use, the contention policies around that synchronization, deadlock detection and prevention, and guarantee that you didn‚Äôt forget to lock when accessing a shared data structure. All behind a tantalizingly simple keyword, atomic.</p>
<p>STM also came with simple, more declarative, coordination mechanisms, like orElse. So, although the focus was on eliminating the need to manually manage locking, it also helped evolve synchronization between threads.</p>
<p>Unfortunately, after a few years of prototyping deep runtime, OS, and even hardware support, we abandoned the efforts. My brief summary is that it‚Äôs more important to encourage good concurrency architecture than it is to make poor ones ‚Äújust work‚Äù, although I have written more details here and here. It was this higher level architecture that we should focus on solving first and foremost and, after the dust settled, see what gaps remained. It wasn‚Äôt even clear that STM would be the correct tool for the job once we got to that point. (In hindsight, I do think it‚Äôs one of the very many reasonable tools in the toolbelt, although with more distributed application architectures on the rise, it‚Äôs a dangerous thing to give to people.)</p>
<p>Our STM efforts weren‚Äôt a complete failure, however. It was during this time that I began experimenting with type systems for safe concurrency. Moreover, bits and pieces ended up incorporated into Intel‚Äôs Haswell processor as the Transactional Synchronization Extensions (TSX) suite of instructions, delivering the capability to leverage speculative lock elision for ultra-cheap synchronization and locking operations. And again, I worked with some amazing people during this time.
Parallel Language Integrated Query (PLINQ)</p>
<p>Alongside STM, I‚Äôd been prototyping a ‚Äúskunkworks‚Äù data parallel framework, on nights and weekends, to leverage our recent work in Language Integrated Query (LINQ).</p>
<p>The idea behind parallel LINQ (PLINQ) was to steal a page from three well-researched areas:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Parallel databases, which already parallelized SQL queries on users‚Äô behalves without them needing to know about it, often with impressive results.

</span><span style="color:#c0c5ce;">Declarative and functional languages, which often used list comprehensions to express higher-level language operations that could be aggressively optimized, including parallelism. For this, I deepened my obsession with Haskell, and was inspired by APL.

</span><span style="color:#c0c5ce;">Data parallelism, which had quite a lengthy history in academia and even some more mainstream incarnations, most notably OpenMP.
</span></pre>
<p>The idea was pretty straightforward. Take existing LINQ queries, which already featured operations like maps, filters, and aggregations ‚Äì things that were classically parallelizable in both languages and databases ‚Äì and auto-parallelize them. Well, it couldn‚Äôt be implicit, because of side-effects. But all it took was a little AsParallel to enable:</p>
<p>// Sequential:
var q = (from x in xs
where p(x)
select f(x)).Sum();</p>
<p>// Parallel:
var q = (from x in xs.AsParallel()
where p(x)
select f(x)).Sum();</p>
<p>This demonstrates one of the great things about data parallelism. It can scale with the size of your inputs: either data quantity, expense of the operations against that data, or both. And when expressed in a sufficiently high-level language, like LINQ, a developer needn‚Äôt worry about scheduling, picking the right number of tasks, or synchronization.</p>
<p>This is essentially MapReduce, on a single machine, across many processors. Indeed, we later collaborated with MSR on a project called DryadLINQ which not only ran such queries across many processors, but also distributed them across many machines too. (Eventually we went even finer-grained with SIMD and GPGPU implementations.) This eventually led to Microsoft‚Äôs own internal equivalent to Google‚Äôs MapReduce, Cosmos, a system that powers a lot of big data innovation at Microsoft still to this date.</p>
<p>Developing PLINQ was a fond time in my career and a real turning point. I collaborated and built relationships with some amazing people. BillG wrote a full-page review of the idea, concluding with ‚ÄúWe will have to put more resources specifically on this work.‚Äù Such strong words of encouragement didn‚Äôt hurt with securing funding to deliver on the idea. It also attracted the attention of some incredible people. For example, Jim Gray took notice, and I got to experience his notorious generosity 1st hand, just two months before his tragic disappearance.</p>
<p>Needless to say, this was an exciting time!
Interlude: Forming the PFX Team</p>
<p>Around this time, I decided to broaden the scope of our efforts beyond just data parallelism, tackling task parallelism and other concurrency abstractions. So I went around pitching the idea of forming a new team.</p>
<p>Much to my surprise, a new parallel computing group was being created in the Developer Division in response to the changing technology landscape, and they wanted to sponsor these projects. It was an opportunity to roll everything up under a nice top-level business theme, unify recruiting efforts, and take things even further, eventually branching out into C++, GPGPUs, and more.</p>
<p>So, obviously, I said yes.</p>
<p>I named the team ‚ÄúPFX‚Äù, initially short for ‚Äúparallel frameworks‚Äù, although by the time we shipped marketing working its magic on us, renaming it to ‚ÄúParallel Extensions to .NET.‚Äù This team‚Äôs initial deliverable encompassed PLINQ, task parallelism, and a new effort, Coordination Data Structures (CDS), meant to handle advanced synchronization efforts, like barrier-style synchronization, concurrent and lock-free collections derived from many great research papers, and more.
Task Parallel Library</p>
<p>This brings me to task parallelism.</p>
<p>As part of PLINQ, we needed to create our own concept of parallel ‚Äútasks.‚Äù And we needed a sophisticated scheduler that could scale automatically given the machine‚Äôs available resources. Most existing schedulers were thread-pool like, in that they required that a task run on a separate thread, even if doing so was not profitable. And the mapping of tasks to threads was fairly rudimentary, although we did make improvements to that over the years.</p>
<p>Given my love of Cilk, and the need to schedule lots of potentially-recursive fine-grained tasks, choosing a work stealing scheduler for our scheduling architecture was a no-brainer.</p>
<p>At first, our eyes were locked squarely on PLINQ, and so we didn‚Äôt pay as much attention to the abstractions. Then MSR began exploring what standalone a task parallel library would look like. This was a perfect partnership opportunity and so we started building something together. The Task<T> abstraction was born, we rewrote PLINQ to use it, and created a suite of Parallel APIs for common patterns such as fork/join and parallel for and foreach loops.</p>
<p>Before shipping, we replaced the guts of the thread-pool with our new shiny work-stealing scheduler, delivering unified resource management within a process, so that multiple schedulers wouldn‚Äôt fight with one another. To this day, the code is almost identical to my early implementation in support of PLINQ (with many bug fixes and improvements, of course).</p>
<p>We really obsessed over the usability of a relatively small number of APIs for a long time. Although we made mistakes, I‚Äôm glad in hindsight that we did so. We had a hunch that Task<T> was going to be core to everything we did in the parallelism space but none of us predicted the widespread usage for asynchronous programming that really popularized it years later. Now-a-days, this stuff powers async and await and I can‚Äôt imagine life without Task<T>.
A Shout-Out: Inspiration From Java</p>
<p>I would be remiss if I didn‚Äôt mention Java, and the influence it had on my own thinking.</p>
<p>Leading up to this, our neighbors in the Java community had also begun to do some innovative work, led by Doug Lea, and inspired by many of the same academic sources. Doug‚Äôs 1999 book, Concurrent Programming in Java, helped to popularize these ideas in the mainstream and eventually led to the incorporation of JSR 166 into the JDK 5.0. Java‚Äôs memory model was also formalized as JSR 133 around this same time, a critical underpinning for the lock-free data structures that would be required to scale to large numbers of processors.</p>
<p>This was the first mainstream attempt I saw to raise the abstraction level beyond threads, locks, and events, to something more approachable: concurrent collections, fork/join, and more. It also brought the industry closer to some of the beautiful concurrent programming languages in academia. These efforts were a huge influence on us. I especially admired how academia and industry partnered closely to bring decades‚Äô worth of knowledge to the table, and explicitly sought to emulate this approach in the years to come.</p>
<p>Needless to say, given the similarities between .NET and Java, and level of competition, we were inspired.
O Safety, Where Art Thou?</p>
<p>There was one big problem with all of this. It was all unsafe. We had been almost exclusively focused on mechanisms for introducing concurrency, but not any of the safeguards that would ensure that using them was safe.</p>
<p>This was for good reason: it‚Äôs hard. Damn hard. Especially across the many diverse kinds of concurrency available to developers. But thankfully, academia had decades of experience in this area also, although it was arguably even more ‚Äúesoteric‚Äù to mainstream developers than the parallelism research. I began wallowing in it night and day.</p>
<p>The turning point for me was another BillG ThinkWeek paper I wrote, Taming Side Effects, in 2008. In it, I described a new type system that, little did I know at the time, would form the basis of my work for the next 5 years. It wasn‚Äôt quite right, and was too tied up in my experiences with STM, but it was a decent start.</p>
<p>Bill again concluded with a ‚ÄúWe need to do this.‚Äù So I got to work!
Hello, Midori</p>
<p>But there was still a huge problem. I couldn‚Äôt possibly imagine doing this work incrementally in the context of the existing languages and runtimes. I wasn‚Äôt looking for a warm-and-cozy approximation of safety, but rather something where, if your program compiled, you could know it was free of data races. It needed to be bulletproof.</p>
<p>Well, actually, I tried. I prototyped a variant of the system using C# custom attributes and static analysis, but quickly concluded that the problems ran deep in the language and had to be integrated into the type system for any of the ideas to work. And for them to be even remotely usable. Although we had some fun incubation projects at the time (like Axum), given the scope of the vision, and for a mixture of cultural and technical reasons, I knew this work needed a new home.</p>
<p>So I joined Midori.
An Architecture, and An Idea</p>
<p>A number of concurrency gurus were also on the Midori team, and I had been talking to them about all of this for a couple years leading up to me joining. At a top-level, we knew the existing foundation was the wrong one to bet on. Shared-memory multithreading really isn‚Äôt the future, we thought, and notably absent from all of my prior work was fixing this problem. The Midori team was set up exactly to tackle grand challenges and make big bets.</p>
<p>So, we made some:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Isolation is paramount, and we will embrace it wherever possible.

</span><span style="color:#c0c5ce;">Message passing will connect many such isolated parties through strongly typed RPC interfaces.

</span><span style="color:#c0c5ce;">Namely, inside of a process, there exists a single message loop, and, by default, no extra parallelism.

</span><span style="color:#c0c5ce;">A ‚Äúpromises-like‚Äù programming model will be first class so that:
</span><span style="color:#c0c5ce;">    Synchronous blocking is disallowed.
</span><span style="color:#c0c5ce;">    All asynchronous activity in the system is explicit.
</span><span style="color:#c0c5ce;">    Sophisticated coordination patterns are possible without resorting to locks and events.
</span></pre>
<p>To reach these conclusions we were heavily inspired by Hoare CSPs, Gul Agha‚Äôs and Carl Hewitt‚Äôs work on Actors, E, œÄ, Erlang, and our own collective experiences building concurrent, distributed, and various RPC-based systems over the years.</p>
<p>I didn‚Äôt say this before, however message passing was notably absent in my work on PFX. There were multiple reasons. First, there were many competing efforts, and none of them ‚Äúfelt‚Äù right. For instance, the Concurrency and Coordination Runtime (CCR) was very complex (but had many satisfied customers); the Axum language was, well, a new language; MSR‚Äôs Cœâ was powerful, but required language changes which some were hesitant to pursue (though the derivative library-only work, Joins, held some promise); and so on. Second, it didn‚Äôt help that everyone seemed to have a different idea on what the fundamental concepts should be.</p>
<p>But it really came down to isolation. Windows processes are too heavyweight for the fine-grained isolation we thought necessary to deliver safe, ubiquitous and easy message passing. And no sub-process isolation technology on Windows was really up for the task: COM apartments, CLR AppDomains, ‚Ä¶ many flawed attempts instantly come to mind; frankly, I did not want to die on that hill.</p>
<p>(Since then, I should note, there have been some nice efforts, like Orleans ‚Äì built in part by some ex-Midori members ‚Äì TPL Dataflow, and Akka.NET. If you want to do actors and/or message passing in .NET today, I recommend checking them out.)</p>
<p>Midori, on the other hand, embraced numerous levels of isolation, beginning with processes themselves, which were even cheaper than Windows threads thanks to software isolation. Even coarser-grained isolation was available in the form of domains, adding added belts-and-suspenders hardware protection for hosting untrusted or logically separate code. In the early days, we certainly wanted to go finer-grained too ‚Äì inspired by E‚Äôs concept of ‚Äúvats‚Äù, the abstraction we already began with for process message pumps ‚Äì but weren‚Äôt sure how to do it safely. So we waited on this. But this gave us precisely what we needed for a robust, performant, and safe message passing foundation.</p>
<p>Important to the discussion of this architecture is the notion of shared nothing, something Midori leveraged as a core operating principle. Shared nothing architectures are great for reliability, eliminating single points of failure, however they are great for concurrency safety too. If you don‚Äôt share anything, there is no opportunity for race conditions! (This is a bit of a lie, and generally insufficient, as we shall see.)</p>
<p>It‚Äôs interesting to note that we were noodling on this around the same time Node.js was under development. The core idea of an asynchronous, non-blocking, single process-wide event loop, is remarkably similar. Perhaps something tasty was in the water during 2007-2009. In truth, many of these traits are common to event-loop concurrency.</p>
<p>This formed the canvas on top of which the entire concurrency model was painted. I‚Äôve already discussed this in the asynchronous everything article. But there was more‚Ä¶
Why Not Stop Here?</p>
<p>It‚Äôs a reasonable question. A very robust system could be built with nothing more than the above, and I should say, throughout multiple years of pounding away at the system, the above foundation stood the test of time and underwent far fewer changes than what came next (syntax aside). There is a simplicity to leaving it at this that I admire. In fact, with perfect hindsight, I believe stopping here would have been a reasonable story for ‚ÄúV1.‚Äù</p>
<p>However, a number of things kept us pushing for more:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">There was no sub-process parallelism. Notably absent were task and data parallelism. This was painful for a guy who had just come from building .NET‚Äôs task and PLINQ programming models. We had plenty of places that had latent parallelism just waiting to be unlocked, like image decoding, the multimedia pipeline, FRP rendering stack, browser, eventually speech recognition, and more. One of Midori‚Äôs top-level goals was to tackle the concurrency monster and, although a lot of parallelism came for ‚Äúfree‚Äù thanks to processes, the absence of task and data parallelism hurt.

</span><span style="color:#c0c5ce;">All messages between processes required RPC data marshaling, so rich objects could not be shared. One solution to the absence of task parallelism could have been to model everything as processes. Need a task? Spawn a process. In Midori, they were cheap enough for this to work. Doing that, however, entailed marshaling data. Not only could that be an expensive operation, not all types were marshalable, severely limiting parallelizable operations.

</span><span style="color:#c0c5ce;">In fact, an existing ‚Äúexchange heap‚Äù was developed for buffers, loosely based on the concept of linearity. To avoid marshaling large buffers, we already had a system for exchanging them between processes without copying as part of the RPC protocol. This idea seemed useful enough to generalize and offer for higher-level data structures.

</span><span style="color:#c0c5ce;">Even intra-process race conditions existed, due to multiple asynchronous activities in-flight and interleaving, despite the lack of data races thanks to the single message loop model described above. A benefit of the await model is that interleaving are at least visible and auditable in the source code; but they could still trigger concurrency errors. We saw opportunities for the language and frameworks to help developers get this correct.

</span><span style="color:#c0c5ce;">Finally, we also had a vague desire to have more immutability in the system. Doing so could help with concurrency safety, of course, but we felt the language should also help developers get existing commonplace patterns correct-by-construction. We also saw performance optimization opportunities if the compiler could trust immutability.
</span></pre>
<p>We went back to academia and the ThinkWeek paper in search of inspiration. These approaches, if combined in a tasteful way, seemed like they could give us the tools necessary to deliver not only safe task and data parallelism, but also finer-grained isolation, immutability, and tools to possibly address some of the intra-process race conditions.</p>
<p>So, we forked the C# compiler, and went to town.
The Model</p>
<p>In this section, I will rearrange the story to be a bit out of order. (How appropriate.) I‚Äôll first describe the system we ended up with, after many years of work, in ‚Äútutorial style‚Äù rather than starting with the slightly messier history of how we ended up there. I hope this gives a more concise appreciation of the system. I will then afterwards give the complete historical account, including the dozens of systems that came before which influenced us greatly.</p>
<p>We started with C#‚Äôs type system and added two key concepts: permission and ownership.
Permission</p>
<p>The first key concept was permission.</p>
<p>Any reference could have one and it governed what you could do with the referent object:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">mutable: The target object (graph) can be mutated through the usual ways.
</span><span style="color:#c0c5ce;">readonly: The target object (graph) can be read from but cannot be mutated.
</span><span style="color:#c0c5ce;">immutable: The target object (graph) can be read from and will never be mutated.
</span></pre>
<p>A subtyping relationship meant you could implicitly convert either mutable or immutable to readonly. In other words, mutable &lt;: readonly and immutable &lt;: readonly.</p>
<p>For example:</p>
<p>Foo m = new Foo(); // mutable by default.</p>
<p>immutable Foo i = new Foo(); // cannot ever be mutated.
i.Field++; // error: cannot mutate an immutable object.</p>
<p>readonly Foo r1 = m; // ok; cannot be mutated by this reference.
r1.Field++; // error: cannot mutate a readonly object.</p>
<p>readonly Foo r2 = i; // ok; still cannot be mutated by this reference.
r2.Field++; // error: cannot mutate a readonly object.</p>
<p>These are guarantees, enforced by the compiler and subject to verification.</p>
<p>The default, if unstated, was immutable for primitive types like int, string, etc., and mutable for all others. This preserved existing C# semantics in almost all scenarios. (That is, C# compiled as-is had no change in meaning.) This was contentious but actually a pretty cool aspect of the system. It was contentious because the principle of least authority would lead you to choose readonly as the default. It was cool because you could take any C# code and start incrementally sprinkling in permissions where they delivered value. If we had decided to break from C# more radically ‚Äì something in hindsight we should have done ‚Äì then breaking with compatibility and choosing the safer default would have been the right choice; but given our stated goals of C# compatibility, I think we made the right call.</p>
<p>These permissions could also appear on methods, to indicate how the this parameter got used:</p>
<p>class List<T> {
void Add(T e);
int IndexOf(T e) readonly;
T this[int i] { readonly get; set; }
}</p>
<p>A caller would need a sufficient permission in order to invoke a method:</p>
<p>readonly List<Foo> foos = ...;
foos[0] = new Foo(); // error: cannot mutate a readonly object.</p>
<p>A similar thing could be stated using delegate types and lambdas. For example:</p>
<p>delegate void PureFunc<T>() immutable;</p>
<p>This meant that a lambda conforming to the PureFunc interface could only close over immutable state.</p>
<p>Notice how powerful this has suddenly become! This PureFunc is precisely what we would want for a parallel task. As we will see shortly, these simple concepts alone are enough to enable many of those PFX abstractions to become safe.</p>
<p>By default, permissions are ‚Äúdeep‚Äù, in that they apply transitively, to the entire object graph. This interacts with generics in the obvious way, however, so that you could, for example, have combinations of deep and shallow permissions:</p>
<p>readonly List<Foo> foos = ...;             // a readonly list of mutable Foos.
readonly List<readonly Foo> foos = ...;    // a readonly list of readonly Foos.
immutable List<Foo> foos = ...;            // an immutable list of mutable Foos.
immutable List<immutable Foo> foos = ...;  // an immutable list of immutable Foos.
// and so on...</p>
<p>Despite this working, and appearing obvious, man was this a difficult thing to get right!</p>
<p>For power users, we also had a way to write generic types that parameterized over permissions. This was definitely required deep in the bowels of highly generic code, but otherwise could be ignored by 90% of the system‚Äôs users:</p>
<p>delegate void PermFunc&lt;T, U, V, permission P&gt;(P T, P U, P V);</p>
<p>// Used elsewhere; expands to <code>void(immutable Foo, immutable Bar, immutable Baz)</code>:
PermFunc&lt;Foo, Bar, Baz, immutable&gt; func = ...;</p>
<p>I should also note that, for convenience, you could mark a type as immutable to indicate ‚Äúall instances of this type are immutable.‚Äù This was actually one of the most popular features of all of this. At the end of the day, I‚Äôd estimate that 1/4-1/3 of all types in the system were marked as immutable:</p>
<p>immutable class Foo {...}
immutable struct Bar {...}</p>
<p>There is an interesting twist. As we‚Äôll see below, readonly used to be called readable, and was entirely distinct. But after we left Midori and were hard at work trying to ready these concepts for inclusion in C#, we decided to try and unify them. So that‚Äôs what I am presenting here. The only hitch is that readonly would be given a slightly different meaning. On a field, readonly today means ‚Äúthe value cannot be changed‚Äù; in the case of a pointer, therefore, the readonly of today did not impact the referent object graph. In this new model, it would. Given that we anticipated an opt-in flag, --strict-mutability, this would be acceptable, and would require readonly mutable, a slight wart, to get the old behavior. This wasn‚Äôt a deal-breaker to me ‚Äì especially given that a very common bug in C# is developers assuming that readonly is deep (which now it would be), and obvious similarities to const come to mind.
Ownership</p>
<p>The second key concept was ownership.</p>
<p>A reference could be given an ownership annotation, just as it could be given a permission:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">isolated: The target object (graph) forms an unaliased transitive closure of state.
</span></pre>
<p>For example:</p>
<p>isolated List<int> builder = new List<int>();</p>
<p>Unlike permissions, which indicate what operations are legal on a given reference, ownership annotations told us important aliasing properties about the given object graphs. An isolated graph has a single ‚Äúin-reference‚Äù to the root object in the object graph, and no ‚Äúout-references‚Äù (except for immutable object references, which are permitted).</p>
<p>A visual aid might help to conceptualize this:</p>
<p>Isolation Bubbles</p>
<p>Given an isolated object, we can mutate it in-place:</p>
<p>for (int i = 0; i &lt; 42; i++) {
builder.Add(i);
}</p>
<p>And/or destroy the original reference and transfer ownership to a new one:</p>
<p>isolated List<int> builder2 = consume(builder);</p>
<p>The compiler from here on would mark builder as uninitialized, though if it is stored in the heap multiple possible aliases might lead to it, so this analysis could never be bulletproof. In such cases, the original reference would be nulled out to avoid safety gotchas. (This was one of many examples of making compromises in order to integrate more naturally into the existing C# type system.)</p>
<p>It‚Äôs also possible to destroy the isolated-ness, and just get back an ordinary List<int>:</p>
<p>List<int> built = consume(builder);</p>
<p>This enabled a form of linearity that was useful for safe concurrency ‚Äì so objects could be handed off safely, subsuming the special case of the exchange heap for buffers ‚Äì and also enabled patterns like builders that laid the groundwork for strong immutability.</p>
<p>To see why this matters for immutability, notice that we skipped over exactly how an immutable object gets created. For it to be safe, the type system needs to prove that no other mutable reference to that object (graph) exists at a given time, and will not exist forever. Thankfully that‚Äôs precisely what isolated can do for us!</p>
<p>immutable List<int> frozen = consume(builder);</p>
<p>Or, more concisely, you‚Äôre apt to see things like:</p>
<p>immutable List<int> frozen = new List<int>(new[] { 0, ..., 9 });</p>
<p>In a sense, we have turned our isolation bubble (as shown earlier) entirely green:</p>
<p>Immutability from Isolation Bubbles</p>
<p>Behind the scenes, the thing powering the type system here is isolated and ownership analysis. We will see more of the formalisms at work in a moment, however there is a simple view of this: all inputs to the List<int>‚Äôs constructor are isolated ‚Äì namely, in this case, the array produced by new[] ‚Äì and therefore the resulting List<int> is too.</p>
<p>In fact, any expression consuming only isolated and/or immutable inputs and evaluating to a readonly type was implicitly upgradeable to immutable; and, a similar expression, evaluating to a mutable type, was upgradeable to isolated. This meant that making new isolated and immutable things was straightforward using ordinary expressions.</p>
<p>The safety of this also depends on the elimination of ambient authority and leaky construction.
No Ambient Authority</p>
<p>A principle in Midori was the elimination of ambient authority. This enabled capability-based security, however in a subtle way was also necessary for immutability and the safe concurrency abstractions that are to come.</p>
<p>To see why, let‚Äôs take our PureFunc example from earlier. This gives us a way to reason locally about the state captured by a lambda. In fact, a desired property was that functions accepting only immutable inputs would result in referential transparency, unlocking a number of novel compiler optimizations and making it easier to reason about code.</p>
<p>However, if mutable statics still exist, the invocation of that PureFunc may not actually be pure!</p>
<p>For example:</p>
<p>static int x = 42;</p>
<p>PureFunc<int> func = () =&gt; x++;</p>
<p>From the type system‚Äôs point of view, this PureFunc has captured no state, and so it obeys the immutable capture requirement. (It may be tempting to say that we can ‚Äúsee‚Äù the x++, and therefore can reject the lambda, however of course this x++ might happen buried deep down in a series of virtual calls, where it is invisible to us.)</p>
<p>All side-effects need to be exposed to the type system. Over the years, we explored extra annotations to say ‚Äúthis function has mutable access to static variables‚Äù; however, the mutable permission is already our way of doing that, and felt more consistent with the overall stance on ambient authority that Midori took.</p>
<p>As a result, we eliminated all ambient side-effectful operations, leveraging capability objects instead. This obviously covered I/O operations ‚Äì all of which were asynchronous RPC in our system ‚Äì but also even ‚Äì somewhat radically ‚Äì meant that even just getting the current time, or generating a random number, required a capability object. This let us model side-effects in a way the type-system could see, in addition to reaping the other benefits of capabilities.</p>
<p>This meant that all statics must be immutable. This essentially brought C#‚Äôs const keyword to all statics:</p>
<p>const Map&lt;string, int&gt; lookupTable = new Map&lt;string, int&gt;(...);</p>
<p>In C#, const is limited to primitive constants, like ints, bools, and strings. Our system expanded this same capability to arbitrary types, like lists, maps, ‚Ä¶, anything really.</p>
<p>Here‚Äôs where it gets interesting. Just like C#‚Äôs current notion of const, our compiler evaluated all such objects at compile-time and froze them into the readonly segment of the resulting binary image. Thanks to the type system‚Äôs guarantee that immutability meant immutability, there was no risk of runtime failures as a result of doing so.</p>
<p>Freezing had two fascinating performance consequences. First, we could share pages across multiple processes, cutting down on overall memory usage and TLB pressure. (For instance, lookup tables held in maps were automatically shared across all programs using that binary.) Second, we were able to eliminate all class constructor accesses, replacing them with constant offsets, leading to more than a 10% reduction in code size across the entire OS along with associated speed improvements, particularly at startup time.</p>
<p>Mutable statics sure are expensive!
No Leaky Construction</p>
<p>This brings us to the second ‚Äúhole‚Äù that we need to patch up: leaky constructors.</p>
<p>A leaky constructor is any constructor that shares this before construction has finished. Even if it does so at the ‚Äúvery end‚Äù of its own constructor, due to inheritance and constructor chaining, this isn‚Äôt even guaranteed to be safe.</p>
<p>So, why are leaky constructors dangerous? Mainly because they expose other parties to partially constructed objects. Not only are such objects‚Äô invariants suspect, particularly in the face of construction failure, however they pose a risk to immutability too.</p>
<p>In our particular case, how are we to know that after creating a new supposedly-immutable object, someone isn‚Äôt secretively holding on to a mutable reference? In that case, tagging the object with immutable is a type hole.</p>
<p>We banned leaky constructors altogether. The secret? A special permission, init, that meant the target object is undergoing initialization and does not obey the usual rules. For example, it meant fields weren‚Äôt yet guaranteed to be assigned to, non-nullability hadn‚Äôt yet been established, and that the reference could not convert to the so-called ‚Äútop‚Äù permission, readonly. Any constructor got this permission by default and you couldn‚Äôt override it. We also automatically used init in select areas where it made the language work more seamlessly, like in object initializers.</p>
<p>This had one unfortunate consequence: by default, you couldn‚Äôt invoke other instance methods from inside a constructor. (To be honest, this was actually a plus in my opinion, since it meant you couldn‚Äôt suffer from partially constructed objects, couldn‚Äôt accidentally invoke virtuals from a constructor, and so on.) In most cases, this was trivially worked around. However, for those cases where you really needed to call an instance method from a constructor, we let you mark methods as init and they would take on that permission.
Formalisms and Permission Lattices</p>
<p>Although the above makes intuitive sense, there was a formal type system behind the scenes.</p>
<p>Being central to the entire system, we partnered with MSR to prove the soundness of this approach, especially isolated, and published the paper in OOPSLA‚Äô12 (also available as a free MSR tech report). Although the paper came out a couple years before this final model solidified, most of the critical ideas were taking shape and well underway by then.</p>
<p>For a simple mental model, however, I always thought about things in terms of subtyping and substitution.</p>
<p>In fact, once modeled this way, most implications to the type system ‚Äúfall out‚Äù naturally. readonly was the ‚Äútop permission‚Äù, and both mutable and immutable convert to it implicitly. The conversion to immutable was a delicate one, requiring isolated state, to guarantee that it obeyed the immutability requirements. From there, all of the usual implications follow, including substitution, variance, and their various impact to conversions, overrides, and subtypes.</p>
<p>This formed a two-dimensional lattice wherein one dimension was ‚Äútype‚Äù in the classical sense and the other ‚Äúpermission‚Äù, such that all types could convert to readonly Object. This diagram illustrates:</p>
<p>Permission Lattice</p>
<p>The system could obviously be used without any knowledge of these formalisms. However, I had lived through enough sufficiently scary, yet subtle, security problems over the years due to type system gotchas, so going the extra mile and doing the formalism not only helped us understand our own system better, but also helped us sleep better at night.
How This Enabled Safe Concurrency</p>
<p>New type system in hand, we can now go back and revisit those PFX abstractions, and make them all safe.</p>
<p>The essential property we must establish is that, when an activity has mutable rights to a given object, then that object must not be simultaneously accessible to any other activities. Notice that I am using the term ‚Äúactivity‚Äù deliberately. For now, imagine this maps directly to ‚Äútask‚Äù, although we shall return to this subtlety momentarily. Also note that I‚Äôve said ‚Äúobject‚Äù; that too is a gross simplification, since for certain data structures like arrays, simply ensuring that activities do not have mutable rights to overlapping regions is sufficient.</p>
<p>Beyond what this disallows, it actually allows for some interesting patterns. For instance, any number of concurrent activities may share readonly access to the same object. (This is a bit like a reader/writer lock, just without any locks or runtime overheads.) Remember that we can convert mutable to readonly, which means that, given an activity with mutable access, we can use fork/join parallelism that captures an object with readonly permissions, provided the mutator is temporally paused for the duration of this fork/join operation.</p>
<p>Or, in code:</p>
<p>int[] arr = ...;
int[] results = await Parallel.Fork(
() =&gt; await arr.Reduce((x, y) =&gt; x+y),
() =&gt; await arr.Reduce((x, y) =&gt; x*y)
);</p>
<p>This code computes the sum and product of an array, in parallel, by merely reading from it. It is data race-free.</p>
<p>How so? This example Fork API uses permissions to enforce the required safety:</p>
<p>public static async T[] Fork<T>(params ForkFunc<T>[] funcs);</p>
<p>public async delegate T ForkFunc<T>() readonly;</p>
<p>Let‚Äôs break this apart. Fork simply takes an array of ForkFuncs. Since Fork is static, we needn‚Äôt worry about it capturing state dangerously. But ForkFunc is a delegate and can be satisfied by instance methods and lambdas, both of which can close over state. By marking the this position as readonly, we limit the captures to readonly; so, although the lambdas can capture arr in our above example, they cannot mutate it. And that‚Äôs it.</p>
<p>Notice too that the nested function Reduce can also be run in parallel, thanks to ForkFunc! Obviously, all of the familiar Parallel.For, Parallel.ForEach, and friends, can enjoy similar treatment, with similar safety.</p>
<p>It turns out most fork/join patterns, where we can guarantee the mutator is paused, work this way. All of PLINQ, for example, can be represented this way, with complete data-race freedom. This was the use-case I always had in mind.</p>
<p>In fact, we can now introduce automatic parallelism! There are a few ways to go about this. One way is to never offer LINQ operators that aren‚Äôt protected by readonly annotations. This was always my preferred approach, given the absurdity of having query operators performing mutations. But other approaches were possible. One is to offer overloads ‚Äì one set of mutable operators, one set of readonly operators ‚Äì and the compiler‚Äôs overload resolution would then pick the one with the least permission that type-checked.</p>
<p>As mentioned earlier, tasks are even simpler than this:</p>
<p>public static Task<T> Run<T>(PureFunc<T> func);</p>
<p>This accepts our friend from earlier, PureFunc, that is guaranteed to be referentially transparent. Since tasks do not have structured lifetime like our fork/join and data parallel friends above, we cannot permit capture of even readonly state. Remember, the trick that made the above examples work is that the mutator was temporarily paused, something we cannot guarantee here with unstructured task parallelism.</p>
<p>So, what if a task needs to party on mutable state?</p>
<p>For that, we have isolated! There are various ways to encode this, however, we had a way to mark delegates to indicate they could capture isolated state too (which had the side-effect of making the delegate itself isolated):</p>
<p>public static Task<T> Run<T>(TaskFunc<T> func);</p>
<p>public async delegate T TaskFunc<T>() immutable isolated;</p>
<p>Now we can linearly hand off entire object graphs to a task, either permanently or temporarily:</p>
<p>isolated int[] data = ...;
Task<int> t = Task.Run(<a href="https://www.johangall.com/jojolisp/">consume data</a> =&gt; {
// in here, we own <code>data</code>.
});</p>
<p>Notice that we leveraged lambda capture lists to make linear captures of objects straightforward. There‚Äôs an active proposal to consider adding a feature like this to a future C#, however without many of the Midori features, it remains to be seen whether the feature stands on its own.</p>
<p>Because of the rules around isolation production, mutable objects produced by tasks could become isolated, and readonly object could be frozen to become immutable. This was tremendously powerful from a composition standpoint.</p>
<p>Eventually, we created higher level frameworks to help with data partitioning, non-uniform data parallel access to array-like structures, and more. All of it free from data races, deadlocks, and the associated concurrency hazards.</p>
<p>Although we designed what running subsets of this on a GPU would look like, I would be lying through my teeth if I claimed we had it entirely figured out. All that I can say is understanding the side-effects and ownership of memory are very important concepts when programming GPUs, and we had hoped the above building blocks would help create a more elegant and unified programming model.</p>
<p>The final major programming model enhancement this enabled was fine-grained ‚Äúactors‚Äù, a sort of mini-process inside of a process. I mentioned the vat concept earlier, but that we didn‚Äôt know how to make it safe. Finally we had found the missing clue: a vat was really just an isolated bubble of state. Now that we had this concept in the type system, we could permit ‚Äúmarshaling‚Äù of immutable and isolated objects as part of the message passing protocol without marshaling of any sort ‚Äì they could be shared safely by-reference!</p>
<p>I would say that the major weakness of this system was also its major benefit. The sheer permutations of concepts could be overwhelming. Most of them composed nicely, however the poor developers creating the underlying ‚Äúsafe concurrency‚Äù abstractions ‚Äì myself included ‚Äì almost lost our sanity in doing so. There is probably some generics-like unification between permissions and ownership that could help here, however the ‚Äúfunniness‚Äù of linearity is hard to quarantine.</p>
<p>Amazingly, it all worked! All those cases I mentioned earlier ‚Äì image decoders, the multimedia stack, the browser, etc. ‚Äì could now use safe intra-process parallelism in addition to being constructed out of many parallel processes. Even more interestingly, our one production workload ‚Äì taking Speech Recognition traffic for Bing.com ‚Äì actually saw significant reductions in latency and improvements in throughput as a result. In fact, Cortana‚Äôs DNN-based speech recognition algorithms, which delivered a considerable boost to accuracy, could have never reached their latency targets were it not for this overall parallelism model.
Sequential Consistency and Tear-Free Code</p>
<p>There was another unanticipated consequence of safe concurrency that I quite liked: sequential consistency (SC).</p>
<p>For free.</p>
<p>After all those years trying to achieve a sane memory model, and ultimately realizing that most of the popular techniques were fundamentally flawed, we had cracked the nut. All developers got SC without the price of barriers everywhere. Given that we had been running on ARM processors where a barrier cost you 160 cycles, this gave us not only a usability edge, but also a performance one. This also gave our optimizing compiler much more leeway on code motion, because it could now freely order what used to be possibly-side- effectful operations visible to multiple threads.</p>
<p>To see how we got SC for free, consider how the overall system was layered.</p>
<p>At the bottom of all of the above safe concurrency abstractions, there was indeed unsafe code. This code was responsible for obeying the semantic contract of safe concurrency by decorating APIs with the right permissions and ownership, even if the implementation physically violated them. But it is important to note: this is the only code in the system ‚Äì plus the 1st party kernel code ‚Äì that had to deal with concurrency at the threads, locks, events, and lock-free level of abstraction. Everything else built atop the higher-level abstractions, where barriers had already been placed into the instruction stream at all the right places, thanks to the infrastructure.</p>
<p>This had another consequence: no struct tearing was visible in the 3rd party programming model. Everything was ‚Äúatomic‚Äù, again for free.</p>
<p>This allowed us to use multi-word slice and interface representations, just like Go does, but without the type-safety- threatening races. It turns out, the risk of struct tearing is one of major factors preventing us from having a great Go-like slice type to C# and .NET. In Midori, slices were safe, efficient, and everywhere.
Message Passing Races</p>
<p>Message passing helps tremendously when building correct, reliable concurrent systems, however it is not a panacea. I had mentioned shared nothing earlier on. It‚Äôs a dirty little secret, however, even if you don‚Äôt have shared memory, but agents can communicate with one another, you still have shared state encoded in the messaging between those agents, and the opportunity for race conditions due to the generally unpredictable order of arrival of these messages.</p>
<p>This is understood, although perhaps not very widely. The most worrisome outcome from these kind of races is time of check time of use (TOCTOU), one of the more common kinds of races that can lead to security vulnerabilities. (Midori‚Äôs type- and memory-safety of course helps to avoid this particular symptom, however reliability problems are very real also.)</p>
<p>Although people used to hate it when I compared this situation to COM STAs, for those familiar with them, an analogy is apt. If you need to block a thread inside of a COM STA, you must decide: Do I pump the message loop, or do I not pump the message loop? If you choose to pump the message loop, you can suffer reentrancy, and that reentrancy might be witness to broken invariants, or even mutate state out from underneath the blocking call, much to its dismay after it reawakens. If you choose not to pump the message loop, you can suffer deadlock, as calls pile up, possibly ones that are required to unblock the thread.</p>
<p>In Midori‚Äôs system, we did not give this choice to the developer. Instead, every await was an opportunity to pump the underlying message loop. Just as with a COM STA, these pumps possibly dispatched work that might interact with shared state. Note that this is not parallelism, mind you, since process event loops did not permit parallelism, however there is possibly a lot of concurrency going on here, and it can definitely screw you:</p>
<p>async bool IsRed(AsyncColor c) {
return (await c.R &gt; 0 &amp;&amp; await c.G == 0 &amp;&amp; await c.B == 0);
}</p>
<p>This rather simple (and silly) function checks to see if an AsyncColor is ‚Äúred‚Äù; to do so, it reads the R, G, and B properties. For whatever reason, they are asynchronous, so we must await between accesses. If AsyncColor is a mutable object, well, guess what ‚Äì these values might change after we‚Äôve read them, opening up a possible TOCTOU bug. For instance, imagine a caller‚Äôs surprise when IsRed may have lied to it:</p>
<p>AsyncColor c = ...;
await IsRed(c);
assert(await c.R &gt; 0);</p>
<p>That assertion can very well fire. Even this callsite has a TOCTOU bug of its own, since c.R might be &gt;0 at the end of IsRed‚Äôs return, but not after the assert expression‚Äôs own await has completed.</p>
<p>All of this should be familiar territory for concurrency experts. But we sought to eliminate these headaches.</p>
<p>This area of the system was still under active development towards the end of our project, however we had sketched out a very promising approach. It was to essentially apply similar permission annotations to asynchronous activity ‚Äì hence my choice of the term ‚Äúactivity‚Äù earlier ‚Äì as we did parallel tasks. Although this seriously limited an asynchronous activity‚Äôs state purview, combined with a reader/writer-lock like idea, meant that we could use permissions affixed to asynchronous interfaces to automatically ensure state and asynchronous operations were dispatched safely.
Evolution</p>
<p>Before moving on, a brief word on the evolution of the system. As I mentioned earlier, I presented the system in its final form. In reality, we went through five major phases of evolution. I won‚Äôt bore you with exhaustive details on each one, although I will note the major mistakes and lessons learned in each phase.</p>
<p>In the first phase, I tried to build the system entirely out of annotations that were ‚Äúoutside‚Äù of the type system. As I‚Äôve already said, that failed spectacularly. At this point, I hope you can appreciate how deeply integrated into the compiler and its type system these concepts need to be for them to work and for the result to be usable.</p>
<p>Next, I tried a variant of this with just readonly. Except I called it readable (a name that would stick until the very tail end of the project), and it was always deep. There was no immutable and there was no isolated. The concept of mutable was called writable, although I was delusional, and thought you‚Äôd never need to state it. I was very confused about the role generics played here, and ended up coding myself up into a corner trying to make it work.</p>
<p>After that, I recognized at least that readable and writable were related to one another, and recognized the subtyping relationship of (writable &lt;: readable). And, largely based on conversations with colleagues in MSR, I decided to toss out everything I had done on generics and redo it. It was at that time I recognized that each generic type variable, despite looking like a naked type, actually carried both a permission and a type. That helped.</p>
<p>I then came up with immutable, however it wasn‚Äôt what you see today. Instead, it had the slightly confusing meaning of being a ‚Äúview‚Äù over just the immutable subset of data in the target object graph. (This was at first limited to only readonly fields (in the classical C# sense) that were of a primitive type.) If you tried reading a non-immutable part from this view, you‚Äôd get a compiler error. Bizarrely, this meant you could have an immutable List<T> that wasn‚Äôt actually immutable. In hindsight, this was pretty wonky, but it got us thinking about and discussing immutability.</p>
<p>Somewhere in here, we recognized the need for generic parameterization over permissions, and so we added that. Unfortunately, I originally picked the % character to indicate that a generic type was a permission, which was quite odd; e.g., G&lt;%P&gt; versus G<T>. We renamed this to permission; e.g., G<permission P> versus G<T>.</p>
<p>There was one problem. Generic permissions were needed in way more places than we expected, like most property getters. We experimented with various ‚Äúshortcuts‚Äù in an attempt to avoid developers needing to know about generic permissions. This hatched the readable+ annotation, which was a shortcut for ‚Äúflow the this parameter‚Äôs permission.‚Äù This concept never really left the system, although (as we will see shortly), we fixed generics and eventually this concept became much easier to swallow, syntax-wise (especially with smart defaults like auto-properties).</p>
<p>We lived with this system for some time and this was the first version deployed at-scale into Midori.</p>
<p>And then a huge breakthrough happened: we discovered the concepts necessary for isolated and, as a result, an immutable annotation that truly meant that an object (graph) was immutable.</p>
<p>I can‚Äôt claim credit for this one. That was the beauty of getting to this stage: after developing and prototyping the initial ideas, and then deploying them at-scale, we suddenly had our best and brightest obsessing over the design of this thing, because it was right under their noses. This was getting an initial idea out in front of ‚Äúcustomers‚Äù early-and-often at its finest, and, despite some growing pains, worked precisely as designed.</p>
<p>We then wallowed in the system for another year and 1/2 and, frankly, I think lost our way a little bit. It turns out deepness was a great default, but sometimes wasn‚Äôt what you wanted. List<T> is a perfect example; sometimes you want the List to be readonly but the elements to be mutable. In the above examples, we took this capability for granted, but it wasn‚Äôt always the case. The outer readonly would infect the inner Ts.</p>
<p>Our initial whack at this was to come up with shallow variants of all the permissions. This yielded keywords that became a never-ending source of jokes in our hallways: shreadable, shimmutable, and ‚Äì our favorite ‚Äì shisolated (which sounds like a German swear word when said aloud). Our original justification for such nonsense was that in C#, the signed and unsigned versions of some types used abbreviations (sbyte, uint, etc.), and shallow sure would make them quite lengthy, so we were therefore justified in our shortening into a sh prefix. How wrong we were.</p>
<p>From there, we ditched the special permissions and recognized that objects had ‚Äúlayers‚Äù, and that outer and inner layers might have differing permissions. This was the right idea, but like most ideas of this nature, we let the system get inordinately more complex, before recognizing the inner beauty and collapsing it back down to its essence.</p>
<p>At the tail end of our project, we were working to integrate our ideas back into C# and .NET proper. That‚Äôs when I was adamant that we unify the concept of readable with readonly, leading to several keyword renames. Ironically, despite me having left .NET to pursue this project several years earlier, I was the most optimistic out of anybody that this could be done tastefully. Sadly, it turned out I was wrong, and the project barely got off the ground before getting axed, however the introductory overview above is my best approximation of what it would have looked like.
Inspirations</p>
<p>Now that we have seen the system in its final state, let‚Äôs now trace the roots back to those systems that were particularly inspiring for us. In a picture:</p>
<p>Influences</p>
<p>I‚Äôll have to be brief here, since there is so much ground to cover, although there will be many pointers to follow up papers should you want to dive deeper. In fact, I read something like 5-10 papers per week throughout the years I was working on all of this stuff, as evidenced by the gigantic tower of papers still sitting in my office:</p>
<p>Concurrency Paper Stack
const</p>
<p>The similarities with const should, by now, be quite evident. Although people generally have a love/hate relationship with it, I‚Äôve always found that being const correct is worth the effort for anything bigger than a hobby project. (I know plenty of people who would disagree with me.)</p>
<p>That said, const is best known for its unsoundness, thanks to the pervasive use of const_cast. This is commonly used at the seams of libraries with different views on const correctness, although it‚Äôs also often used to cheat; this is often for laziness, but also due to some compositional short-comings. The lack of parameterization over const, for example, forces one to duplicate code; faced with that, many developers would rather just cast it away.</p>
<p>const is also not deep in the same way that our permissions were, which was required to enable the safe concurrency, isolation, and immutability patterns which motivated the system. Although many of the same robustness benefits that const correctness delivers were brought about by our permissions system, that wasn‚Äôt its original primary motivation.
Alias Analysis</p>
<p>Although it‚Äôs used more as a compiler analysis technique than it is in type systems, alias analysis is obviously a close cousin to all the work we did here. Although the relationship is distant, we looked closely at many uses of aliasing annotations in C(++) code, including __declspec(noalias) in Visual C++ and restrict (__restrict, <strong>restrict</strong>, etc.) in GCC and standard C. In fact, some of our ideas around isolated eventually assisted the compiler in performing better alias analysis.
Linear Types</p>
<p>Phillip Wadler‚Äôs 1990 ‚ÄúLinear types can change the world!‚Äù was immensely influential for me in the early days. I remember a huge lightbulb going off when I first read this paper. Linear types are inspired by the linear logic of J.-Y. Girard, and it is easy to get lost in the mathematics for hours.</p>
<p>In a nutshell, a linear type lets you prove that a variable is used exactly once. This is similar to isolated, however due to the aliasing properties of an imperative language like C# (especially for heap structures with possible cycles between them), the simple and elegant model of strict linearity is hard to make work.</p>
<p>Linear types themselves also aren‚Äôt very commonly seen in the wild, and are mostly useful for their mathematical and proof properties. If you go looking, you will find examples, however. More than real syntax in real languages, linear types have been hugely influential on subsequent innovations in type systems that also impacted us, such as affine and uniqueness types.
Haskell Monads</p>
<p>In the early days, I was pretty obsessed with Haskell, to put it mildly.</p>
<p>I often describe the above system that we built as the inverse of the Haskell state monad. In Haskell, what you had was a purely functional language, with sugar to make certain aspects look imperative. If you wanted side-effects, you needed to enter the beautiful world of monads. In particular, for simple memory side-effects, the state monad let you have traditional mutable data structures, but in a way that the type system very much understood and could restrict for safety where appropriate.</p>
<p>Well, the system we built was sort of the opposite: you were in an imperative language, and had a way of marking certain aspects of the program as being purely functional. I am pretty sure I read the classic ‚ÄúState in Haskell‚Äù paper at least a dozen times over the years. In fact, as soon as I recognized the similarities, I compared notes with Simon Peyton-Jones, who was immensely gracious and helpful in working through some very difficult type system design challenges.
Effect Types</p>
<p>Effect typing, primarily in the ML community, was also influential in the early days. An effect type propagates information at compile-time describing the dynamic effect(s) executing said code is expected to bring about. This can be useful for checking many properties.</p>
<p>For example, I always thought of await and throws annotations as special kinds of effects that indicate a method might block or throw an exception, respectively. Thanks to the additive and subtractive nature of effect types, they propagate naturally, and are even amenable to parametric polymorphism.</p>
<p>It turns out that permissions can be seen as a kind of effect, particularly when annotating an instance method. In a sense, a mutable instance method, when invoked, has the ‚Äúeffect‚Äù of mutating the receiving object. This realization was instrumental in pushing me towards leveraging subtyping for modeling the relationship between permissions.</p>
<p>Related to this, the various ownership systems over the years were also top-of-mind, particularly given Midori‚Äôs heritage with Singularity, which used the Spec# language. This language featured ownership annotations.
Regions</p>
<p>Regions, despite classically being used mostly for deterministic and efficient memory management, were incredibly interesting towards the days of figuring out isolated.</p>
<p>They aren‚Äôt identical for several reasons, however.</p>
<p>The first reason is that isolated object graphs in our system weren‚Äôt as strictly partitioned as regions, due to immutable in- and out- references. Regions are traditionally used to collect memory efficiently and hence dangling references like this wouldn‚Äôt be permitted (and the reachability analysis to detect them would basically devolve into garbage collection).</p>
<p>The second reason is that we wanted to avoid the syntactic burden of having regions in the language. A good example of this in action is Deterministic Parallel Java, which requires explicit region annotations on objects using a very generics-like syntax (e.g., Foo<region R>). Some amount of this can be hidden from the developer through more sophisticated compiler analysis ‚Äì much like Cyclone did ‚Äì however, we worried that in some very common cases, regions would rear their ugly heads and then the developer would be left confused and dismayed.</p>
<p>All that said, given our challenges with garbage collection, in addition to our sub-process actor model, we often pondered whether some beautiful unification of isolated object graphs and regions awaited our discovery.
Separation Logic</p>
<p>Particularly in the search for formalisms to prove the soundness of the system we built, separation logic turned out to be instrumental, especially the concurrent form. This is a formal technique for proving the disjointness of different parts of the heap, which is very much what our system is doing with the safe concurrency abstractions built atop the isolated primitive. In particular, our OOPSLA paper used a novel proof technique, Views, which can be constructed from separation algebras. Caution: this is getting into some very deep mathematical territory; several colleagues far smarter than I am were the go-to guys on all of this. But, it certainly helped all of us sleep better at night.
Uniqueness Types</p>
<p>Uniqueness types are a more recent invention, derived from some of the early linear type systems which so fascinated me early on. For a period of time, we actually had a unique keyword in the language. Eventually we folded that back into the concept of isolated (it was essentially a ‚Äúshallow‚Äù isolated). But there is no denying that all of this was heavily inspired by what we saw with uniqueness types, especially in languages like Clean, the experimental work to bring uniqueness to Scala, and, now, Rust.
Model Checking</p>
<p>Finally, I would be remiss if I didn‚Äôt at least mention model checking. It‚Äôs easy to confuse this with static analysis, however, model checking is far more powerful and complete, in that it goes beyond heuristics and therefore statistics. MSR‚Äôs Zing and, although we used it to verify the correctness of certain aspects of our implementation, I don‚Äôt think we sufficiently considered how model checking might impact the way safety was attained. This was top-of-mind as we faced intra-process interleaving race conditions. Especially as we look to the future with more distributed-style concurrency than intra-process parallelism, where state machine verification is critical, many key ideas in here are relevant.
Other Languages</p>
<p>This story spans many years. During those years, we saw several other languages tackling similar challenges, sometimes in similar ways. Because of the complex timeline, it‚Äôs hard to trace every single influence to a given point in time, however it‚Äôs fair to say that four specific languages had a noteworthy influence on us.</p>
<p>(Note that there are dozens of influential concurrent and parallel languages that inspired our work. I‚Äôm sure I haven‚Äôt read everything there is to read ‚Äì there‚Äôs always more to learn ‚Äì however I did my best to survey the field. I will focus here on the most mainstream and relevant to people writing production code in the year 2016.)
(Modern) C++</p>
<p>I already mentioned const and its influence.</p>
<p>It is also interesting to note the similarities between isolated and C++11‚Äôs std::unique_ptr. Although born in different times, and in very different worlds, they both clearly deliver a similar perspective on ownership. Noted difference include deepness ‚Äì C++‚Äôs approach is ‚Äúdeep‚Äù insofar as you leverage RAII faithfully in your data structures ‚Äì and motivations ‚Äì C++‚Äôs motivation being primarily memory management, and neither safe concurrency nor immutability.</p>
<p>The concept of constexpr has obvious similarities to both isolated and immutable, particularly the compile-time evaluation and freezing of the results. The continued evolution of constexpr in C++13 and C++17 is taking the basic building blocks to new frontiers that I had always wanted to do with our system, but never had time, like arbitrary compile-time evaluation of expressions, and freezing/memoization of the results.</p>
<p>Thankfully, because I was leading the C++ group at Microsoft for some time after Midori, I was able to bring many of our lessons learned to the discussion, and I like to think it has had a positive impact on evolving C++ even further.
D</p>
<p>The system we came up with has obvious comparisons to D‚Äôs take on const and immutable; just as D‚Äôs const is a view over mutable or immutable data, so too is our readonly. And just as D added deepness to the concept of const, so did we in our permissions model generally. This is perhaps the closest analogy in any existing systems. I am frankly surprised it doesn‚Äôt get used an order of magnitude more than it does, although Andrei, one of its chief developers, has some thoughts on that topic.
Go</p>
<p>Although I personally love programming in Go, it didn‚Äôt have as much influence on our system as you might expect. Go lists concurrency as one of its primary features. Although concurrency is easy to generate thanks to goroutines, and best practices encourage wonderful things like ‚ÄúShare Memory by Communicating‚Äù, the basic set of primitives doesn‚Äôt go much beyond the threads, thread-pools, locks, and events that I mention us beginning with in the early days of this journey.</p>
<p>On one hand, I see that Go has brought its usual approach to bear here; namely, eschewing needless complexity, and exposing just the bare essentials. I compare this to the system we built, with its handful of keywords and associated concept count, and admire the simplicity of Go‚Äôs approach. It even has nice built-in deadlock detection. And yet, on the other hand, when I find myself debugging classical data races, and torn structs or interfaces, I clamor for more. I have remarked before that simply running with GOMAXPROCS=1, coupled with a simple RPC system ‚Äì ideally integrated in such a way where you needn‚Äôt step outside of Go‚Äôs native type system ‚Äì can get you close to the simple ‚Äúno intra-process parallelism‚Äù Midori model that we began with. And perhaps the best sweet spot of all.
Rust</p>
<p>Out of the bunch, Rust has impressed me the most. They have delivered on much of what we set out to deliver with Midori, but actually shipped it (whereas we did not). My hat goes off to that team, seriously, because I know first hand what hard, hard, hard work this level of type system hacking is.</p>
<p>I haven‚Äôt yet described our ‚Äúborrowed references‚Äù system, or the idea of auto-destructible types, however when you add those into the mix, the underlying type system concepts are remarkably similar. Rust is slightly less opinionated on the overall architecture of your system than Midori was, which means it is easier to adopt piecemeal, however the application of these concepts to traditional concurrency mechanisms like locks is actually fascinating to see.</p>
<p>This article gives a great whirlwind tour of safe concurrency in Rust. Poking through to some of the references reveals APIs designed with similar principles in mind. For example, simple_parallel looks a whole lot like the PFX Parallel API described earlier with safety annotations applied to it. I trust their system more than ours, because they have shipped and had thousands of eyes and real-world experience applied to it.
Epilogue and Conclusion</p>
<p>Although I‚Äôve glossed over many details, I hope you enjoyed the journey, and that the basic ideas were clear. And, most importantly, that you learned something new. If you want to understand anything in greater detail, please see our OOPSLA paper, or just ask.</p>
<p>It‚Äôs been a couple years since I‚Äôve been away from this. As most of you know, Midori happened before the OSS renaissance at Microsoft, and so it never saw the light of day. In that time, I‚Äôve pondered what lessons we learned on this journey, and whether any of it is relevant beyond the hallways of our old building 34. I believe it is, otherwise I‚Äôd not have taken the time to write up this article.</p>
<p>I‚Äôm thrilled that the world has adopted tasks in a big way, although it was for a different reason than we expected (asynchrony and not parallelism). In many ways this was inevitable, however I have to think that doing tasks a half-decade ahead of the curve at least had a minor influence, including the async and await ideas built atop it.</p>
<p>Data parallelism has taken off‚Ä¶sort of. Far fewer people leverage CPUs in the way we imagined, but that‚Äôs for good reason: GPUs are architected for extremely wide SIMD operations over floating points, which is essentially the killer scenario for this sort of parallelism. It doesn‚Äôt cover all of the cases, but man does it scream.</p>
<p>Safe concurrency is still critically important, yet lacking, and the world still needs it. I think we collectively underestimated how long it would take for the industry to move to type- and memory-safe programming models. Despite the increasing popularity of safe systems languages like Go and Rust, it pains me to say it, but I still believe we are a decade away from our fundamental technology stacks ‚Äì like the operating systems themselves ‚Äì being safe to the core. But our industry desperately needs this to happen, given that buffer errors remain the #1 attack type for critical security vulnerabilities in our software.</p>
<p>I do think that concurrency-safety will be our next frontier after type- and memory-safety have arrived. TOCTOU, and race conditions generally, are an underexploited yet readily attackable vector. (Thankfully, just as writing correct concurrent code is hard, so too is provoking a latent concurrency error through the delicate orchestration of race conditions). As more systems become concurrent (distributed) systems this will become an increasing problem for us. It‚Äôs not clear the exact formulation of techniques I demonstrated above is the answer ‚Äì in fact, given our focus on parallelism over asynchrony, surely it is not ‚Äì however we will need some answer. It‚Äôs just too damn hard to build robust, secure, and safe concurrent programs, still, to this day, 15 years later.</p>
<p>In particular, I‚Äôm still conflicted about whether all those type system extensions were warranted. Certainly immutability helped with things far beyond safe concurrency. And so did the side-effect annotations, as they commonly helped to root out bugs caused by unintended side-effects. The future for our industry is a massively distributed one, however, where you want simple individual components composed into a larger fabric. In this world, individual nodes are less ‚Äúprecious‚Äù, and arguably the correctness of the overall orchestration will become far more important. I do think this points to a more Go-like approach, with a focus on the RPC mechanisms connecting disparate pieces.</p>
<p>The model of leveraging decades of prior research was fascinating and I‚Äôm so happy we took this approach. I literally tried not to invent anything new. I used to joke that our job was to sift through decades of research and attempt to combine them in new and novel ways. Although it sounds less glamorous, the reality is that this is how a lot of our industry‚Äôs innovation takes place; very seldom does it happen by inventing new ideas out of thin air.</p>
<p>Anyway, there you have it. Next up in the series, we will talk about Battling the GC.</p>

</div>

        </div>

    </body>

</html>
